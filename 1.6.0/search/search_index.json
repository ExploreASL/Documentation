{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ExploreASL Description Installation Workflow Documentation ExploreASL team Acknowledgments How to cite Description ExploreASL is a pipeline and toolbox for image processing and statistics of arterial spin labeling perfusion MR images. It is designed as a multi-OS , open source, collaborative framework that facilitates cross-pollination between image processing method developers and clinical investigators. The software provides a complete head-to-tail approach that runs fully automatically, encompassing all necessary tasks from data import and structural segmentation, registration and normalization, up to CBF quantification. In addition, the software package includes and quality control ( QC ) procedures and region-of-interest ( ROI ) as well as voxel-wise analysis on the extracted data. To-date, ExploreASL has been used for processing ~10000 ASL datasets from all major MRI vendors and ASL sequences, and a variety of patient populations, representing ~30 studies. The ultimate goal of ExploreASL is to combine data from multiple studies to identify disease related perfusion patterns that may prove crucial in using ASL as a diagnostic tool and enhance our understanding of the interplay of perfusion and structural changes in neurodegenerative pathophysiology. Additionally, this (semi-)automatic pipeline allows us to minimize manual intervention, which increases the reproducibility of studies. Installation To use ExploreASL within Matlab, you can download a stable release version from the GitHub releases section. Navigate within Matlab to the ExporeASL directory, to make ExploreASL the current working directory. To start ExploreASL from Matlab, type: ExploreASL Workflow Documentation Additional information about ExploreASL can be found in the Neuroimage paper and on the ExploreASL website, including the walkthrough document and how-to videos. Further documentation is work in progress. For any help please contact the lead authors/developers at h.j.mutsaerts@amsterdamumc.nl or j.petr@hzdr.de. ExploreASL team Henk Mutsaerts - co-creator Jan Petr - co-creator Michael Stritt - PhD student, ASPIRE Paul Groot - developer backbone, IT specialist Pieter Vandemaele - developer Matlab BIDS app Luigi Lorenzini - developer ExploreQC Maurice Pasternak - developer GUI Mathijs Dijsselhof - PhD student, Cerebrovascular Age Beatriz Padrela - PhD student, BBB-ASL Sandeep Ganji - developer integration Philips ISD Patricia Clement - developer ASL-BIDS & organizer Acknowledgments This project has received support from the following EU/EFPIA Innovative Medicines Initiatives (1 and 2) Joint Undertakings: EPAD grant no. 115736, AMYPAD grant no. 115952. Additionally, this work received support from the EU-EFPIA Innovative Medicines Initiatives Joint Undertaking (grant No 115952), and Amsterdam Neuroscience . The authors wish to thank the COST-AID (European Cooperation in Science and Technology - Arterial spin labeling Initiative in Dementia) Action BM1103 and the Open Source Initiative for Perfusion Imaging (OSIPI) and the ISMRM Perfusion Study groups for facilitating meetings for researchers to discuss the implementation of ExploreASL. The authors acknowledge Guillaume Flandin, Robert Dahnke, and Paul Schmidt for reviewing the structural module for its implementation of SPM12 , CAT12 , and LST , respectively; Krzysztof Gorgolewksi for his advice on the BIDS implementation; Jens Maus for help with MEX compilation; Cyril Pernet for providing the SPM Univariate Plus QC scripts. Contributors \u2728 Thanks goes to these wonderful people ( emoji key ): Henk Mutsaerts \ud83d\udc68\u200d\ud83d\udd2c \ud83d\udd8b \ud83d\udcbb Jan Petr \ud83d\udc68\u200d\ud83d\udd2c \ud83d\udd8b \ud83d\udcbb Michael Stritt \ud83d\udcbb \ud83d\udd8b \ud83d\udcd6 Paul Groot \ud83d\udcbb \ud83d\udd8b Pieter Vandemaele \ud83d\udcbb \ud83e\udd14 \ud83e\udde0 luislorenzini \ud83d\udcbb \ud83d\udd27 MauricePasternak \ud83d\udcca \ud83d\udcbb \ud83c\udfa8 Patricia Clement \ud83e\udde0 \ud83e\udd14 \ud83d\udcd6 Mathijs Dijsselhof \ud83d\udd8b \ud83e\udde0 Beatriz Padrela \ud83d\udd8b \ud83e\udde0 Sandeep Ganji \ud83d\udd8b \ud83e\udd14 \ud83e\udde0 Martin Craig \ud83d\udd8b \ud83d\udcbb \ud83e\udde0 jozsait \ud83d\udcbb \ud83d\udea7 DaveThoma5 \ud83e\udd14 \ud83e\udde0 This project follows the all-contributors specification. Contributions of any kind welcome! How to cite The bare minimum of references is the ExploreASL manuscript and the used ExploreASL release, which you can find on Zenodo (e.g. version 1.3.0 ). The following provides an example as how to correctly cite ExploreASL and its third-party tools. The versions of the included third-party tools are described in CHANGES.md for each ExploreASL release. The data were analysed using ExploreASL ref1 version x.x.x ref2 , including SPM12 version xxxx ref3 , CAT12 version xxxx ref4 , and LST version x.x.x ref5 . This Matlab-based software was used with Matlab (MathWorks, MA, USA) version x.x (yearx) ref6 . Ref1: the ExploreASL paper, describing the full pipeline and decisions for processing steps: https://www.sciencedirect.com/science/article/pii/S1053811920305176 Ref2: the Zenodo DOI for the actual ExploreASL release used to analyse the data. The release numbers (e.g. 1.3.0) follow semantic versioning . Ref3: SPM12 references: https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib14 & https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib53. Note that the SPM version (e.g. 7219) is adapted and extended for use with ExploreASL. Ref4: CAT12 reference: https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib55. Note that the CAT12 version (e.g. 1364) is adapted for use with ExploreASL. Ref5: LST reference: https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib118. Note that the LST version (e.g. 2.0.15) is adapted for use with ExploreASL. Ref6: Matlab publishes a release twice yearly, which can be reviewed here: https://www.mathworks.com/products/compiler/matlab-runtime.html. You can provide the release number (e.g. 9.4) or year number (e.g. 2018a), or both.","title":"Home"},{"location":"#description","text":"ExploreASL is a pipeline and toolbox for image processing and statistics of arterial spin labeling perfusion MR images. It is designed as a multi-OS , open source, collaborative framework that facilitates cross-pollination between image processing method developers and clinical investigators. The software provides a complete head-to-tail approach that runs fully automatically, encompassing all necessary tasks from data import and structural segmentation, registration and normalization, up to CBF quantification. In addition, the software package includes and quality control ( QC ) procedures and region-of-interest ( ROI ) as well as voxel-wise analysis on the extracted data. To-date, ExploreASL has been used for processing ~10000 ASL datasets from all major MRI vendors and ASL sequences, and a variety of patient populations, representing ~30 studies. The ultimate goal of ExploreASL is to combine data from multiple studies to identify disease related perfusion patterns that may prove crucial in using ASL as a diagnostic tool and enhance our understanding of the interplay of perfusion and structural changes in neurodegenerative pathophysiology. Additionally, this (semi-)automatic pipeline allows us to minimize manual intervention, which increases the reproducibility of studies.","title":"Description"},{"location":"#installation","text":"To use ExploreASL within Matlab, you can download a stable release version from the GitHub releases section. Navigate within Matlab to the ExporeASL directory, to make ExploreASL the current working directory. To start ExploreASL from Matlab, type: ExploreASL","title":"Installation"},{"location":"#workflow","text":"","title":"Workflow"},{"location":"#documentation","text":"Additional information about ExploreASL can be found in the Neuroimage paper and on the ExploreASL website, including the walkthrough document and how-to videos. Further documentation is work in progress. For any help please contact the lead authors/developers at h.j.mutsaerts@amsterdamumc.nl or j.petr@hzdr.de.","title":"Documentation"},{"location":"#exploreasl-team","text":"Henk Mutsaerts - co-creator Jan Petr - co-creator Michael Stritt - PhD student, ASPIRE Paul Groot - developer backbone, IT specialist Pieter Vandemaele - developer Matlab BIDS app Luigi Lorenzini - developer ExploreQC Maurice Pasternak - developer GUI Mathijs Dijsselhof - PhD student, Cerebrovascular Age Beatriz Padrela - PhD student, BBB-ASL Sandeep Ganji - developer integration Philips ISD Patricia Clement - developer ASL-BIDS & organizer","title":"ExploreASL team"},{"location":"#acknowledgments","text":"This project has received support from the following EU/EFPIA Innovative Medicines Initiatives (1 and 2) Joint Undertakings: EPAD grant no. 115736, AMYPAD grant no. 115952. Additionally, this work received support from the EU-EFPIA Innovative Medicines Initiatives Joint Undertaking (grant No 115952), and Amsterdam Neuroscience . The authors wish to thank the COST-AID (European Cooperation in Science and Technology - Arterial spin labeling Initiative in Dementia) Action BM1103 and the Open Source Initiative for Perfusion Imaging (OSIPI) and the ISMRM Perfusion Study groups for facilitating meetings for researchers to discuss the implementation of ExploreASL. The authors acknowledge Guillaume Flandin, Robert Dahnke, and Paul Schmidt for reviewing the structural module for its implementation of SPM12 , CAT12 , and LST , respectively; Krzysztof Gorgolewksi for his advice on the BIDS implementation; Jens Maus for help with MEX compilation; Cyril Pernet for providing the SPM Univariate Plus QC scripts.","title":"Acknowledgments"},{"location":"#contributors","text":"Thanks goes to these wonderful people ( emoji key ): Henk Mutsaerts \ud83d\udc68\u200d\ud83d\udd2c \ud83d\udd8b \ud83d\udcbb Jan Petr \ud83d\udc68\u200d\ud83d\udd2c \ud83d\udd8b \ud83d\udcbb Michael Stritt \ud83d\udcbb \ud83d\udd8b \ud83d\udcd6 Paul Groot \ud83d\udcbb \ud83d\udd8b Pieter Vandemaele \ud83d\udcbb \ud83e\udd14 \ud83e\udde0 luislorenzini \ud83d\udcbb \ud83d\udd27 MauricePasternak \ud83d\udcca \ud83d\udcbb \ud83c\udfa8 Patricia Clement \ud83e\udde0 \ud83e\udd14 \ud83d\udcd6 Mathijs Dijsselhof \ud83d\udd8b \ud83e\udde0 Beatriz Padrela \ud83d\udd8b \ud83e\udde0 Sandeep Ganji \ud83d\udd8b \ud83e\udd14 \ud83e\udde0 Martin Craig \ud83d\udd8b \ud83d\udcbb \ud83e\udde0 jozsait \ud83d\udcbb \ud83d\udea7 DaveThoma5 \ud83e\udd14 \ud83e\udde0 This project follows the all-contributors specification. Contributions of any kind welcome!","title":"Contributors \u2728"},{"location":"#how-to-cite","text":"The bare minimum of references is the ExploreASL manuscript and the used ExploreASL release, which you can find on Zenodo (e.g. version 1.3.0 ). The following provides an example as how to correctly cite ExploreASL and its third-party tools. The versions of the included third-party tools are described in CHANGES.md for each ExploreASL release. The data were analysed using ExploreASL ref1 version x.x.x ref2 , including SPM12 version xxxx ref3 , CAT12 version xxxx ref4 , and LST version x.x.x ref5 . This Matlab-based software was used with Matlab (MathWorks, MA, USA) version x.x (yearx) ref6 . Ref1: the ExploreASL paper, describing the full pipeline and decisions for processing steps: https://www.sciencedirect.com/science/article/pii/S1053811920305176 Ref2: the Zenodo DOI for the actual ExploreASL release used to analyse the data. The release numbers (e.g. 1.3.0) follow semantic versioning . Ref3: SPM12 references: https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib14 & https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib53. Note that the SPM version (e.g. 7219) is adapted and extended for use with ExploreASL. Ref4: CAT12 reference: https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib55. Note that the CAT12 version (e.g. 1364) is adapted for use with ExploreASL. Ref5: LST reference: https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib118. Note that the LST version (e.g. 2.0.15) is adapted for use with ExploreASL. Ref6: Matlab publishes a release twice yearly, which can be reviewed here: https://www.mathworks.com/products/compiler/matlab-runtime.html. You can provide the release number (e.g. 9.4) or year number (e.g. 2018a), or both.","title":"How to cite"},{"location":"ASL_Module/","text":"Submodules of the ASL Module xASL_wrp_CreateAnalysisMask.m Format xASL_wrp_CreateAnalysisMask(x) Description This function creates an analysis mask with the following steps: 0. Create FoV mask (native & MNI spaces) 1. Detect negative vascular signal (native & MNI spaces, within pGM>0.5) 2. Detect peak vascular signal (native & MNI spaces, within pGM==80% percentile on ASL image) 3. Brainmasking & FoV-masking (A) native & B) MNI spaces) - Add WM vascular parts back to the mask (defined as pWM>0.8) & remove extracranial signal In the WM, negative or peak signal is more expected from noise rather than from intra-vascular signal, not many big vessels exist in the WM 4. Save vascular masks 5. Create susceptibility mask (standard space only) Here, we combine manually segmented susceptibility artifact regions in which a population-based susceptibility probability map is created This map is combined (i.e. taking the product) with the mean control & PWI intensity distribution in these regions. This product is thresholded with the average of the 75th percentile & 15% of the intensity (for a bit more robustness against individual variability in sinus sizes). xASL_wrp_PVC.m Format xASL_wrp_PVC(x) Description This submodule performs partial volume correction (PVC) in native ASL space. It runs the Asllani's method for partial volume correction by linear regression. It has two main extensions - first it uses a 3D kernel. Second, it can use a Gaussian weights instead of the default flat kernel. Admin and checking values and files Getting the resolution and preparing parameters Running PV-correction Saving files and cleaning xASL_wrp_PreparePV.m Format xASL_wrp_PreparePV(x, bStandardSpace) Description This submodule prepares partial volume correction (PVC) by creating correct PV maps in ASL resolution, in native space, as well as in standard space if requested (to perform PVC in standard space): If bStandardSpace: Create dummy upsampled ASL scan, for registration Reslice pGM & pWM to hi-res ASL Estimate effective spatial resolution of ASL Smooth pGM & pWM to this spatial resolution Move smoothed tissue posteriors to MNI space else: run step 3 only, which will use the effective spatial resolution that is default for the respective sequence: 2D EPI: [1 1 1] * VoxelSize 3D GRASE: [1.1 1.1 1.38] * VoxelSize 3D spiral: [4.3 4.4 10.1] * VoxelSize (assuming GE uses the upsampled 2x2x4 mm & run steps 1&2, but in native space these entail presmoothing & downsampling. xASL_wrp_ProcessM0.m Format xASL_wrp_ProcessM0(x) Description This submodule performs the image processing and quantification of M0 maps (if they exist), with the following steps: Register M0 to mean control if it exists Before registration, contrast is equalized between the images & biasfields are removed Quantify M0 (correction scale slope & incomplete T1 recovery) Masking & smoothing of M0 image, either using: A) traditional technique (very sharp masking & little smoothing) B) new ExploreASL-specific technique: * extrapolating outside mask (avoiding artifacts from too much or too little masking) * smooth very extensively, to create a biasfield (increases robustness & comparison of M0 between sequences/patients) Any M0 will be processed here. Even if part of the subjects does not have an M0, since this can be later imputed, or an average population M0 image could be used. Also, without background suppression and without an M0, the MeanControl image is before saved as M0, and will be processed here as well. Note that any voxel-size differences between M0 and ASL are allowed here: step 0B below rescales the PD inside an M0 voxel to the same as the ASL resolution (assuming a voxel with half volume contains half the amount of protons). The M0 is further processed in standard space, and reduced to a biasfield. For the quantification in standard space, the PWI and M0 are now by definition in the same space. Also, the standard space M0 biasfield is resampled to the native PWI space (at the end of step 3B), ensuring that both are also in the same native space. xASL_wrp_Quantify.m Format xASL_wrp_Quantify(x) Description This submodule converts PWIs to quantified CBF maps (or related derivatives). Note that we don't delete x.P.Path_PWI4D here, as this NIfTI file may be needed by xASL_wrp_VisualQC_ASL.m Load PWI Prepare M0 Hematocrit & blood T1 correction ASL & M0 parameters comparisons Load SliceGradient Initialize & define quantification parameters Define labeling efficiency Perform quantification Save files Perform FEAST quantification (if exist) Create standard space masked image to visualize masking effect xASL_wrp_RealignASL.m Format xASL_wrp_RealignASL(x[,bSubtraction]) Description This submodule estimates motion by spm_realign, which uses a rigid-body registration (3 translations, 3 rotations). It runs ENABLE to reject outliers and provides a visualization. ENABLE, QC and visualizations are based on the Net Displacement Vector (NDV) (in mm): according to Pythagorean/Euclydian RMS https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=ind1211&L=fsl&P=R34458&1=fsl&9=A&J=on&d=No+Match%3BMatch%3BMatches&z=4 view this link for image of rotation roll, pitch and yaw https://www.google.nl/search?q=rotation+pitch+yaw+roll&espv=2&tbm=isch&imgil=LW3Nn1K-L6Oc7M%253A%253B-aSyykkRityJoM%253Bhttp%25253A%25252F%25252Fwww.grc.nasa.gov%25252FWWW%25252Fk-12%25252Fairplane%25252Frotations.html&source=iu&usg=__MlLQ5VuyRbm6kZP0vBJlPxmfbkw%3D&sa=X&ei=TWfjU4WcK4bqyQPqu4Fo&ved=0CD8Q9QEwBQ&biw=1680&bih=946#facrc=_&imgdii=_&imgrc=LW3Nn1K-L6Oc7M%253A%3B-aSyykkRityJoM%3Bhttp%253A%252F%252Fwww.grc.nasa.gov%252FWWW%252Fk-12%252Fairplane%252FImages%252Frotations.gif%3Bhttp%253A%252F%252Fwww.grc.nasa.gov%252FWWW%252Fk-12%252Fairplane%252Frotations.html%3B709%3B533 This submodule performs the following steps: Estimate motion Calculate and plot position and motion parameters Threshold-free spike definition (based on ENABLE, but with t-stats rather than the threshold p<0.05) Remove spike frames from nifti xASL_wrp_RegisterASL.m Format xASL_wrp_RegisterASL(x) Description This submodule registers ASL images to T1w space, by using a combination of the registration techniques below. Note that in the absence of raw structural files (i.e. T1.nii[.gz] or T1_ORI.nii[.gz], it will recreate dummy files from standard space to do this registration M0-T1w rigid-body -> this works well in 2D EPI sequences PWI-pGM rigid-body -> this is robust across sequences with different readouts and consequently different effective spatial resolutions. With low spatial resolution (e.g. GE 3D spiral product sequence), M0-T1w registration may not work, but PWI-pGM will work. PWI-pGM registration fails with large (vascular) artifacts, therefore this is performed only with relatively low spatial CoV. PWI-pGM affine -> If the spatial CoV is sufficiently low, this can improve the registration These images are registered to ASL templates that were inversely transformed from MNI to the T1w space (& resampled to the ASL space) As this would have an ever higher similarity with the M0 & PWI This submodule performs the following steps: 0. Administration: - A. ASL4D is dealth with, if motion peaks were removed this is called despiked_ASL4D - B. a default \"OtherList\" is specified. This is used every registration instance, except for removing the ref and src NIfTIs used in the registration instance. Also, inside the registration function the unexisting OtherList NIfTIs are skipped - C. Define paths to the ASL templates - D. Previous registration output files are removed - E. Allow registration without structural data - F. native->MNI transformation flow field y_T1.nii is smoothed to the effective ASL resolution y_ASL.nii - G. Registration contrasts are dealth with: x.bRegistrationContrast - specifies the image contrast used for registration (OPTIONAL, DEFAULT = 2): - 0 = Control->T1w - 1 = CBF->pseudoCBF from template/pGM+pWM (skip if sCoV>0.667) - 2 = automatic (mix of both) - 3 = option 2 & force CBF->pseudoCBF irrespective of sCoV or Tanimoto coefficient - H. Dummy src NIfTIs are created: mean_control.nii to register with T1w mean_PWI_Clipped.nii to register with pseudoCBF - I. Create reference images, downsampled pseudoTissue Registration Center of Mass Registration ASL -> anat (Control->T1w) (this step is only applied if it improves the Tanimoto coefficient) Registration CBF->pseudoCBF (this step is only applied if it improves the Tanimoto coefficient). Also, this step is only applied if the spatial CoV<0.67. Note that this is usually the case for 3D scans because of their lower effective spatial resolution. x.bAffineRegistration - specifies the ASL-T1w rigid-body registration is followed up by an affine registration (OPTIONAL, DEFAULT = 0) - 0 = affine registration disabled - 1 = affine registration enabled - 2 = affine registration automatically chosen based on spatial CoV of PWI x.bDCTRegistration - Specifies if to include the DCT registration on top of Affine, all other requirements for affine are thus also taken into account (OPTIONAL, DEFAULT = 0) - 0 = DCT registration disabled - 1 = DCT registration enabled if affine enabled and conditions for affine passed - 2 = DCT enabled as above, but use PVC on top of it to get the local intensity scaling right xASL_wrp_ResampleASL.m Format xASL_wrp_ResampleASL(x) Description This submodule resamples native space NIfTIs to standard space, using the deformation fields computed in the structural module after smoothing these transformation fields to the ASL resolution. The applied interpolation is a combination of all transformations (e.g. motion correction, registration to T1w, and transformation of T1w to standard space. This submodule performs the following steps: Administration Warp TopUp QC files Create slice gradient image for quantification reference, in case of 2D ASL Resample ASL time series to MNI space Resample to native space (applying any motion correction or registration) Bilateral filter (currently disabled) Create mean control image, if available, in native & standard space Clone mean control image to be used as pseudo-M0 (if x.M0==UseControlAsM0) Pair-wise subtraction & saving PWI & PWI4D in both spaces Save PWI NIfTI & time-series-related maps (SD, SNR) Delete temporary files Report spatial CoV as QC xASL_wrp_VisualQC_ASL.m Format xASL_wrp_VisualQC_ASL(x) Description This submodule performs several visualizations for visual & quantitative QC. After initial admin It starts with making ASL NIfTIs ready for visualization & conversion to DICOM (though skipped by default) Then it performs a collection of visualizations Visualizes results of the TopUp geometric distortion correction Visualization of slice gradient Visualization & calculation of temporal QC parameters Compute DICE overlap/intersection of ASL brain in FoV & T1w, to calculate coverage Summarize orientation & check left-right flips Collect several other parameters & store in PDF overview","title":"Module ASL"},{"location":"ASL_Module/#submodules-of-the-asl-module","text":"","title":"Submodules of the ASL Module"},{"location":"ASL_Module/#xasl_wrp_createanalysismaskm","text":"","title":"xASL_wrp_CreateAnalysisMask.m"},{"location":"ASL_Module/#format","text":"xASL_wrp_CreateAnalysisMask(x)","title":"Format"},{"location":"ASL_Module/#description","text":"This function creates an analysis mask with the following steps: 0. Create FoV mask (native & MNI spaces) 1. Detect negative vascular signal (native & MNI spaces, within pGM>0.5) 2. Detect peak vascular signal (native & MNI spaces, within pGM==80% percentile on ASL image) 3. Brainmasking & FoV-masking (A) native & B) MNI spaces) - Add WM vascular parts back to the mask (defined as pWM>0.8) & remove extracranial signal In the WM, negative or peak signal is more expected from noise rather than from intra-vascular signal, not many big vessels exist in the WM 4. Save vascular masks 5. Create susceptibility mask (standard space only) Here, we combine manually segmented susceptibility artifact regions in which a population-based susceptibility probability map is created This map is combined (i.e. taking the product) with the mean control & PWI intensity distribution in these regions. This product is thresholded with the average of the 75th percentile & 15% of the intensity (for a bit more robustness against individual variability in sinus sizes).","title":"Description"},{"location":"ASL_Module/#xasl_wrp_pvcm","text":"","title":"xASL_wrp_PVC.m"},{"location":"ASL_Module/#format_1","text":"xASL_wrp_PVC(x)","title":"Format"},{"location":"ASL_Module/#description_1","text":"This submodule performs partial volume correction (PVC) in native ASL space. It runs the Asllani's method for partial volume correction by linear regression. It has two main extensions - first it uses a 3D kernel. Second, it can use a Gaussian weights instead of the default flat kernel. Admin and checking values and files Getting the resolution and preparing parameters Running PV-correction Saving files and cleaning","title":"Description"},{"location":"ASL_Module/#xasl_wrp_preparepvm","text":"","title":"xASL_wrp_PreparePV.m"},{"location":"ASL_Module/#format_2","text":"xASL_wrp_PreparePV(x, bStandardSpace)","title":"Format"},{"location":"ASL_Module/#description_2","text":"This submodule prepares partial volume correction (PVC) by creating correct PV maps in ASL resolution, in native space, as well as in standard space if requested (to perform PVC in standard space): If bStandardSpace: Create dummy upsampled ASL scan, for registration Reslice pGM & pWM to hi-res ASL Estimate effective spatial resolution of ASL Smooth pGM & pWM to this spatial resolution Move smoothed tissue posteriors to MNI space else: run step 3 only, which will use the effective spatial resolution that is default for the respective sequence: 2D EPI: [1 1 1] * VoxelSize 3D GRASE: [1.1 1.1 1.38] * VoxelSize 3D spiral: [4.3 4.4 10.1] * VoxelSize (assuming GE uses the upsampled 2x2x4 mm & run steps 1&2, but in native space these entail presmoothing & downsampling.","title":"Description"},{"location":"ASL_Module/#xasl_wrp_processm0m","text":"","title":"xASL_wrp_ProcessM0.m"},{"location":"ASL_Module/#format_3","text":"xASL_wrp_ProcessM0(x)","title":"Format"},{"location":"ASL_Module/#description_3","text":"This submodule performs the image processing and quantification of M0 maps (if they exist), with the following steps: Register M0 to mean control if it exists Before registration, contrast is equalized between the images & biasfields are removed Quantify M0 (correction scale slope & incomplete T1 recovery) Masking & smoothing of M0 image, either using: A) traditional technique (very sharp masking & little smoothing) B) new ExploreASL-specific technique: * extrapolating outside mask (avoiding artifacts from too much or too little masking) * smooth very extensively, to create a biasfield (increases robustness & comparison of M0 between sequences/patients) Any M0 will be processed here. Even if part of the subjects does not have an M0, since this can be later imputed, or an average population M0 image could be used. Also, without background suppression and without an M0, the MeanControl image is before saved as M0, and will be processed here as well. Note that any voxel-size differences between M0 and ASL are allowed here: step 0B below rescales the PD inside an M0 voxel to the same as the ASL resolution (assuming a voxel with half volume contains half the amount of protons). The M0 is further processed in standard space, and reduced to a biasfield. For the quantification in standard space, the PWI and M0 are now by definition in the same space. Also, the standard space M0 biasfield is resampled to the native PWI space (at the end of step 3B), ensuring that both are also in the same native space.","title":"Description"},{"location":"ASL_Module/#xasl_wrp_quantifym","text":"","title":"xASL_wrp_Quantify.m"},{"location":"ASL_Module/#format_4","text":"xASL_wrp_Quantify(x)","title":"Format"},{"location":"ASL_Module/#description_4","text":"This submodule converts PWIs to quantified CBF maps (or related derivatives). Note that we don't delete x.P.Path_PWI4D here, as this NIfTI file may be needed by xASL_wrp_VisualQC_ASL.m Load PWI Prepare M0 Hematocrit & blood T1 correction ASL & M0 parameters comparisons Load SliceGradient Initialize & define quantification parameters Define labeling efficiency Perform quantification Save files Perform FEAST quantification (if exist) Create standard space masked image to visualize masking effect","title":"Description"},{"location":"ASL_Module/#xasl_wrp_realignaslm","text":"","title":"xASL_wrp_RealignASL.m"},{"location":"ASL_Module/#format_5","text":"xASL_wrp_RealignASL(x[,bSubtraction])","title":"Format"},{"location":"ASL_Module/#description_5","text":"This submodule estimates motion by spm_realign, which uses a rigid-body registration (3 translations, 3 rotations). It runs ENABLE to reject outliers and provides a visualization. ENABLE, QC and visualizations are based on the Net Displacement Vector (NDV) (in mm): according to Pythagorean/Euclydian RMS https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=ind1211&L=fsl&P=R34458&1=fsl&9=A&J=on&d=No+Match%3BMatch%3BMatches&z=4 view this link for image of rotation roll, pitch and yaw https://www.google.nl/search?q=rotation+pitch+yaw+roll&espv=2&tbm=isch&imgil=LW3Nn1K-L6Oc7M%253A%253B-aSyykkRityJoM%253Bhttp%25253A%25252F%25252Fwww.grc.nasa.gov%25252FWWW%25252Fk-12%25252Fairplane%25252Frotations.html&source=iu&usg=__MlLQ5VuyRbm6kZP0vBJlPxmfbkw%3D&sa=X&ei=TWfjU4WcK4bqyQPqu4Fo&ved=0CD8Q9QEwBQ&biw=1680&bih=946#facrc=_&imgdii=_&imgrc=LW3Nn1K-L6Oc7M%253A%3B-aSyykkRityJoM%3Bhttp%253A%252F%252Fwww.grc.nasa.gov%252FWWW%252Fk-12%252Fairplane%252FImages%252Frotations.gif%3Bhttp%253A%252F%252Fwww.grc.nasa.gov%252FWWW%252Fk-12%252Fairplane%252Frotations.html%3B709%3B533 This submodule performs the following steps: Estimate motion Calculate and plot position and motion parameters Threshold-free spike definition (based on ENABLE, but with t-stats rather than the threshold p<0.05) Remove spike frames from nifti","title":"Description"},{"location":"ASL_Module/#xasl_wrp_registeraslm","text":"","title":"xASL_wrp_RegisterASL.m"},{"location":"ASL_Module/#format_6","text":"xASL_wrp_RegisterASL(x)","title":"Format"},{"location":"ASL_Module/#description_6","text":"This submodule registers ASL images to T1w space, by using a combination of the registration techniques below. Note that in the absence of raw structural files (i.e. T1.nii[.gz] or T1_ORI.nii[.gz], it will recreate dummy files from standard space to do this registration M0-T1w rigid-body -> this works well in 2D EPI sequences PWI-pGM rigid-body -> this is robust across sequences with different readouts and consequently different effective spatial resolutions. With low spatial resolution (e.g. GE 3D spiral product sequence), M0-T1w registration may not work, but PWI-pGM will work. PWI-pGM registration fails with large (vascular) artifacts, therefore this is performed only with relatively low spatial CoV. PWI-pGM affine -> If the spatial CoV is sufficiently low, this can improve the registration These images are registered to ASL templates that were inversely transformed from MNI to the T1w space (& resampled to the ASL space) As this would have an ever higher similarity with the M0 & PWI This submodule performs the following steps: 0. Administration: - A. ASL4D is dealth with, if motion peaks were removed this is called despiked_ASL4D - B. a default \"OtherList\" is specified. This is used every registration instance, except for removing the ref and src NIfTIs used in the registration instance. Also, inside the registration function the unexisting OtherList NIfTIs are skipped - C. Define paths to the ASL templates - D. Previous registration output files are removed - E. Allow registration without structural data - F. native->MNI transformation flow field y_T1.nii is smoothed to the effective ASL resolution y_ASL.nii - G. Registration contrasts are dealth with: x.bRegistrationContrast - specifies the image contrast used for registration (OPTIONAL, DEFAULT = 2): - 0 = Control->T1w - 1 = CBF->pseudoCBF from template/pGM+pWM (skip if sCoV>0.667) - 2 = automatic (mix of both) - 3 = option 2 & force CBF->pseudoCBF irrespective of sCoV or Tanimoto coefficient - H. Dummy src NIfTIs are created: mean_control.nii to register with T1w mean_PWI_Clipped.nii to register with pseudoCBF - I. Create reference images, downsampled pseudoTissue Registration Center of Mass Registration ASL -> anat (Control->T1w) (this step is only applied if it improves the Tanimoto coefficient) Registration CBF->pseudoCBF (this step is only applied if it improves the Tanimoto coefficient). Also, this step is only applied if the spatial CoV<0.67. Note that this is usually the case for 3D scans because of their lower effective spatial resolution. x.bAffineRegistration - specifies the ASL-T1w rigid-body registration is followed up by an affine registration (OPTIONAL, DEFAULT = 0) - 0 = affine registration disabled - 1 = affine registration enabled - 2 = affine registration automatically chosen based on spatial CoV of PWI x.bDCTRegistration - Specifies if to include the DCT registration on top of Affine, all other requirements for affine are thus also taken into account (OPTIONAL, DEFAULT = 0) - 0 = DCT registration disabled - 1 = DCT registration enabled if affine enabled and conditions for affine passed - 2 = DCT enabled as above, but use PVC on top of it to get the local intensity scaling right","title":"Description"},{"location":"ASL_Module/#xasl_wrp_resampleaslm","text":"","title":"xASL_wrp_ResampleASL.m"},{"location":"ASL_Module/#format_7","text":"xASL_wrp_ResampleASL(x)","title":"Format"},{"location":"ASL_Module/#description_7","text":"This submodule resamples native space NIfTIs to standard space, using the deformation fields computed in the structural module after smoothing these transformation fields to the ASL resolution. The applied interpolation is a combination of all transformations (e.g. motion correction, registration to T1w, and transformation of T1w to standard space. This submodule performs the following steps: Administration Warp TopUp QC files Create slice gradient image for quantification reference, in case of 2D ASL Resample ASL time series to MNI space Resample to native space (applying any motion correction or registration) Bilateral filter (currently disabled) Create mean control image, if available, in native & standard space Clone mean control image to be used as pseudo-M0 (if x.M0==UseControlAsM0) Pair-wise subtraction & saving PWI & PWI4D in both spaces Save PWI NIfTI & time-series-related maps (SD, SNR) Delete temporary files Report spatial CoV as QC","title":"Description"},{"location":"ASL_Module/#xasl_wrp_visualqc_aslm","text":"","title":"xASL_wrp_VisualQC_ASL.m"},{"location":"ASL_Module/#format_8","text":"xASL_wrp_VisualQC_ASL(x)","title":"Format"},{"location":"ASL_Module/#description_8","text":"This submodule performs several visualizations for visual & quantitative QC. After initial admin It starts with making ASL NIfTIs ready for visualization & conversion to DICOM (though skipped by default) Then it performs a collection of visualizations Visualizes results of the TopUp geometric distortion correction Visualization of slice gradient Visualization & calculation of temporal QC parameters Compute DICE overlap/intersection of ASL brain in FoV & T1w, to calculate coverage Summarize orientation & check left-right flips Collect several other parameters & store in PDF overview","title":"Description"},{"location":"About/","text":"About ExploreASL Team Henk Mutsaerts - co-creator Jan Petr - co-creator Michael Stritt - PhD student, ASPIRE Paul Groot - developer backbone, IT specialist Pieter Vandemaele - developer Matlab BIDS app Luigi Lorenzini - developer ExploreQC Maurice Pasternak - developer GUI Mathijs Dijsselhof - PhD student, Cerebrovascular Age Beatriz Padrela - PhD student, BBB-ASL Sandeep Ganji - developer integration Philips ISD Patricia Clement - developer ASL-BIDS & organizer","title":"About"},{"location":"About/#about","text":"","title":"About"},{"location":"About/#exploreasl-team","text":"Henk Mutsaerts - co-creator Jan Petr - co-creator Michael Stritt - PhD student, ASPIRE Paul Groot - developer backbone, IT specialist Pieter Vandemaele - developer Matlab BIDS app Luigi Lorenzini - developer ExploreQC Maurice Pasternak - developer GUI Mathijs Dijsselhof - PhD student, Cerebrovascular Age Beatriz Padrela - PhD student, BBB-ASL Sandeep Ganji - developer integration Philips ISD Patricia Clement - developer ASL-BIDS & organizer","title":"ExploreASL Team"},{"location":"FAQ/","text":"FAQ","title":"FAQ"},{"location":"FAQ/#faq","text":"","title":"FAQ"},{"location":"Functions/","text":"Functions General Functions xASL_Iteration.m Format [bAborted, xOut] = xASL_Iteration(x, moduleName[, dryRun, stopAfterErrors]) Description Parses the settings and runs the DatabaseLoop sub-function. Administration xASL_adm_CatchNumbersFromString.m Format [OutputNumber] = xASL_adm_CatchNumbersFromString(InputString) Description Extracts a number from a char array. xASL_adm_CheckFileCount.m Format [result, files] = xASL_adm_CheckFileCount(path, expr[, mincount, failifmissing]) [result] = xASL_adm_CheckFileCount(...) Description Checks the given PATH for files corresponding to the SPM_SELECT regular expression EXPR . Returns if the number of files is equal to or higher than MINCOUNT . If FAILIFMISSING is true and not enough files, then throw and error. If everything goes ok and second output argument is specified then return also the list of files. xASL_adm_CheckPermissions.m Format [FilesList, FilesExeList, FoldersList] = xASL_adm_CheckPermissions(InputPath[, FilesExecutable]) Description This function does a recursive search through the root folder & makes a list of the attributes of all files and folders. It tries to reset the attributes to what we desire, which is by default: 664 for files (meaning only reading & writing for users & group, & read-only for others) 775 for folders (meaning reading, writing & opening for current user & current group, & for others only reading & opening) For executable files we also want 775. Note that the permission to 'execute a folder' means opening them. DataOK checks data permissions. ExeOK checks executable permissions. DataOK also includes executable permissions for folders. This runs recursively (but currently skips the contents of the root-folder) . xASL_adm_CheckSPM.m Format [spm_path, spm_version] = xASL_adm_CheckSPM([modality, proposed_spm_path, check_mode]) [spm_path] = xASL_adm_CheckSPM(...) xASL_adm_CheckSPM(...) Description Checks if the spm function exists and if the reported version matches our development version ( SPM8 or SPM12 ). If the spm toolbox is not available yet, it will try the PROPOSED_SPM_PATH (if specified) or the user selected directory and add it to PATH . The function will fail if SPM cannot be found or if detecting an unsupported version. xASL_adm_CleanUpBeforeRerun.m Format xASL_adm_CleanupBeforeCompleteRerun(AnalysisDir, iModule, bRemoveWMH, bAllSubjects, SubjectID) Description This function (partly) reverts previous ExploreASL runs, deleting derivatives, while keeping raw data intact. if bAllSubjects==true, then all subjects and all module derivatives will be removed. This function performs the following steps: If a Population folder doesn't exist yet but dartel does, rename it Remove whole-study data files in AnalysisDir if bAllSubjects Remove lock files/folders for reprocessing Restore backupped _ORI (original) files Delete native space CAT12 temporary folders (always, independent of iModule) Remove native space files for iModule Remove standard space files for iModule Remove population module files Remove or clean up stored x-struct & QC file -> THIS HAS NO SESSION SUPPORT YET NB: still need to add xASL_module_func & xASL_module_dwi for EPAD xASL_adm_CompareDataSets.m Format [RMS] = xASL_adm_CompareDataSets(RefAnalysisRoot,SourceAnalysisRoot,x,type,mutexState) Description Compare data sets is used to ... type 0: Only save type 1: Save and evaluate type 2: Only evaluate xASL_adm_CompareLists.m Format [NewList] = xASL_adm_CompareLists(list1, list2) Description This script compares two single dimension lists. xASL_adm_ConvertDate2Nr.m Format [Nr DayInYear] = xASL_adm_ConvertDate2Nr(TempDate) Description Converts date to number input mmdd -> output mm (with days in fractions/floating point). Inverse from ConvertNrDate. xASL_adm_ConvertNr2Time.m Format Time = xASL_adm_ConvertNr2Time(Nr) Description Converts number to time input hh (with minutes in fractions/floating point) -> output hhmm. Inverse from xASL_adm_ConvertTime2Nr. xASL_adm_ConvertSubjSess2Subj_Sess.m Format [iSubj iSess] = xASL_adm_ConvertSubjSess2Subj_Sess(nSessions, iSubjSess) Description Converts combined SubjectSession index to subject & session indices. Useful for data lists in ExploreASL. xASL_adm_ConvertTime2Nr.m Format Nr = xASL_adm_ConvertTime2Nr(Time) Description Converts time to number input hhmm -> output hh (with minutes in fractions/floating point). Inverse from xASL_adm_ConvertNr2Time. xASL_adm_CopyMoveFileList.m Format [List] = xASL_adm_CopyMoveFileList(OriDir, DstDir, StrRegExp, bMove[, bDir, bRecursive, bOverwrite, bVerbose]) Description Moves a file to a file, a file to a directory, or a directory to a directory. It keeps the initial extensions, no unzipping or zipping after the move. But it makes sure that only one of .nii and .nii.gz exists in the destination directory. Useful to split a large database. xASL_adm_CorrectName.m Format strOut = xASL_adm_CorrectName(strIn[, bOption, strExclude]) Description Finds and replaces all non-word characters either by empty space or by an underscore. Optionally leaves in few selected special characters. Note that if '_' is excluded from replacement, but option 2 is on, then underscores are replaced anyway. xASL_adm_CreateFileReport.m Format x = xASL_adm_CreateFileReport(x, bHasFLAIR, bHasMoCo, bHasM0, bHasLongitudinal) Description Prints a summary of created files or the individual modules (i.e. Structural, Longiutudinal & ASL modules). Provides a quick check to see what has been skipped, an whether all files are present. This script iterates across: Native space 1) subject and 2) session files, Resampled 3) subject and 4) session files, 5) Lock files and 6) QC Figure files. For all we perform a: A) Count of the files present, summarized in FileReportSummary.csv B) List of the missing files in \"Missing*.csv\" files PM: Simplify/optimize this code, to make filename variable changing, search within subject-directories, etc. Combine the parts searching for missing & summarizing count. xASL_adm_DefineASLResolution.m Format x = xASL_adm_DefineASLResolution(x) Description If the parameters x.ResolutionEstimation == 1, it initializes the resolution with expected values per sequence type and then runs the procedure xASL_im_ResolutionEstim to estimate the resolution from the mismatch between ASL and structural data. For x.ResolutionEstimation == 0, xASL_init_DefaultEffectiveResolution the educated guess is used for the estimated resolution using previous data and analyzis. xASL_adm_DefineASLSequence.m Format [x] = xASL_adm_DefineASLSequence(x) Description This ExploreASL function tries to check what ASL sequence is being processed, if this was not already defined in x.Sequence. It does so by checking known combinations of readout dimensionality (x.readout_dim) and vendor, knowing the product sequences of the vendors. xASL_adm_DeleteFilePair.m Format filepaths = xASL_adm_DeleteFilePair(path, ext1[, ext2 [, ext3 ...]]) xASL_adm_DeleteFilePair(path, ext1[, ext2 [, ext3 ...]]) Description Delete the file given in PATH, and also deletes files with the same name, but with extension given in EXT1, and potentially also EXT2, EXT3... xASL_adm_Dicom2Parms.m Format [parms pathDcmDictOut] = xASL_adm_Dicom2Parms(inp[, parmsfile, dcmExtFilter, bUseDCMTK, pathDcmDictIn]) Description The function goes through the INP files, reads the DICOM or PAR/REC files and parses their headers. It extracts the DICOM parameters important for ASL, makes sure they are in the correct format, if missing then replaces with default value, it also checks if the parameters are consistent across DICOM files for a single sequence. xASL_adm_DocCrawler.m Format xASL_adm_DocCrawler(inputPath) Description This function checks each individual file header and extracts the information. The results is saved as a markdown file. If you want to use star symbols (*testFile.m e.g.) we recommend not to use them in the same line with bold text (which is written like this: bold text ). xASL_adm_DocInitialize.m Format xASL_adm_DocInitialize Description This function generates all markdown files, which are necessary for the mkdocs documentation. xASL_adm_FindByRegExp.m Format xasl_adm_FindByRegExp(root, dirSpecs[, varargin]) Description Recursively find files in the root directory according to the dirSpecs. xASL_adm_FindStrIndex.m Format INDEX = xASL_adm_FindStrIndex(ARRAY, STRING) Description Similar to find, but then for a cell array filled with strings. Only takes 4 dimensions. xASL_adm_GetFsList.m Format RES = xASL_adm_GetFsList([strDirectory, strRegEx, bGetDirNames, bExcludeHidden, bIgnoreCase, nRequired]) Description List files or directories from a given path. And optionally uses regular expressions to filter the result with options to exclude hidden files, ignore case, and set a minimal requirement on the number of results. Sorts the results at the end. xASL_adm_GetNumFromStr.m Format num = xASL_adm_GetNumFromStr(str) Description Obtains single number from string. CAVE there should only be one number! xASL_adm_GetPhilipsScaling.m Format scaleFactor = xASL_adm_GetPhilipsScaling(pathParmsMat,pathNifti) Description This script provides the correct scaling factors for a NIfTI file. It checks the header of the NIfTI that normally has the same scaling as RescaleSlope in DICOM, it checks if dcm2nii (by the info in JSON) has already converted the scale slopes to floating point. And if not, the derive the correct scaling factor to be applied. xASL_adm_GetUserName.m Format UserName = xASL_adm_GetUserName() Description Get the name of the current user. xASL_adm_Hex2Num.m Format outNum = xASL_adm_hex2num(inStr) Description Takes a hexadecimal string and converts it to number or string. Works also when the string contains escape characters, and for single-floats and for a little and big endian. If containing 8 and less characters than treat as float, if more than as double. xASL_adm_LesionResliceList.m Format [INname, OUTname] = xASL_wrp_LesionResliceList(x,bLesion_T1,bLesion_FLAIR,bROI_T1,bROI_FLAIR) Description Creates list of structural image paths to reslice. xASL_adm_LoadParms.m Format [Parms, x] = xASL_adm_LoadParms(ParmsPath[, x, bVerbose]) Description This function loads the internal memory x struct, any legacy *_parms.mat sidecar, any *.json BIDS sidecar, to use scan-specific parameters for image processing/quantification. Also, per BIDS inheritance, any x.S.SetsID parameters (from participants.tsv) are loaded as well. This function performs the following steps: Load .mat parameter file Load JSON file Deal with warnings Find fields with scan-specific data in x.S.Sets, and use this if possible (per BIDS inheritance) Sync Parms.* with x.(Q.)* (overwrite x/x.Q) Fix M0 parameter if not set xASL_adm_LoadX.m Format [x[, IsLoaded]] = xASL_adm_LoadX(x[, Path_xASL, bOverwrite]) Description This function loads x.Output & x.Output_im struct fields from the x.mat on the hard drive & adds them to the current x struct located in memory. If it didnt exist in the x.mat, it will set IsLoaded to false, which can be catched externally & a warning issued if managed so in the calling function. If it didnt exist in the memory x struct, or bOverwrite was requested, the contents of x.mat will be loaded to the memory x struct xASL_adm_MakeStandalone.m Format xASL_adm_MakeStandalone(outputPath, bCompileSPM, importDCM, markAsLatest); Description This function creates an output folder including a standalone version of ExploreASL, which can be used with the Matlab Runtime outside of Matlab itself. A quick fix to solve path dependencies etc. is to first compile SPM (but this can be turned off for speed). This function performs the following steps: Manage ExploreASL and compiler code folders Capture version/date/time File management output folder & starting diary Handle SPM Specific Options Manage compilation paths Run SPM compilation Run ExploreASL compilation Print done xASL_adm_OrderFields.m Format outStruct = xASL_adm_OrderFields(inStruct,orderStruct) Description Order fields in the structure inStruct to match orderStruct , unmatching fields in inStruct are copied as they are at the end, unmatching fields in orderStruct are ignored. This is just a cosmetic change and no values are edited. xASL_adm_OtherListSPM.m Format [OtherListSPM, OtherListOut] = xASL_adm_OtherListSPM(OtherList, bList4D) Description bPadComma1 is to add the ,1 to the end of the pathstring, which SPM uses to assign the first image of a 4D image array (OPTIONAL, DEFAULT = true) bList4D: boolean, true for listing multiple 4D volumes separately in the list (OPTIONAL, DEFAULT=true). xASL_adm_ParReadHeader.m Format info =xASL_adm_ParReadHeader(filename) Description Function for reading the header of a Philips Par / Rec MR V4.* file. xASL_adm_RemoveLogFilesForRerun.m Format xASL_adm_RemoveLogFilesForRerun(rootDir); Description Removes all log files from any directory containing .log files. xASL_adm_Remove_1_SPM.m Format [OtherList] = xASL_adm_Remove_1_SPM(OtherList) Description Remove ,1 at end of OtherLists, if exists. These are appended in CoregInit, OldNormalizeWrapper etc, since this should allow 4rd dim (e.g. as in ASL4D). xASL_adm_ReplaceSymbols.m Format strOut = xASL_adm_ReplaceSymbols(strIn, symbolTable[, bracketLeft, bracketRight]) Description It takes the STRIN on input, then looks for symbols between BRACKETLEFT and BRACKETRIGHT and replaces these symbols in in the string by the values provided in the SYMBOLTABLE as SYMBOLTABLE.SYMBOL, SYMBOLTABLE.D.SYMBOL, or SYMBOLTABLE.P.SYMBOL xASL_adm_ResetVisualizationSlices.m Format [x] = xASL_adm_ResetVisualizationSlices(x) Description Removes any predefined slices that should be visualized, allowing to show the default slices. Comes in handy when different pipeline visualization parts are repeated. xASL_adm_SaveX.m Format xASL_adm_SaveX(x[, Path_xASL, bOverwrite]) Description This function saves the x.mat either to the predefined path or the the subject x.mat xASL_adm_UnzipOrCopy.m Format unpackedFiles = xASL_adm_UnzipOrCopy(srcDir, wildCard, destDir [, bOverwrite]) Description This is a simple wrapper function to (g)unzip one or more files to the specified destination directory. Existing files or directories will not be overwritten, unless forced with bOverwrite. A regular file-copy will be used if the source files don't have gz or zip filename extensions. xASL_adm_Voxel2RealWorldCoordinates.m Format [X Y Z] = xASL_adm_Voxel2RealWorldCoordinates(X,Y,Z,VoxelSize) Description Converts MNI coordinates from voxel coordinates/indices. Assumes X Y Z = LR LeftRight AP AnteriorPosterior IS InferiorSuperior. VoxelSize should be [1 3]-sized input. xASL_adm_ZipFileList.m Format filepaths = xASL_adm_ZipFileList(strDirectory, strRegExp[, bRecurse, bUseGzip, nRequired]) xASL_adm_ZipFileList(strDirectory, strRegExp[, bRecurse, bUseGzip, nRequired]) Description Zip the files that match regular expression STRREGEXP in the given directory STRDIRECTORY. Zips recursively if specified in BRECURSE. Zips all files unless the number is specified by NREQUIRED, if the number is not met, then does not zip anything and throws an error. xASL_adm_uiGetInput.m Format [Parms] = xASL_adm_uiGetInput(Parms) Description Checks whether input fields are present, or requests them. BIDS xASL_bids_Add2ParticipantsTSV.m Format xASL_bids_Add2ParticipantsTSV(DataIn, DataName, x, bOverwrite) Description This function adds metadata/statistical variables to the participants.tsv in the root/analysis folder, by the following steps. This function will iterate over Data provided at DataIn and fill them in the participants.tsv, overwriting if allowed. Empty data is filled in as 'n/a', and the first column \"participants_id\" is sorted for participants. This function runs the following steps: Admin - Validate that there are not too many columns Admin - Detect nSubjectsSessions Admin - Load pre-existing participants.tsv or create one Admin - Get column number of data Add data to CellArray Sort rows on subjects Fill empty cells Write data to participants.tsv xASL_bids_BIDS2Legacy.m Format xASL_bids_BIDS2Legacy(pathStudy[, bOverwrite, dataPar]) Description This function converts BIDS rawdata (in pathStudy/rawdata/) to xASL legacy derivative format (e.g. pathStudy/derivatives/ExploreASL/) Can be updated step-by-step when ExploreASL's derivative structure moves to BIDS NB: ask how Visits/session layer is defined in bids-matlab (should be separate layer within subjects, but now isn't?) This function performs the following steps: Parse a folder using bids-matlab Define Subject Define SubjectVisit Parse modality Parse scantype Compile paths for copying Manage sidecars to copy Copy files Parse M0 Create DataPar.json xASL_bids_CompareStructures.m Format [identical,results] = xASL_bids_CompareStructures(pathDatasetA,pathDatasetB,[bPrintReport,threshRmseNii]); Description Function that compares two BIDS folders with several subfolders and studies and prints the differences. We recommend to set bPrintReport to true, because you otherwise can't see significant file content differences. xASL_bids_Config.m Format bidsPar = xASL_bids_Config() Description Creates several structures necessary for configuring the DICOM to BIDS conversion and saving of BIDS JSON files and NII structure. xASL_bids_CreateDatasetDescriptionTemplate.m Format [json] = xASL_bids_CreateDatasetDescriptionTemplate(draft) Description This script creates a JSON structure which can be saved using spm_jsonwrite to get a dataset_description.json template. Missing fields that are required are added. BIDSVersion checked against the current configured version. Remaining fields will be validated. Other fields not belonging to dataset_description.json are ignored. xASL_bids_DRO2BIDS.m Format xASL_bids_DRO2BIDS(droTestPatient,[droSubject]) Description Prepare DRO test patient for BIDS2RAW conversion. This script uses the output of the asldro python script and converts it into a bids structure that can be read by our xASL_bids_BIDS2Legacy script. An exemplary usage is shown in the unit test called xASL_ut_UnitTest_function_BIDS2Legacy. xASL_bids_Dicom2JSON.m Format [parms pathDcmDictOut] = xASL_bids_Dicom2Parms(imPar, pathIn[, pathJSON, dcmExtFilter, bUseDCMTK, pathDcmDictIn]) Description The function goes through the pathIn files, reads the DICOM or PAR/REC files and parses their headers. It extracts the DICOM parameters important for ASL, makes sure they are in the correct format, if missing then replaces with default value, it also checks if the parameters are consistent across DICOM files for a single sequence. xASL_bids_GetPhoenixProtocol.m Format [xasl,parameters,parameterList,phoenixProtocol] = xASL_bids_GetPhoenixProtocol(pathData,bUseDCMTK) Description Function that reads raw DICOM data (\".dcm\" or \".IMA\") and extracts the phoenix protocol parameters. Only works for Siemens DICOM data with phoenix protocol (tag = [0x29,0x1020]). xASL_bids_JsonCheck.m Format jsonOut = xASL_bids_JsonCheck(jsonIn,fileType) Description It checks the existence of all BIDS fields, removes superfluous fields, checks all the conditions and orderes the structure on the output. It works according to the normal BIDS, or ASL-BIDS definition xASL_bids_MergeNifti.m Format NiftiPaths = xASL_bids_MergeNifti(NiftiPaths, seqType) Description This function takes a list of M0 or ASL4D files and concatenates them together in a longer 4D volume if possible following certain patterns: works only with 3D and 4D files; all files in the list must have the same size of the first three dimensions; files are generarily sorted according to the last number in the filename and outputted to M0.nii or ASL4D.nii; first JSON is taken and renamed, all other JSONs and NIIs are deleted after merging; M0*_parms.m or ASL*_parms.mat is renamed to M0_parms.m or ASL4D_parms.m; M0 files are checked if the field PhaseEncodingAxis is consistent through all the volumes, if not the nothing is merged; this is applied to a generic case and 3 other specific Siemens scenarios are implemented: i) All NII files have two volumes, then simply concatenate according to the last number. ii) Two files with a single volume each are merged according to the last number in the file name. iii) Multiple files with each containing a single volume are sorted to tags ASL4D_x_x_Y and controls ASL4D_Y and merged in the order of the last number in the filename (Y) alternating the tags and controls This function performs the following steps in subfunctions: xASL_bids_MergeNifti_M0Files Generic merging of M0 files xASL_bids_MergeNifti_GEASLFiles Merge GE ASL files and extract scan order from DICOM tags xASL_bids_MergeNifti_SiemensASLFiles Merge Siemens ASL files with specific filename pattern xASL_bids_MergeNifti_AllASLFiles Merge any ASL files xASL_bids_MergeNifti_Merge Merge NiftiPaths & save to pathMerged xASL_bids_MergeNifti_Delete Delete NiftiPaths and associated JSONs xASL_bids_MergeNifti_RenameParms Find *_parms.m files in directory and shorten to provided name xASL_bids_Par2JSON.m Format parms = xASL_bids_Par2JSON(pathPar, pathJSON) Description Opens the Philips PAR file. Reads the relevant DICOM headers and saves them to JSON sidecar in a BIDS format. The JSON file is created automatically by the dcm2nii readout, so it always looks for this JSON file and add the same time reads the PAR file and adds further parameters to the JSON that were not identified by the dcm2nii tool. xASL_bids_PhoenixProtocolAnalyzer.m Format [bidsPar,sourcePar] = xASL_bids_PhoenixProtocolAnalyzer(parameterList); Description This function analyzes the parameter list of the phoenix protocol (tag = [0x29,0x1020]). This function is usually called from xASL_bids_GetPhoenixProtocol. xASL_bids_PhoenixProtocolReader.m Format [parameterList,phoenixProtocol] = xASL_bids_PhoenixProtocolReader(rawPhoenixProtocol) Description Function to parse the raw phoenix protocol. This function is usually called from xASL_bids_GetPhoenixProtocol. xASL_bids_VendorFieldCheck.m Format jsonOut = xASL_bids_VendorFieldCheck(jsonIn,bIsASL) Description It checks all the JSON fields, make sure that they are renamed from vendor specific names to common BIDS names xASL_bids_parms2BIDS.m Format outBids = xASL_bids_parms2BIDS(inXasl[, inBids, bOutBids, priorityBids]) Description This functions takes two parameter structures and merges them. At the same time, renames all fields according to the output type (note that only some fields have two standardised names different between the two formats. In case of duplicities, takes the field value from the preferred format. Also takes into account that the units in BIDS are s, but in xASL ms. This function performs the following steps: Define field names that need to be convert/renamed/merged Convert XASL fields to the output format (BIDS or XASL) Convert BIDS fields to the output format (BIDS or XASL) Merge the BIDS and XASL fields, convert field values xASL_bids_parseM0.m Format xASL_bids_parseM0(pathASLNifti) Description Check the .JSON and aslContext.tsv sidecards of an ASL file in BIDS format and find the specified M0 possibilities. Then it converts the ASL file to ExploreASL legacy format including splitting of ASL and M0 NIFTIes if needed. Note that the sidecars are in BIDS, but the file-structure is already expected to be in Legacy format FSL xASL_fsl_RunFSL.m Format [x] = xASL_adm_RunFSL(FSLCommand, x[, OutputZipping]) Description This function runs an FSL command from ExploreASL: Checking the FSL dir Manage CUDA/CPU parallelization (currently disabled, WIP) Setting up FSL environment Running the command Supports .nii & .nii.gz, Linux, MacOS & Windows (WSL) xASL_fsl_SetFSLdir.m Format [FSLdir[, x, RootWSLdir]] = xASL_adm_SetFSLdir(x, bUseLatestVersion) Description This function finds the FSLdir & puts it out, also in x.FSLdir to allow repeating this function without having to repeat searching. If the FSLdir & RootFSLDir are already defined in x.FSLdir & x.RootFSLDir, this function is skipped. Supports Linux, MacOS & Windows (WSL), & several different default installation folders for different Linux distributions xASL_fsl_TopUp.m Format xASL_fsl_TopUp(InDir[, ScanType], x) Description This function runs FSL TopUp. It assumes that there are 2 TopUp images, i.e. 1 blip up & 1 blip down. Admin: manage ScanType, NIfTI paths, create TopUp parameter file for image to apply TopUp to & for the TopUp NIfTIs, delete files from previous run, define the image with the same acquisition parameters as TopUp (does the image we apply TopUp to, have the Blip up or down?) Register images to image that we apply TopUp to (registration between blip up/down images is performed by TopUp) Run TopUp estimate (i.e. estimate the geometric distortion field from B0 NIfTI & parameters file), this takes quite long. Also has a x.Quality=0 option that is very fast but inaccurate, to try out this pipeline part. Before TopUp, NaNs (e.g. from resampling) are removed from the images TopUp is run with default settings Apply TopUp Imaging xASL_im_BilateralFilter.m Format [ovol] = xASL_im_BilateralFilter(volIM, mask, VoxelSize, x) Description This function runs a spatial lowpass temporally highpass filter, and removes outliers within this signal, and adapts the time-series accordingly. xASL_im_CenterOfMass.m Format xASL_im_CenterOfMass(PathNIfTI, OtherList, AllowedDistance) Description This function estimates the center of mass of the image matrix, and if this is too far off the current orientation matrix center, the center will be reset. This fixes any incorrect orientation outputted by the scanner. The realignment is only applied when any of the X/Y/Z dimensions have a higher offset than AllowedDistance. xASL_im_CleanupWMHnoise.m Format xASL_im_CleanupWMHnoise(InputPath, OutputPath, MinLesionVolume, pThresh) Description Threshold white matter lesions, acknowledging the fact that they may be confluent with subresolution connection through a dilation. This part is executed conservatively, as FLAIR hyperintensities inside the GM can be erroneously segmented as WMH, and should not be lesion-filled (otherwise these cannot be fixed later in the Structural module). Note that LST lesion filling expects a probability map, doesnt work nicely with binary mask xASL_im_ClipExtremes.m Format [NewIM] = xASL_im_ClipExtremes(InputIm[, ThreshHigh, ThreshLow, bVerbose, bNormalize]) Description This function clips an image to a given percentile. The percentile is found using non-zeros sorted intensities, so both isfinite & non-zeros. This function performs the following steps: Constrain clippable intensities Clip high intensities Clip low intensities Normalize to 4096 (12 bit, 12^2) Save as NIfTI if the input was a NIfTI xASL_im_Column2IM.m Format [ImageOut] = xASL_im_Column2IM(ColumnIn, BrainMask) Description This function \"decompresses\" an image matrix (or multiple matrices) from a single-dimensional column, by reconstructing the image matrix from the voxel positions within the BrainMask. NB: Important to use the same BrainMask as used for converting the image matrix to the column! See also: xASL_im_IM2Column.m The mask mostly used for xASL_im_IM2Column is x.WBmask, which completely engulfes pGM, pWM & pCSF. xASL_im_CompareNIfTIResolutionXYZ.m Format [IsEqualResolution] = xASL_im_CompareNIfTIResolutionXYZ(PathNIfTI1, PathNIfTI2) Description This function checks whether the X, Y and Z resolution of a NIfTI with any number of dimensions is equal. It rounds for 2 floating points, for both NIfTIs, to ensure that the same precision is compared. xASL_im_ComputeDice.m Format [DiceCoeff] = xASL_im_ComputeDice(imA, imB) Description This function calculates the Dice coefficient of image overlap. xASL_im_CreateASLDeformationField.m Format xASL_im_CreateASLDeformationField(x, bOverwrite, EstimatedResolution) Description This function smooths a transformation flow field to a lower resolution. Usually, we use a high resolution anatomical image (e.g. 3D T1w ) to obtain the flowfields from native space to standard space, and apply these to the lower resolution ASL images. Because of the resolution differences, the flowfields need to be downsampled/smoothed, to avoid deformation effects that are crispier than the functional image that is investigated. This function performs the following steps: Obtain resolutions Fill NaNs at edges y_T1.nii flowfield to prevent interpolation artifact Smooth flowfield Fill NaNs at edges y_ASL.nii Note that if the resolution of ASL is not significantly (i.e. >0.5 mm in any dimension) lower than T1w, the y_T1.nii is copied to y_ASL.nii xASL_im_CreatePseudoCBF.m Format xASL_im_CreatePseudoCBF(x, spatialCoV[, bPVC]) Description This function creates a pseudo-CBF image from mean CBF template, arterial transit time (ATT) bias field & vascular artifacts, weighted through spatial CoV The first part of this code puts templates in the native space and creates a pseudoCBF image from a downsampled pGM & pWM tissue (PseudoTissue). The latter is used for registration but also as reference for the template registration, to speed this up. The second part of this code computes a pseudoCBF image based on the pseudoTissue & the CBF templates of CBF, ATT biasfield and vascular peaks, based on spatial CoV. This submodule performs the following steps: Create the pseudoTissue CBF reference image, if it doesnt exist already Create the native space copies of ASL templates, if they dont exist already Spatial CoV input argument check Load native space copies of templates Create pseudoTissue from segmentations, mix this with the mean CBF template depending on spatial CoV Create pseudoCBF reference image used for CBF-based registration Scale mean_PWI_Clipped source image to the same range as PseudoCBF xASL_im_CreateSliceGradient.m Format xASL_im_CreateSliceGradient(x) Description Create slice gradient in same space as input file Reslice slice gradient to MNI (using existing ASL matrix changes from e.g. registration to MNI, motion correction, registration to GM) Creating average slice gradient xASL_im_DecomposeAffineTransformation.m Format [M, P] = xASL_im_DecomposeAffineTransformation(Mtransformation) Description This function splits a transformation matrix into individual components, which can be useful to guide the SPM reslicing. The components are the same as in spm_(i)matrix.m, except for the shearing: these are included in the rotations, and the 90 degree rotations, these are separated. Reason for the separation of the 90 degree rotations, is that these indicate if orientations (transversal, coronal & sagittal) have been switched in the NIfTI. This can be useful to correct for any erroneous 90degree rotations from registration, or to put two images in the same orientation order or voxelsize without applying their subtle realignment (e.g. for manipulating registration references) THEORY 90 degree rotations: Any rotation will always swap the other dims (X rotation swaps Y/Z, Y rotation swaps X/Z etc.) because they are perpendicular (haaks) Dims X Y Z care for LR, AP and IS translation. - X-rotation will rotate the transverse slice (LR <-> AP) swapping Y (coronal) & Z (saggital) - Y-rotation will rotate the coronal slice (IS <-> LR) slice, swapping X (transversal) and Z (sagittal) - Z-rotation will rotate the sagittal slice (AP <-> IS) swapping X (transversal) and Y (sagittal) E.g., MPRAGE is acquired in sagittal slices, and ASL/fMRI/BOLD in transversal slices. This is an Y rotation (you look into the coronal plane, rotate this, which will swap the sagittal slices into transversal) This function performs the following steps: Start with an output P and M struct Obtain translations Obtain zoom Obtain 90degree rotations Obtain subtle rotations & shearing Check the rounding errors of the decomposition xASL_im_DetermineFlip.m Format [QCstruct] = xASL_im_DetermineFlip(x,iS,PathOrientationResults,QCstruct) Description Check determinants, should be the same before & after registration, otherwise a left-right flip is applied This is not visible, but detrimental for image analysis/stats. xASL_im_DilateErodeFull.m Format imOut = xASL_im_DilateErodeFull(imIn, type, kernel) Description Runs dilation or erosion on a binary imIn in full three dimensions. It uses its own dilate_erode function and crops the image so that it contains only the mask. The size of all three dimensions of the kernel needs to be an odd number. xASL_im_DilateErodeSeparable.m Format imOut = xASL_im_DilateErodeSeparable(imIn, type, kernel_x, kernel_y, kernel_z) Description Runs dilation or erosion on a binary imIn separably in three dimensions. Dilation/erosion in each dimension is done by using the specified kernels. It uses its own dilate_erode function and crops the image so that it contains only the mask. Works only with odd sized kernels xASL_im_DilateErodeSphere.m Format el = xASL_im_DilateErodeSphere(R) Description Creates a 3D structuring element (binary) sphere with the given diameter (R) and size 2*R+1 xASL_im_DummyOrientationNIfTI.m Format xASL_im_DummyOrientationNIfTI(PathSrc, PathRef, PathDummyOut[, bApplyRotationMinor, bApplyRotation90, bApplyZoom, bApplyTranslation]) Description This function creates a dummy image as reference for xASL_spm_reslice, allowing to only apply specific parts of the transformation between the two images. E.g. only the rotation, or only the zooming. This can be useful to correct for any erroneous rotations from registration, or to put two images in the same space without applying their realignment. This function performs the following steps: Load orientations & calculate transformation Calculate the desired transformation Calculate new orientation matrix Calculate the new image size Save the dummy NIfTI xASL_im_EstimateResolution.m Format [resFWHM, resSigma, resErr, imSmo, imMask] = xASL_im_EstimateResolution(imCBF, imGM, imWM[, imMaskOrig, PSFtype, maxIter]) Description Creates a high-resolution pseudo-CBF image based on segmented GM and WM maps and iteratively adjusts its resolution by smoothing until reaching a perfect fit with the CBF image thus obtaining the resolution difference between the GM and CBF image and uses this to calculate the estimated effective resolution of hte CBF. Note that all the calculations are done using voxels as measures and not mm, so the output resolution is also in voxels and has to be transfered to mm by using the knowledge about the voxel size. It is assumed that for imGM and imWM, the voxel size equals the resolution, and the imCBF is upsampled to the smaller voxels of imGM. xASL_im_Flip.m Format [MatrixOut] = xASL_im_Flip(MatrixIn, varargin) Description Backwards compatibility for flipping left-right in standard space (NB: this can be different than in native space!). xASL_im_IM2Column.m Format [ColumnOut] = xASL_im_IM2Column(ImageIn, BrainMask[, ApplyShiftDim]) Description This function \"compresses\" an image matrix (or multiple matrices) for optimization of memory and CPU resources. The output column only includes voxels that lie within the BrainMask. This excludes extracranial zero-information voxels from computations and memory use. NB: Important to use the same BrainMask for converting the column back to an image matrix! See also: xASL_im_Column2IM.m The mask mostly used for xASL_im_IM2Column is x.WBmask, which completely engulfes pGM, pWM & pCSF xASL_im_JointHist.m Format imHist = xASL_im_JointHist(imA,imB[,imMask,minA,maxA,minB,maxB,nBins]) Description It calculates a joint histogram of two images of any dimensions over a mask of the same size. The boundaries and number of bins can either be given or min and max values are used. Values outside of the bins are counted to the first/last bin. xASL_im_Lesion2CAT.m Format LesionPathOut = xASL_im_Lesion2CAT(PathIn) Description For all lesion masks in the anatomical directory, load them, merge them and save them for the CAT segmentation. If there are no lesions found, the images are untouched. xASL_im_Lesion2Mask.m Format LesionIM = xASL_im_Lesion2Mask(LesionPath, x) Description This function takes a mask and adds several ROIs, to be used as custom \"atlas\", e.g. when computing region-average CBF values. The mask % can be an ROI or lesion, if we assume it is a lesion, the following masks are created: Intralesional Perilesional (15 mm rim around the lesion) Hemisphere (ipsilateral to lesion) Contralateral version of 1 Contralateral version of 2 Contralateral version of 3 All these masks are masked by a brainmask (pGM+pWM)>0.5 This function performs the following steps: If lesion is empty, skip this & delete the file BrainMasking Create hemispheres Save mutually exclusive masks Create tsv-sidecar containing the names of the ROIs Visual QC xASL_im_M0ErodeSmoothExtrapolate.m Format [ImOut] = xASL_im_M0ErodeSmoothExtrapolate(ImIn, x) Description This function erodes, smooths & extrapolates M0 in standard space. It assumes that the M0 image is in standard space & that the GM & WM probability maps are aligned. Here, we mask the M0, to remove high CSF signal and low extracranial signal, enabling us to smooth the image without inserting wrong signal. See also the ExploreASL manuscript for a more extensive explanation. This function performs the following steps: Mask: Load segmentations, create structural mask Mask: Create intensity-based mask to remove extracranial signal Mask: Erode the combined masks Mask: Determine any odd borders Smoothing Extrapolating only Scale back to the GM M0 Print visual QC figure A visual QC figure is created, showing the M0 image processing steps for a single transversal slice (slice 53 in 1.5 mm MNI standard space) OutputFile = fullfile(x.D.M0regASLdir,['M0_im_proc_' x.P.SubjectID '.jpg']); The original M0 image (a) is masked with a (pGM+pWM)>50% mask (b) eroded with a two-voxel sphere to limit the influence of the ventricular and extracranial signal (c) and thresholded to exclude significantly high (i.e. median + 3*mean absolute deviation (MAD)) border region values (d) This masked M0 image is smoothed with a 16x16x16 mm full- width-half-maximum Gaussian filter (Mutsaerts et al., 2018) (e) after which the signal at the border is smoothly extrapolated until the full image is filled (f). Whereas the masking avoids mixing with cerebrospinal fluid or extracranial signal, the extrapolation avoids M0 division artifacts xASL_im_MaskNegativeVascularSignal.m Format [NegativeMask, TreatedPWI] = xASL_quant_DetectNegativeVascularSignal(x) Description This function segments clusters with significant negative ASL signal. This can be tricky as there is also the negative tail of Gaussian noise from the ASL subtraction. The image feature we use here, is that negative vascular signal will be a relatively large region with significant median negative value, whereas noise will be regions with relatively small negative signal. Negative signal from wrong background suppression timing (e.g. in the first slice with 2D EPI) can be masked out with this as well. The procedure works as follows: Obtain mask of negative voxels within pGM>0.5 mask Obtain distribution of subzero clusters Define the negative threshold Create mask by thresholding whole image Note that the definition of the threshold is obtained within the GM only, but that this threshold is applied to the full image. Note that instead of the PWI path input, a CBF image should work equally well, as we don't expect a smooth M0 biasfield to change the distribution of negative clusters xASL_im_MaskPeakVascularSignal.m Format [MaskIM, CBF] = xASL_quant_VascularContrast(PathPWI, Path_M0, CompressionRate, ClipThresholdValue, bClip) Description This function searches for an acceptable high threshold as definition of high intra-vascular ASL signal. It also allows to compress the values here (when bClip==true). Compression retains some variability, but limits their outlying influence on statistics. The procedure works as follows: Segment GM on ASL image at 80th percentile of CBF image distribution For PWI & CBF images, select voxels higher than median + ClipThresholdValue MAD Vascular artifacts will have a high intensity in both images, whereas errors by division by M0 will only have a high intensity on the M0 image, and high values due to a biasfield will only be noticeable on the PWI image Combine the two created masks Obtain average clipping value from selected voxels from the combined masks Apply compression if requested. If not, output image will have NaNs for intra-vascular voxels. Note that the definition of the threshold is obtained within the GM only, but that this threshold is applied to the full image to also remove extracranial extreme values. Note that the performance may change when using this script with or without M0, as this will change the distribution that determines where the threshold for extremes lies. xASL_im_Modulation.m Format xASL_im_Modulation(x) Description Combines the transformations to create Jacobians, & multiplies the standard space segmentations with these to create volumetric images for volumetric analyses. xASL_im_NormalizeLabelingTerritories.m Format image_out = xASL_im_NormalizeLabelingTerritories( imageIN, GMmask, x) Description Normalizes per perfusion territory mask should be GM mask. xASL_im_PCA.m Format [pc, score, eigenvalues, tsquare, loadings, Xmean] = xASL_im_PCA(dataIn) Description Perform a Principal Component Analysis. xASL_im_PVCbspline.m Format [imPVEC,imCBFrec,imResidual,FWHM] = xASL_im_PVCbspline(imCBF,imPV[,bsplineNum]) Description PVC of ASL data using prior GM-,WM-partial volume maps. Follows the principles of the PVEc algorithm by I. Asllani (MRM, 2008). The PV-corrected CBF_GM and CBF_WM maps are approximated using an uniformly sampled cubic B-splines. REFERENCES: -Asllani I, Borogovac A, Brown TR. Regression algorithm correcting for partial volume effects in arterial spin labeling MRI. Magnetic Resonance in Medicine. 2008 Dec 1;60(6):1362-71. -Petr J, Mutsaerts HJ, De Vita E, Steketee RM, Smits M, Nederveen AJ, Hofheinz F, van den Hoff J, Asllani I. Effects of systematic partial volume errors on the estimation of gray matter cerebral blood flow with arterial spin labeling MRI. MAGMA 2018. DOI:10.1007/s10334-018-0691-y xASL_im_PVCkernel.m Format [imPVC,imCBFrec,imResidual] = xASL_im_PVCkernel(imCBF, imPV [,kernel,mode]) Description Partial volume correction (PVC) of ASL data using prior GM-,WM-partial volume maps. Follows the principles of the PVC algorithm by I. Asllani (MRM, 2008). xASL_im_PreSmooth.m Format pathOut = xASL_im_PreSmooth(pathRef,pathSrc[,pathSmo,resRef,resSrc,srcAffinePath, bInvAffine]) Description It assumes that the FWHM is equal to voxel size, unless the real resolution is given. Then takes into account the voxel sizes and orientation difference between the volumes, but performs the smoothing according to the given real resolution (it is possible to supply the resolution for just one image) - this should be helpful primarily when the It creates a Gaussian covariance matrix for the reference, transforms it according to the difference between the two images a produces the Gaussian covariance matrix of the pre-smoothing in the source space. Then it performs the smoothing. The following steps are performed: Obtain the voxel size Skip this function if reference resolution is equal to, or lower than source resolution Deal with affine transformation Obtain the transformation matrix from the Reference to the Source space Apply the smoothing filter on the source image(s) Save the smoothed image xASL_im_ProcessM0Conventional.m Format [Corr_M0] = xASL_im_ProcessM0Conventional(ImIn, x) Description This function uses the conventional M0 masking, and only a little smoothing, following what Philips uses for its 3D {{GRASE}}. Advantages of the newer M0 processing in ExploreASL are the lack of use of M0 threshold-based masking, the removal of high CSF values and higher SNR for ASL division. xASL_im_ProjectLabelsOverData.m Format OutputIM = xASL_im_ProjectLabelsOverData(DataIM,LabelIM,x,ScaleFactorData,ScaleFactorLabel) Description This script projects labels over an image, but works only in 2D. Make sure to make a 2D image from a 3D or 4D image using xASL_vis_TransformData2View.m can be used in combination with xASL_vis_Imwrite.m xASL_im_ResampleLinearFair.m Format [output_res]=xASL_im_ResampleLinearFair(im_input,newsize) Description Downsample (or upsample, works similarly) old_res image to low_res image, trilinear. We recommend using \"xASL_spm_Resample\" instead, because of better performance. NB: new_res should fit exactly integer fold in old_res NB: all dimensions of new_res should have equal size xASL_im_RestoreOrientation.m Format xASL_im_RestoreOrientation(PathNIfTI) Description This function reverts the NIfTI header orientation matrix to the original orientation from the scanner/dcm2nii conversion. xASL_im_SkullStrip.m Format xASL_im_SkullStrip(InPath, PathMNIMask, x, OutPath) Description Creates skull-stripped T1w image based on MNI -> native space registration from segmentation. xASL_im_Smooth3D.m Format [imSmo, imGaussX, imGaussY, imGaussZ] = xASL_im_Smooth3D(imIn, sigma[, PSFtype]) Description It smooths the 3D image with a 3D kernels that has defined the shape and SD of the smoothing separably in three dimension. xASL_im_SplitImageLabels.m Format xASL_im_SplitImageLabels(ImagePaths, LabelTable[, OutputFolder, bOverwrite, ResampleDir, SubRegExp]) Description This function allows extracting of labels from a NIfTI file containing multiple labels, into single NIfTI files each containing a single label. Not all existing labels need to be extracted. The following steps are performed: Load TSV file Process images xASL_im_Upsample.m Format xASL_im_Upsample(PathOrig, PathDest, NewVoxelSize, LeaveEmpty, PaddingDim, Kernel) Description Upsamples an ASL image, without changing the orientation matrix, which can be used e.g. for PVEc in higher resolution but same space. xASL_im_ZeroEdges.m Format [IM] = xASL_im_ZeroEdges(IM[, EdgeThicknessPerc]) Description Resampling can sometimes give some strange errors near image edges. These should be NaNs, but sometimes can be zeros or ones, or even weird numbers. For resampling, NaNs should be set to 0 (this is done in another function) as they can influence the resampling (depending on the transformation matrix). To be sure that the edges are nicely fixed, this function sets a border at the image matrix edges to zero. xASL_im_dilateROI.m Format xASL_im_dilateROI(PathIn, [PathOut, minVolume]) Description The function loads a binary image from PathIn and if smaller than the defined volume (40 mL by default) it dilates it with a 3x3 sphere element until a minimal volume is reached. When it is small enough, it is saved to PathOut. 40 mm^3 is equal to 3 voxels in all directions in DARTEL space, or around the highest obtainable ASL effective resolution (3x3x4 mm). xASL_im_rotate.m Format rotated = xASL_im_rotate(im, angle) Description Simple rotation of the first two dimension of a ND image by 0, 90, 180, 270 degrees. Initialization xASL_init_DefaultEffectiveResolution.m Format [EffectiveResolution] = xASL_init_DefaultEffectiveResolution(PathASL, x) Description This ExploreASL module provides an educated guess on the effective spatial resolution of ASL. This may depend on the combination of acquisition PSF, reconstruction filter, head motion. Note that the derived/processed images may have a lower effective resolution because of smoothing effects from interpolation. Note that this remains an educated-guess, the actual FWHM may still differ, especially for 3D GRASE sequences, where e.g. the choice of number of segments can affect the smoothness. This function conducts the following steps: Educated-guess FWHM Attempt accounting for in-plane interpolation in reconstruction Calculate and report effective spatial resolution xASL_init_DefineStudyData.m Format [x] = xASL_init_DefineStudyData(x) Description This initialization wrapper initializes the parameters for this pipeline run, i.e. subjects, sessions (runs), timepoints (visits), exclusions, sites, cohorts etc. Note that ASL sessions are defined here as what BIDS calls \"runs\". The \"longitudinal_Registration functions here manage different TimePoints, which is what BIDS calls \"visits\". With different structural scans, from the same participant. This is managed by subject name suffixes _1 _2 _n, and can be used for comparing visits in the population module, or running SPM's longitudinal within-subject registration. Parallelization is allowed here by calling ExploreASL different times, where it divides the subjects/images for processing across the nWorkers, using iWorker as the reference for the part that the current ExploreASL call will process. This requires having a Matlab license that can be started multiple times on a server, or alternatively running the ExploreASL compilation, and doesn't require the Matlab parallel toolbox. This function exists from the following parts: Manage included & excluded subjects Create dummy defaults (exclusion list, ASL sessions) Create list of total baseline & follow-up subjects, before exclusions Create TimePoint data-lists Manage exclusions Add sessions as statistical variable, if they exist Parallelization: If running parallel, select cases for this worker Add Longitudinal TimePoints (different T1 volumes) as covariate/set, after excluding Load & add statistical variables Make x.S.SetsOptions horizontal if vertical by transposing Create single site dummy, if there were no sites specified Check for time points sets Create list of baseline & follow-up subjects (i.e. after exclusion) Check what excluded from which TimePoints xASL_init_FileSystem.m Format [x] = xASL_init_FileSystem(x) Description This function initializes the file system used throughout ExploreASL, for processing a single dataset/scan. It is repeated for each scan, and runs the following parts: Create folders Subject/session definitions Add prefixes & suffixes Add Subject-specific prefixes Add sidecars Add atlas paths xASL_init_InitializeMutex.m Format [x] = xASL_init_InitializeMutex(x, ModuleName) Description This function initializes the mutex/lock system of ExploreASL for a module. Mutex (for mutual exclusion) is a synchronization mechanism for enforcing limits of access to data (here a module for a single scan) to allow parallelization. It also allows stopping and continuing of ExploreASL. This function runs the following steps: Lock folder management Initialize mutex object xASL_init_LoadMetadata.m Format [x] = xASL_init_LoadMetadata(x) Description This function loads all metadata used in the study, either statistical covariates (age, MMSE) or groups to compare between (site, sequence, cohort), or parameters to be used in quantification/image processing These parameters should be provided in .mat files in the root analysis folder. Each .mat file should contain a single type of metadata, and the filename should equal the variable name. Metadata content should be a cell array with subjects as first column and metadata as last column. Sessions (runs) can be included as second column. Metadata can be in any string or numerical format. participants.tsv is now added per BIDS. It looks for metadata in participants.tsv first, before going through the mat-files This function iterates through the following steps for each variable: Admin (what nOptions do we call ordinal, convert subject numeric to string, remove white spaces from data) Get unique list of data options & check for missing data Deal with data format (correct NaNs, deal with numeric vs strings) Distinguish continous data (e.g. age) or ordinal data (groups to compare, e.g. cohort) Check if data is complete for all subjects Include complete data in x.S.SETS xASL_init_LongitudinalRegistration.m Format [SubjectNlist, TimePoint, IsSubject, SubjectID_FirstVolume] = xASL_init_LongitudinalRegistration(x) Description This function initializes the longitudinal registration for ExploreASL, which implements the SPM longitudinal registration. This function recognizes and defines visits (i.e. multiple scans per subject) in the initialization of ExploreASL, based on the suffixes _1 _2 _n in the subject names (identified as foldernames). Specifically, this function is called in the registration modules LongReg and DARTEL, the first carrying out within-subject registration and the second between-subject registration, based on the first time point only. For the first function, we specify here a list of visits/timepoints that should be registered longitudinally, for the second function we specify a list of first visits only, as the between-subject registration in ExploreASL is based on the first scan (as opposed to the average subject's scan). This function runs the following steps: Get TimePoint-list (list of visits) Find subject IDs xASL_init_VisualizationSettings.m Format [x] = xASL_init_VisualizationSettings(x) Description This function defines several visualization settings are used throughout ExploreASL's pipeline and tools, assuming a [121 145 121] matrix with 1.5 mm isotropic resolution in MNI space. Input and Output xASL_io_CreateNifti.m Format xASL_io_CreateNifti(pathNewNifti, imNew, resMat, nBits, bGZip) Description This function creates a new NIfTI file, using the SPM \"nifti\" functionality, with the parameters specified as input arguments. This function performs the following steps: Initialize NIfTI Choose datatype (bit resolution) Create scale slopes Create orientation matrix Write the new NIfTI, image matrix & scale slopes Zip and deal with zipping (.nii vs. .nii.gz) xASL_io_DcmtkRead.m Format header = xASL_io_DcmtkRead(filepath, bPixel) Description SHORT Reads DICOM headers using DCMTK FORMAT: header = xASL_io_DcmtkRead(filepath, bPixel) INPUT: filepath (string) - full path to the DICOM file bPixel (bool) - read pixel data, default 0 OUTPUT: header (structure) - structure containing parsed DICOM header Calls the MEX function that uses DCMTK library to read the DICOM header. To change which parameters are read and their names - the MEX file needs to be edited. This function also corrects formating of certain parameters. xASL_io_ExportVTK.m Format xASL_io_ExportVTK(nifti, [mask, exportPath]) Description Export a VTK image file based on a 3D NIFTI or a 3D/4D image matrix. 4D images will be exported as a VTK time series (export-1.vtk, export-2.vtk, etc.). This script uses vtkwrite (MIT License, Copyright 2016, Joe Yeh). xASL_io_MakeNifti4DICOM.m Format xASL_io_MakeNifti4DICOM(PathIn, x) Description This function converts a NIfTI file to one that is ready to convert to DICOM for PACS visualization purposes: For scaling/visualization: Remove peak signal Remove valley signal Remove NaNs Rescale to 12 bit integers Save NIfTI. We also zip the NIfTI as this NIfTI won't be opened by ExploreASL Manage scale slope/datatype Apply original orientation Zip NIfTI xASL_io_PairwiseSubtraction.m Format xASL_io_PairwiseSubtraction(InputFile,outputPath,do_mask,switch_sign) Description Subtracts controls from labels and takes mean. Creates new perfusion-weighted delta_M file, prefaced with 's'. Converts into single precision floating point values (32 bit), removes scale slope. Only runs if ['s' input_file_ASL] doesn't exist. Remember to consider motion correction/ SPM realign (isotropically). Alternative to this function is robust fit (Camille Maumet). xASL_io_ReadDataPar.m Format [x] = xASL_io_ReadDataPar(pathDataPar) Description This function reads the data-parameter file, which is a file containing settings specific to processing a certain dataset or study (abbreviated as DataPar) and creates the x-structure out of it. The file can be in .json or .m format. The input file name pathDataPar is given as a string or character array. The output is the x structure. It only loads the data, removes the x-prefixes, but keeps all the field names and units. It doesn't do any conversions to or from BIDS. The only added value to normal json-read is that it detects invalid entries (numbers in strings, and weird arrays), converts them correctly and reports this incorrect entries so that they can be manually fixed. Also, if an .m file is provided, it converts and saves it to a JSON file (doesn't overwrite) and reports that you should stop using .m files. xASL_io_ReadTheDicom.m Format [Info] = xASL_io_ReadTheDicom(bUseDCMTK, DicomPath) Description This function tries to read a DICOM and throws a warning if it fails to xASL_io_SplitASL.m Format xASL_io_SplitASL(inPath[, iM0, iDummy]) Description This function splits ASL4D & M0 & Dummy images if they were in the same sequence. If dcm2niiX has already splitted the ASL4D NIfTI, this is reconstructed first. If no M0 exists, or only ASL splitting is desired, leave iM0 empty ([]). The dummy scans can be excluded from the ASL sequence during the splitting. Both iM0 and iDummy are the absolute positions of both in the original time series Vendor product sequence examples: GE 3D spiral sometimes puts the M0 at the last volume of the series -> iM0 = [2]; Philips 3D GRASE puts the M0 as control-label volume pair -> iM0 = [1 2]; Siemens 3D GRASE puts the M0 as the first volume -> iM0 = 1; Some Siemens 3D GRASE puts a second Dummy control image -> iDummy = 2; xASL_io_dcm2nii.m Format [niifiles, ScanNameOut, usedinput, msg] = xASL_io_dcm2nii(inpath, destdir, series_name, varargin) Description Convert DICOM NIfTI/BIDS format using the dcm2nii command line utility. xASL_num2str.m Format [DataOut] = xASL_num2str(DataIn[, f, bConcatenate, strDelimiter]) Description When the provided data is numeric, this function will convert the number to string/characters, rewriting NaN into 'n/a' (BIDS convention) but otherwise preserving the Matlab builtin functionality, also for the second argument \"f\". If non-numeric data is provided, it is bypassed (avoiding any issues \"num2str\" will have with non-numeric data). It can concatenate an array/matrix of strings, taking first the columns in the first row, and then going across the rows. See builtin num2str for more details QC xASL_qc_AsymmetryIndex.m Format [AI_perc] = xASL_qc_AsymmetryIndex(ImageIn) Description Extract voxel-wise asymmetry index for QC purposes. xASL_qc_CAT12_IQR.m Format [QA_Output] = xASL_qc_CAT12_IQR(InputImage, InputC1, InputC2, InputC3, bFLAIR) Description Prepare and run CAT12s QC parameters (also for other images). xASL_qc_CollectParameters.m Format x = xASL_qc_CollectParameters(x, iSubject, ScanType, CollectQCFunction) Description This function collects QC parameters for a module. xASL_qc_CollectQC_ASL.m Format [x] = xASL_qc_CollectQC_ASL(x, iSubject) Description This functions collects QC parameters for the ASL module These are stored in x.Output.ASL: ID - SubjectName ASL_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 SPM realign (too much motion is suspicious) MotionMean_mm - mean motion MotionExcl_Perc - percentage of excluded outliers MotionMax_mm - max motion MotionSD_mm - SD motion ASL quantification (strange average CBF, or strange GM-WM contrast) ASL acquisition parameters (should be fairly consistent over subjects/scans): TE - echo time TR - repetition time RescaleSlope - Philips Scaleslope - Philips Matrix X Y Z - matrix size Matrix Z - number of slices VoxelSize X Y - in plane resolution VoxelSize Z - slice thickness RigidBody2Anat_mm - Net Displacement Vector (RMS) from ASL to T1w image (mm) from registration xASL_qc_CollectQC_Structural.m Format [x] = xASL_qc_CollectQC_Structural(x, iSubject) Description This functions collects QC parameters for the structural module These are stored in x.Output.Structural: ID - SubjectName T1w_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 LST output: WMH_vol_mL - WMH volume WMH_n - WMH number of lesions CAT12 output: T1w_IQR_Perc - CAT12 IQR quality parameter for T1w volumetric: GM_vol_mL, WM_vol_mL, CSF_vol_mL, ICV_vol_mL, GM_ICV_Ratio xASL_qc_CollectQC_func.m Format [x] = xASL_qc_CollectQC_func(x, iSubject) Description This functions collects QC parameters for the func module These are stored in x.Output.func: ID - SubjectName func_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 SPM realign (too much motion is suspicious) MotionMean_mm - mean motion MotionExcl_Perc - percentage of excluded outliers MotionMax_mm - max motion MotionSD_mm - SD motion func quantification (strange average CBF, or strange GM-WM contrast) CBF_GM_Median_mL100gmin - median GM CBF CBF_WM_Median_mL100gmin - median WM CBF SpatialCoV_GM_Perc - GM spatial CoV SpatialCoV_WM_Perc - WM spatial CoV CBF_GM_WM_Ratio - GM-WM CBF ratio func acquisition parameters (should be fairly consistent over subjects/scans): TE - echo time TR - repetition time RescaleSlope - Philips Scaleslope - Philips Matrix X Y Z - matrix size Matrix Z - number of slices VoxelSize X Y - in plane resolution VoxelSize Z - slice thickness RigidBody2Anat_mm - Net Displacement Vector (RMS) from func to T1w image (mm) from registration xASL_qc_CollectSoftwareVersions.m Format [x] = xASL_qc_CollectSoftwareVersions(x) Description This functions collects software versions for Matlab, SPM, CAT, LST & ExploreASL If FSL is installed, it will obtain its version as well. These are stored in x.Output.Software. xASL_qc_CompareTemplate.m Format [QC] = xASL_qc_CompareTemplate(x, ModPrefix, iSubjectSession) Description This function computes several advanced template-based QC parameters: RMSE_Perc - Root Mean Square Error between image and template (%) nRMSE_Perc - Same but then normalized AI_Perc - Asymmetry Index between image and template (%) Mean_SSIM_Perc - mean structural similarity index -> xASL_stat_MeanSSIM.m PeakSNR_Ratio - peak signal-to-noise ratio -> xASL_stat_PSNR.m xASL_qc_ComputeFoVCoverage.m Format [CoveragePerc] = xASL_qc_ComputeFoVCoverage(InputPath, x) Description This function computes the intersection/overlap between brainmask on field-of-view (FoV) of low resolution image (native space) & the same brainmask with expanded FoV. It uses the pGM+pWM+pCSF as brainmask This assumes that the structural reference image has full brain coverage, and was properly segmented into GM, WM and CSF Also, we assume that the InputPath contains a single 3D volume xASL_qc_ComputeNiftiOrientation.m Format [structOut] = xASL_qc_ComputeNiftiOrientation(PathNIfTI[, structIn]) Description It loads the input Nifti, finds its dimension, voxel size and a net vector distance from its original position before registration. Adds all these information into an output structure structOut while copying all from structIn and keeping it intact. xASL_qc_CreatePDF.m Format xASL_qc_CreatePDF(x[, DoSubject]) Description This function iterates over all values in x.Output and all images in x.Output_im, and prints them in a PDF file. x.Output & x.Output_im should contain the QC/result output of all ExploreASL pipeline steps. Further code explanation: Below, using the Matlab & SPM Figure tools we create an image, which is then printed to a PDF file fg = the main Figure handle ax = \"axes\" handles, these are objects containing either 1) text or 2) images, with fg as \"parent\" (1) & (2) images have ax as \"parent\" Positions are calculated in such a way that 4 categories can be printed, which will be the first 4 fields found in x.Output then allowing 8 single slice images, and 15 text lines (name & value columns) xASL_qc_FA_Outliers.m Format [FA_Outliers_mL] = xASL_qc_FA_Outliers(InputFA) Description Extract the number of FA outliers, i.e. values of FA above 1 or below 0, from a FA image. xASL_qc_ObtainQCCategoriesFromJPG.m Format xASL_qc_ObtainQCCategoriesFromJPG(x) Description This function obtains QC categories as covariant/set, based on the JPGs in //Population/ASLCheck. These are initially sorted by spatial CoV, and should be visually checked & put in the correct folder. xASL_qc_PCPStructural.m Format [anatQA] = xASL_qc_PCPStructural(PathT1, Pathc1T1, Pathc2T1, x, PopPathT1) Description This function computes several anatomical QC parameters as proposed in SPM Univariate Plus: WM_ref_vol_mL - volume of the WM reference region (mL) WMref_vol_Perc - same but as percentage of total WM volume SNR_GM - GM signal-to-Noise Ratio (SNR), ie the mean intensity within GM divided by SD of WM reference region. Higher = better. CNR_GM_WM - GM-WM Contrast-to-Noise Ratio (CNR), i.e. the mean of GM - mean of WM divided by the SD of the WM reference region. Higher = better. FBER_WMref_Ratio - Foreground to Background Energy Ratio (FBER), i.e. the variance of voxels within the brain (in pGM+pWM mask) divided by the variance of voxels in the WM reference region. Higher = better. EFC_bits - Shannon Entropy Focus Criterion (EFC), i.e. the entropy of voxel intensities proportional to the maximum possibly entropy for a similarly sized image. Indicates ghosting and head motion-induced blurring. Lower = better. Mean_AI_Perc - mean relative voxel-wise absolute Asymmetry Index (AI) within the brain (pGM+pWM mask) (%) SD - same but SD (%) REFERENCES: Preprocessed Connectome Project Quality Assurance Protocol (QAP): http://preprocessed-connectomes-project.org/quality-assessment-protocol/ http://ieeexplore.ieee.org/document/650886/ xASL_qc_PrintOrientation.m Format xASL_qc_PrintOrientation(DIR, reg_exp_INPUT,OUTPUT_DIR,Name); Description Check orientation of niftis, useful to detect accidental left-right flips (all other flips will be visible). translations, rotations or shears are not to be worried about, only negative zooms. This can be detected by negative determinants. So orientation parameters and determinants should be similar across all scans from single scanner/coil, and registration should not give negative determinant. xASL_qc_TanimotoCoeff.m Format TC = xASL_qc_TanimotoCoeff(Image1, Image2[, imMask, type]) Description Compares images Image1 and Image2 within the mask imMask. TYPE specifies the input data type. RATIONALE: Note that the Tanimoto Coefficient is a measure of image overlap/intersection, similar to the Dice coefficient. With the option type 3, this is a fuzzy coefficient, which doesn't require to convert the two images to a binary mask. The TC can be interpreted as a stringent Kappa, ranging from 0 (completely dissimilar) to 100% (identical images). Assuming that perfect registration should not lead to identical images but still retain physiological differences, TC>70% can be regarded as excellent image agreement. The TC will be overestimated when smoothing, but this may lead to more stable artifact detection. xASL_qc_WADQCDC.m Format xASL_qc_WADQCDC(x, iSubject[, ScanType]) Description This QC function runs WAD-QC specific Python script to zip QC information & incorporate this into a DICOM field for analysis on the WAD-QC server, by the following: Define QCDC script: this is the Python script written by Gaspare, edited by Joost Kuijer & copied to the EPAD CustomScripts folder of ExploreASL Python installation location is checked, with several known locations, for several servers. If we cannot find it, the QCDC is not ran Previous QCDC results are cleaned. QCDC stores all its results in a separate folder (Something like 2 layers up from the current folder, here referred to as QCDCDir = [x.D.ROOT 'qcdc_output']) from these result files, only the filled DICOM file is interesting, all the rest are copies of the QC results that we embedded into the DICOM Run QCDC (if Python installation detected) The following files need to be set as executable: ('QCDC', 'src', 'qc_data_collector.py') ('QCDC', 'src', 'bash', 'create_dcm_only_wadqc.sh') ('QCDC', 'src', 'bash', 'sendwadqc.sh') Clean up new QCDC results (as above) & move the filled DICOM to ['qcdc_' DummyFile] within the current ScanType folder Sending the DICOM to the WAD-QC server using storescu xASL_qc_WADQC_GenerateDescriptor.m Format xASL_qc_WADQC_GenerateDescriptor(x, iSubject) Description This QC function generates a JSON descriptor for Gaspare' QCDC script, by the following steps: a) include information about where to find the dummy DICOM (i.e. placeholder DICOM) b) For ExploreASL' QC fields (as passed through in x.Output), here we note all these QC fields for each ScanType, as the x.Output should have been collected equally in the QC file 'QC_collection_SubjectName.json' by function xASL_qc_CollectParameters c) Subfunction xASL_qc_WADQC_images - Includes visual standard space QC images, by searching them on prescribed paths within the Population folder (where currently all derivatives reside) d) Insert the PDF report; this PDF report is subject-specific, not scan-specific. For completeness it is added to each QCDC descriptor e) Add WAD-QC server details (i.e. IP address etc) f) Save the Descriptor JSON file. xASL_qc_temporalSNR.m Format tSNR = xASL_qc_temporalSNR(pathIm4D,pathImTissueProb) Description This function computes several temporal SNR QC parameters as proposed in SPM Univariate Plus: tSNR.tSNR_GM_Ratio : mean GM signal / std GM over time tSNR.tSNR.tSNR_WM_Ratio : mean WM signal / std WM over time tSNR.tSNR.tSNR_CSF_Ratio: mean CSF signal / std CSF over time tSNR.tSNR_WMref_Ratio : mean signal/std over time in eroded deep WM tSNR.tSNR_GMWM_Ratio : mean (GM+WM) signal / sqrt(std(GM+WM)^2+std(WMref)^2) tSNR.tSNR_GMWM_WMref_Ratio: mean (GM+WM) signal / std WMref over time tSNR.tSNR_Physio2Thermal_Ratio: sqrt((tSNR(GM+WM)/tSNR_GMWM_WMref_Ratio))^2-1) tSNR.tSNR_Slope_Corr: Differences to the SPM U+ suggestion: eroded WM is used for estimating background noise Brainmask is determined in the same way as the structural anatQC, CSF is determined from the pGM&pWM maps; REFERENCES: 1. Thomas Liu (2016). Noise contributions to the fMRI signal: An overview NeuroImage, 343, 141-151 http://dx.doi.org/10.1016/j.neuroimage.2016.09.008 2. Cesar Caballero-Gaudes and Richard C. Reynolds (2016). Methods For Cleaning The BOLD fMRI Signal. NeuroImage, 154,128-149 3. Lawrence Wald and Jonathan R Polimeni (2016). Impacting the effect of fMRI noise through hardware and acquisition choices ??? Implications for controlling false positive rates. NeuroImage, 154,15-22 4. SPM Utility + toolbox. Cyril Pernet. https://osf.io/wn3h8/ Quantization xASL_quant_AgeSex2Hct.m Format [Hematocrit] = xASL_quant_AgeSex2Hct([age, sex]) Description This function estimates a participants hematocrit, based on literature-based values for age and sex. It performs the following steps: Warning unknown age/sex Imputing unknown age/sex Define hematocrit per age for unknown sex Define Hematocrit per age for males Define Hematocrit per age for females xASL_quant_BSupCalculation.m Format signalPercentage = xASL_quant_BSupCalculation(BackgroundSuppressionPulseTime, ReadoutTime[, PresaturationTime, T1Time, SliceTime, PathGraph]) Description This function computes the tissue signal percentage that remains after background suppression pulses are played in the ASL acquisition. It assumes that the signal is, at first, optionally saturated by a 90 degree flip at PresaturationTime before readout. Then follows a series of BSup pulses (times before readout are given) that do a 180 degree flip. The observed tissue relaxes with time T1time and the signal attenuation is calculated for several slices acquired at times relative to the readout. xASL_quant_FEAST.m Format xASL_quant_FEAST(x) Description This function quantifies ATT using the FEAST equations, using crushed and non-crushed sessions, of which the ratio is proportional to ATT. Note that the order of sessions should be 1) crushed 2) non-crushed This function runs the following steps: Skip this function if no FEAST data available Admin Load data & correct for timing differences (PLD etc) Smooth and clip CBF maps & FEAST ratio Compute TT maps xASL_quant_GetControlLabelOrder.m Format [ControlIM, LabelIM, OrderContLabl] = xASL_quant_GetControlLabelOrder(FramesIn, x) Description This function automatically checks (and corrects if required) the control and label order of ASL timeseries based on the larger signal in control volumes. It supposes that data is acquired in pairs. xASL_quant_Hct2BloodT1.m Format BloodT1 = xASL_quant_Hct2BloodT1(Hematocrit, Y, B0, bVerbose) Description This function converts hematocrit to blood T1, according to calculations defined by Patrick Hales. With courtesy and thanks! Note that we assume a venous O2 saturation of 68% (Yv=0.68) This function performs the following steps: Check fraction vs percentage hematocrit & Y, should be between 0 and 1 Specify defaults (Hb, Fe) Perform calculation Convert s to ms Print what we did xASL_quant_M0.m Format [M0IM] = xASL_quant_M0(inputM0, x) Description This function quantifies the M0, except for the difference in voxel size between the M0 and ASL source data (which is scaled in xASL_wrp_ProcessM0.m). This function runs the following steps: Correct scale slopes, if Philips Convert control image with background suppression to pseudo-M0 Skip M0 quantification if ~x.ApplyQuantification(4) Set TR specifically for GE Check for correct TR values Quantify the M0, either for single 3D volume or slice-wise Apply custom scalefactor if requested (x.M0_GMScaleFactor) xASL_quant_SinglePLD.m Format [ScaleImage[, CBF]] = xASL_quant_SinglePLD(PWI, M0_im, imSliceNumber, x) Description This script performs a multi-step quantification, by initializing a ScaleImage that travels through this script & gets changed by the following quantification factors: PLD scalefactor (gradient if 2D multi-slice) (if x.ApplyQuantification(3)) Label decay scale factor for single (blood T1) - or dual-compartment (blood+tissue T1) model, CASL or PASL Single-compartment model: Alsop MRM 2014 Dual-compartment model: Wang MRM 2002: Gevers JMRI 2012 (if x.ApplyQuantification(3)) Scaling to physiological units [ml/gr/ms =>ml/100gr/min =>(60,000 ms=>min)(1 gr=>100gr)] (if x.ApplyQuantification(3)) Vendor-specific scalefactor (if x.ApplyQuantification(1) -> future move to dcm2niiX stage) Finally, we: Divide PWI/M0 (if x.ApplyQuantification(5)) Print parameters used Note that the output always goes to the CBF image (in the future this could go to different stages, e.g. dcm2niiX or PWI stage) xASL_quant_SliceTiming.m Format SliceTiming = xASL_quant_SliceTiming(x, inputIm) Description This function takes the x.Q.SliceReadoutTime and returns the SliceTiming parameter. The function creates a vector (of the relatives timings for each slices) out of it with the correct length corresponding to the number of slices in the inputIm corresponding to the BIDS definition. It also checks the x.readout_dim, and for 3D readouts it returns 0. It loads the image from inputIm and calculates the SliceTiming according to the number of slices in the third dimension If a path is given, it also checks if it can find a JSON sidecar, then it loads the JSON sidecar, and looks for SliceTiming inside it. If SliceTiming/SliceReadoutTime is found in the JSON sidecar, it prioritize it over the value in the x-struct For reference, we use these terms: SliceTiming (the BIDS parameter) - it is a vector with the same length as the number of slices and contains the timing of the start of the readout of each slice relative to the first slice SliceReadoutTime - Legacy xASL parameter that will be phased out. It contains either a vector matching the BIDS definition of SliceTiming or a scalar with difference in readout times between the consecutives slices (i.e. the xASL legacy definition of SliceTiming) SliceTimingDiff - Internal parameter in this function for calculating the time difference between consecutive slices. Admin ShortestTR Assign the vector value and check for vector consistency xASL_quant_SliceTiming_ShortestTR.m Format [x] = xASL_quant_SliceTiming_ShortestTR(x) Description When the TR is set to \"shortestTR\" in the ASL acquisition, each ASL scan will have its unique TR. As this is shortest, there won't be a delay between the readout of the last slice and the end of the TR. Therefore, the time to read out all slices is TR - InitialPostLabelDelay - LabelingDuration, and dividing this by the number of slices gives the SliceReadoutTime SPM xASL_spm_BiasfieldCorrection.m Format xASL_spm_BiasfieldCorrection(PathIn, SPMdir, Quality, MaskName, PathOut) Description This function is a wrapper around the SPM \"old segment\" function, for biasfield removal. It is tested for M0 and mean control images. It conducts the following steps: Create implicit mask Define SPM 'old segmentation' settings Run SPM 'old segmentation' Delete temporary files Rename temporary SPM file into output file xASL_spm_affine.m Format xASL_spm_affine(srcPath, refPath, fwhmSrc, fwhmRef[,otherList, bDCT, bQuality]) Description This SPM wrapper runs SPM's old normalize-estimate function, which calculates the affine transformation (i.e. linear + zooming and shearing) that is required to align the source image with the reference image. By default it does not estimate the low-degree Discrete Cosine Transform (DCT) to have a simple affine transformation but this can be enabled in this wrapper. Also note that this affine transformation uses a correlation cost function, hence it requires the source and reference images to have similar contrasts and resolution - or provide the resolution estimates so the smoothing can be done. This function does not change the orientation header by default, but it allows to change those of others through the otherList. If bDCT is used or no otherList given, it stores its estimated affine transformation as orientation difference matrix in a file with the same path but _sn.mat extension. For the provided smoothing FWHM, note that smoothnesses combine with Pythagoras' rule (i.e. square summing). xASL_spm_coreg.m Format xASL_spm_coreg(refPath, srcPath[, OtherList, x, sep, FastReg]) Description This SPM wrapper runs SPMs coregister-estimate function, which calculates the 6 parameter rigid-body transformation (a.k.a. linear) that is required to align the source image with the reference image. This 6 parameter transformation (i.e. 3 XYZ translations and 3 rotations) is applied to the orientation header of the source NIfTI image, and also to the images provided in OtherList (optional). Note that this SPM registration function uses a normalized mutual information (NMI) by default, enabling registration between two images with different contrast. Note that this algorithm will use the first volume of a multi-volume NIfTI xASL_spm_deface.m Format xASL_spm_deface(PathIn, bReplace) Description This function removes the face from an anatomical NIfTI image, e.g. T1w or FLAIR, for disidentification/privacy purposes. When this script is run after the ExploreASL structural module, it does a pretty good job even for 2D images. However, note that this can always fail, strip part of the brain, or change the output of pipelines. So best not to compare results from defaced and non-defaced images. Also, note that defacing makes it difficult to ensure that the FLAIR and T1w are from the same subject. xASL_spm_deformations.m Format xASL_spm_deformations([x,] PathIn, PathOut[, Interpolation, InverseSpace, AffineTrans, DeformationPath]) Description This ExploreASL wrapper manages the SPM deformation tool. It takes multiple (ExploreASL pipeline) transformations and combines/concatenates them into a single transformation prior to applying it to the input images. This allows to apply multiple transformations with a single interpolation, avoiding propagation of undesired interpolation effects. Mainly used to get native space images into standard space, or vice versa. Best to combine as many files as possible within this function, since the deformation calculation (which is the most computation intensive part) needs to be performed once for multi-file resampling This function runs the following steps: Statistics xASL_stat_AtlasForStats.m Format [x] = xASL_stat_AtlasForStats(x) Description This function loads atlases, checks them, and their ROI names, for later use as ROI definition in xASL_stat_GetROIstatistics Note that the atlases should be integer values, or different 4rd dimensions (i.e. multiple images), that are mutually exclusive. This function takes the following steps: Load atlas ROI names There should be a TSV sidecar to the atlas NIfTI file, as explained above. deal with memory mapping Resample atlas 50 1.5 mm^3 MNI Converted atlas with integers to 4D binary image Convert/compress masks into Columns Print atlas overview image xASL_stat_ComputeDifferCoV.m Format diffCoV = xASL_stat_ComputeDifferCoV(imCBF) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask,bPVC,imGM,imWM) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask,bPVC,imGM,imWM,b3D) Description It calculates the spatial DiffCoV value on finite part of imCBF. Optionally a mask IMMASK is provide, and PVC is done for bPVC==2 using imGM and imWM masks and constructing pseudoCoV from pseudoCBF image. For bPVC~=2, imGM and imWM are ignored. It is calculated in 2D or assuming also 3D edges based on B3D. Calculate derivate spatial CoV, by summing up differences in CBF between neighbors. The derivative uses Sobels filter. xASL_stat_ComputeMean.m Format [CBF_GM CBF_WM] = xASL_stat_ComputeMean(imCBF[, imMask, nMinSize, bPVC, bParametric, imGM, imWM]) Description It calculates mean or median of CBF over the mask imMask if the mask volume exceeds nMinSize. It calculates either a mean, a median, or a mean after PVC, depending on the settings of bPVC. For the PVC options, it needs also imGM and imWM and returns the separate PV-corrected values calculated over the entire ROI. Admin Mask calculations Calculate the ROI statistics 3a. No PVC and simple mean 3b. No PVC and median 3c. Simple PVC 3d. Full PVC on a region xASL_stat_ComputeSpatialCoV.m Format sCov = xASL_stat_ComputeSpatialCoV(imCBF[, imMask, nMinSize, bPVC, bParametric, imGM, imWM]) Description It calculates the spatial CoV value on finite part of imCBF. Optionally a mask IMMASK is provide, ROIs of size < NMINSIZE are ignored, and PVC is done for bPVC==2 using imGM and imWM masks and constructing pseudoCoV from pseudoCBF image. For bPVC~=2, imGM and imWM are ignored Admin Create masks sCoV computation xASL_stat_EqualVariancesTest.m Format [resTest, P] = xASL_stat_EqualVariancesTest(X[, alpha, type]) Description Brown-Forsythe or Levene's test for equality of variances. The response variable is transformed (yij = abs(xij - median(xj)) for Brown-Forsythe and yij = abs(xij - mean(xj)) for Levene's test). And then runs a one-way ANOVA F-test to check if the variances are equal. xASL_stat_GetROIstatistics.m Format [x] = xASL_stat_GetROIstatistics(x) Description This function computes mean and spatial CoV for each ROI, in a [1.5 1.5 1.5] mm MNI space, with several ASL-specific adaptions: Skip ROI masks that are smaller than 1 mL as this would be too noisy for ASL (ignored when x.S.IsASL==false) Expand each ROI mask such that it has sufficient WM content (skipped when IsASL==false) Create for each ROI mask a left, right and bilateral copy Iterate over all subjects: a) Load partial volume maps b) Correct for WMH SEGM -> IS THIS STILL REQUIRED??? c) Load data d) Show ROIs projected on ASL image e) Actual data computations Partial Volume Correction (PVC) options: PVC==0 -> perform masking only, no regression PVC==1 -> single compartment regression, for pGM PVC==2 -> dual compartment regression for pGM & pWM (i.e. normal PVC) Here we mask out susceptibility artifacts (including outside FoV) for all ASL computations, and also mask out vascular artifacts for computing the mean. While other artifacts/FoV can be masked out on population level (i.e. >0.95 subjects need to have a valid signal in a certain voxel), vascular artifacts differ too much in their location between subjects, so we mask this on subject-level. Note that the words \"mask\" and \"ROI\" are used interchangeably throughout this function, where they can have a different or the same meaning PM: WE COULD CHANGE THIS, INTO MASK BEING USED TO EXCLUDE VOXELS AND ROI FOR INCLUDING VOXELS xASL_stat_MadNan.m Format y = xASL_stat_MadNan(x[,flag, dim]) Description Calculates a Median/Mean Absolute deviation, but ignoring NaNs in the calculation. xASL_stat_MadNan(X) or xASL_stat_MadNan(X,0) computes xASL_stat_MeanNan(ABS(X-xASL_stat_MeanNan(X)) xASL_stat_MadNan(X,1) computes xASL_stat_MedianNan(ABS(X-xASL_st_MedianNan(X)). xASL_stat_MeanSSIM.m Format mssim=xASL_stat_MeanSSIM(imRef,imSrc[,dynRange]) Description Calculates the similarity index according to Want et al. xASL_stat_MultipleLinReg.m Format [b,CI,pval,stats] = xASL_stat_MultipleLinReg(X,Y[,bIntercept]) Description Performs a multiple linear regression Y=b*X+a and provides the intercept and regression coefficients beta including their significance and confidence intervals. It calculates additionally the goodness of the fit. xASL_stat_PSNR.m Format PSNR=xASL_stat_PSNR(imRef,imSrc) Description Calculates the PSNR, needs two input arguments - 3D images of the same size. Uses 95% percentile instead of MAX. xASL_stat_PairwiseDice.m Format [DiceCoeff] = xASL_stat_PairwiseDice(GroupA, GroupB) Description This function obtains for two lists of images Dice coefficients, for all possible permutations of both lists, by the following steps: 1. Admin (check cell, image exist etc) 2. Obtain matrix of pair-wise permutations 3. Obtain DICE scores PM: Allow entering one group only PM: could extend with xASL_qc_TanimotoCoeff xASL_stat_PrintStats.m Format [x] = xASL_stat_PrintStats(x) Description This function prints an overview of statistics from data that were acquired per ROI, in a TSV file. It starts by printing covariates (called \"Sets\"). Rows will be subjects/sessions, columns will be the sets and ROI-statistics. Any missing data will be skipped (setting them to NaN should have happened in a previous function). This function performs the following steps: First remove previous TSV-file, if already existed printing to a TSV file can be tricky if it is opened by Excel. Make sure to close previous versions first, otherwise this part will crash. Print overview of sets to TSV as explained above. Uses subfunction xASL_stat_CreateLegend to put legends. Aim is to create a single TSV file that has a proper overview of the data, & is self-explanatory to those reading/using it. Define number of ASL sessions, force to 1 in case of TT or volume metrics Print the overview xASL_stat_QuantileNan.m Format y = xASL_stat_QuantileNan(x[,quant, dim]) Description Calculates a quantile, but ignoring NaNs in the calculation xASL_stat_RobustMean.m Format [NoOutliers, iOutliers, ThresholdDeviation] = xASL_stat_RobustMean(IM, ParameterFunction) Description This function detects outlier images, that can be used to create a robust average, e.g. for template or biasfield creation. This is based either on the sum-of-squares with the mean image (SoS), or on the average relative asymmetry index (AI). Images that are median+/-3 mad off are defined as outliers. MAD = median/mean absolute difference xASL_stat_ShapiroWilk.m Format [H, P, W] = xASL_stat_ShapiroWilk(x[, alpha]) Description Performs the statistical test of normality - null hypothesis is that the sample is from normal distribution with unspecified mean and variance. Based on the sample kurtosis it performs either Shapiro-Wilk (for platykurtic) or Shapiro-Francia test (for leptokurtic). xASL_stat_StdNan.m Format y = xASL_stat_StdNan(x[,w,dim]) Description It behaves in a similar way as VAR - it directly passes all arguments to xASL_stat_VarNan. xASL_stat_SumNan.m Format y = xASL_stat_SumNan(x[,dim]) Description It uses the function SUM, but it sets all the NaNs to zero before calling it. xASL_stat_UniquePairwisePermutations.m Format [PermutationList] = xASL_stat_UniquePairwisePermutations(GroupA, GroupB) Description This function lists for one or two samples of indices all possible permutations of indices, performing the following steps: One sample permutations Two sample permutations Print conclusion PM: Allow entering one group only PM: could extend with xASL_qc_TanimotoCoeff xASL_stat_VarNan.m Format y = xASL_stat_VarNan(x[,w,dim]) Description It behaves in a similar way as VAR. xASL_stat_fcdf.m Format F = xASL_stat_fcdf(F,M,N) Description Calculates the cumulative distribution function of the F-distribution for degrees of freedom M,N at value F. xASL_stat_tcdf.m Format F = xASL_stat_tcdf(T,nu) Description Calculates the cumulative distribution function of the Student's t-distribution for degrees of freedom nu at value T. xASL_stat_ticdf.m Format T = xASL_stat_ticdf(P,nu) Description Calculates the inverse of cumulative distribution function of the Student's t-distribution for degrees of freedom nu at value P. xASL_stat_ttest.m Format [H,P,CI,stats] = xASL_stat_ttest(X[,M,alpha,tail,dim]) Description Performs a t-test that the distribution of the input data X has a mean different from 0 (or from a given mean M, or that the distributions X and Y have different means). A normal distribution of the data with an unknown variance is assumed. xASL_stat_ttest2.m Format [H,P,CI,stats] = xASL_stat_ttest2(X,Y[,alpha,tail,vartype,dim]) Description Performs a unpaired t-test that the distribution of the input data X has a mean different from that of Y. A normal distribution of the data with an unknown variance is assumed. xASL_str2num.m Format [DataOut] = xASL_str2num(DataIn[, bKeepCell, bReplaceNonNumerical]) Description str2num wrapper, which only converts strings to numbers, and allows inputting cells. Also, it replaces 'n/a' with NaN (BIDS convention). And it has some other functionality as described in bKeepCell & bReplaceNonNumerical above. xASL_test_GetLogContent.m Format [logContent] = xASL_test_GetLogContent(rootDir, [printContent], [storeRelativePath], [exportTable]) Description Get warnings and errors from log files. Input check Load all log files Iterate over log files Optional: Print log content Optional: Export (0 = no export, 1 = TSV export, 2 = XLSX export) Visualization xASL_vis_AddIM2QC.m Format [x] = xASL_vis_AddIM2QC(x,parms); Description Checks which images already are loaded, and adds new image. xASL_vis_CreateVisualFig.m Format [ImOut, FileName] = xASL_vis_CreateVisualFig(x, ImIn, DirOut, IntScale, NamePrefix, ColorMap, bClip) Description This function creates a visualization Figure by merging flexibly rearranging NIfTI slices, input matrix or path, managing colormaps for different merged image layers. Current use is for visual QC figures and overview in papers. Function is structured as: Admin, deal with input arguments Process image layers separately * xASL_im_TransformData2View: Reshapes image data into visualization figure * xASL_im_ClipExtremes: Clips image to given percentile also we scale for peak intensity, we make sure that there is no visible clipping/distortion * Convert to colors, using any input colormaps combine image layers, using input argument IntScale print figure This function assumes that the first image is a grayscale background image (e.g. for transparancy reasons), if there are multiple images xASL_vis_CropParmsAcquire.m Format [xmin xmax ymin ymax] = xASL_vis_CropParmsAcquire(temp_image) Description Goes from outside to inside to acquire crop settings. Works with grayscale images (2 dimensions per slice). Image position information (2D matrix) should be first 2 dimensions. Could include colordimension later on. xASL_vis_CropParmsApply.m Format ImageOut = xASL_vis_CropParmsApply(ImageIn,CropParameters) Description This function crops 2D image matrices. xASL_vis_Imwrite.m Format [ImOut] = xASL_vis_Imwrite(ImIn, PathOut[, ColorMap, bRescale]) Description This functions takes an input image matrix, interpolates it to HD resolution (1920x1080) for visibility, and saves the image as jpg. This function avoids the graphic interface of Matlab, for running from CLI Careful: this function overwrites any existing PathOut. xASL_vis_OverlapT1_ASL.m Format xASL_vis_OverlapT1_ASL( x, ASL) Description Part of ExploreASL. Shows spatial agreement ASL and probability maps. xASL_vis_TileImages.m Format [ImOut] = xASL_vis_TileImages(ImIn, nColumns) Description Merges selected slices (3D) into one single 2D picture. Plots all slices in one figure with specified rows and columns, aiming for a square tile. PM: can be extended to multiple slices xASL_vis_TransformData2View.m Format FigureOut = xASL_vis_TransformData2View(ImagesIn, x) Description This function changes the dimensionality and reshapes the input images in such a way that they are nicely tiled in a mosaic for visualization purposes. Reshaping a series of images with this function can be useful for visualization of SPM/voxel-based analyses. xASL_vis_VisualQC_TopUp.m Format [MeanAI_PreTopUp_Perc, MeanAI_PostTopUp_Perc] = xASL_vis_VisualQC_TopUp(PathPopB0, PathPopUnwarped, x, iSubject, CheckDir) Description This function creates a Figure that showes the effect of TopUp with 6 images with axial slices: the NormPE, RevPE and their difference image in colorscale, and this before (upper row) & after (lower row) TopUp. xASL_vis_VisualizeROIs.m Format xASL_vis_VisualizeROIs(x, ROI_list) Description Creates for each subject a JPEG image containing the original T1w, WMH_SEGM and T1w after lesion-filling. xASL_wrp_LinearReg_Others2T1w.m Format xASL_wrp_LinearReg_Others2T1w(x[, bAutoACPC]) Description This submodule registers T1c and T2 linearly to the T1w","title":"Functions"},{"location":"Functions/#functions","text":"","title":"Functions"},{"location":"Functions/#general-functions","text":"","title":"General Functions"},{"location":"Functions/#xasl_iterationm","text":"","title":"xASL_Iteration.m"},{"location":"Functions/#format","text":"[bAborted, xOut] = xASL_Iteration(x, moduleName[, dryRun, stopAfterErrors])","title":"Format"},{"location":"Functions/#description","text":"Parses the settings and runs the DatabaseLoop sub-function.","title":"Description"},{"location":"Functions/#administration","text":"","title":"Administration"},{"location":"Functions/#xasl_adm_catchnumbersfromstringm","text":"","title":"xASL_adm_CatchNumbersFromString.m"},{"location":"Functions/#format_1","text":"[OutputNumber] = xASL_adm_CatchNumbersFromString(InputString)","title":"Format"},{"location":"Functions/#description_1","text":"Extracts a number from a char array.","title":"Description"},{"location":"Functions/#xasl_adm_checkfilecountm","text":"","title":"xASL_adm_CheckFileCount.m"},{"location":"Functions/#format_2","text":"[result, files] = xASL_adm_CheckFileCount(path, expr[, mincount, failifmissing]) [result] = xASL_adm_CheckFileCount(...)","title":"Format"},{"location":"Functions/#description_2","text":"Checks the given PATH for files corresponding to the SPM_SELECT regular expression EXPR . Returns if the number of files is equal to or higher than MINCOUNT . If FAILIFMISSING is true and not enough files, then throw and error. If everything goes ok and second output argument is specified then return also the list of files.","title":"Description"},{"location":"Functions/#xasl_adm_checkpermissionsm","text":"","title":"xASL_adm_CheckPermissions.m"},{"location":"Functions/#format_3","text":"[FilesList, FilesExeList, FoldersList] = xASL_adm_CheckPermissions(InputPath[, FilesExecutable])","title":"Format"},{"location":"Functions/#description_3","text":"This function does a recursive search through the root folder & makes a list of the attributes of all files and folders. It tries to reset the attributes to what we desire, which is by default: 664 for files (meaning only reading & writing for users & group, & read-only for others) 775 for folders (meaning reading, writing & opening for current user & current group, & for others only reading & opening) For executable files we also want 775. Note that the permission to 'execute a folder' means opening them. DataOK checks data permissions. ExeOK checks executable permissions. DataOK also includes executable permissions for folders. This runs recursively (but currently skips the contents of the root-folder) .","title":"Description"},{"location":"Functions/#xasl_adm_checkspmm","text":"","title":"xASL_adm_CheckSPM.m"},{"location":"Functions/#format_4","text":"[spm_path, spm_version] = xASL_adm_CheckSPM([modality, proposed_spm_path, check_mode]) [spm_path] = xASL_adm_CheckSPM(...) xASL_adm_CheckSPM(...)","title":"Format"},{"location":"Functions/#description_4","text":"Checks if the spm function exists and if the reported version matches our development version ( SPM8 or SPM12 ). If the spm toolbox is not available yet, it will try the PROPOSED_SPM_PATH (if specified) or the user selected directory and add it to PATH . The function will fail if SPM cannot be found or if detecting an unsupported version.","title":"Description"},{"location":"Functions/#xasl_adm_cleanupbeforererunm","text":"","title":"xASL_adm_CleanUpBeforeRerun.m"},{"location":"Functions/#format_5","text":"xASL_adm_CleanupBeforeCompleteRerun(AnalysisDir, iModule, bRemoveWMH, bAllSubjects, SubjectID)","title":"Format"},{"location":"Functions/#description_5","text":"This function (partly) reverts previous ExploreASL runs, deleting derivatives, while keeping raw data intact. if bAllSubjects==true, then all subjects and all module derivatives will be removed. This function performs the following steps: If a Population folder doesn't exist yet but dartel does, rename it Remove whole-study data files in AnalysisDir if bAllSubjects Remove lock files/folders for reprocessing Restore backupped _ORI (original) files Delete native space CAT12 temporary folders (always, independent of iModule) Remove native space files for iModule Remove standard space files for iModule Remove population module files Remove or clean up stored x-struct & QC file -> THIS HAS NO SESSION SUPPORT YET NB: still need to add xASL_module_func & xASL_module_dwi for EPAD","title":"Description"},{"location":"Functions/#xasl_adm_comparedatasetsm","text":"","title":"xASL_adm_CompareDataSets.m"},{"location":"Functions/#format_6","text":"[RMS] = xASL_adm_CompareDataSets(RefAnalysisRoot,SourceAnalysisRoot,x,type,mutexState)","title":"Format"},{"location":"Functions/#description_6","text":"Compare data sets is used to ... type 0: Only save type 1: Save and evaluate type 2: Only evaluate","title":"Description"},{"location":"Functions/#xasl_adm_comparelistsm","text":"","title":"xASL_adm_CompareLists.m"},{"location":"Functions/#format_7","text":"[NewList] = xASL_adm_CompareLists(list1, list2)","title":"Format"},{"location":"Functions/#description_7","text":"This script compares two single dimension lists.","title":"Description"},{"location":"Functions/#xasl_adm_convertdate2nrm","text":"","title":"xASL_adm_ConvertDate2Nr.m"},{"location":"Functions/#format_8","text":"[Nr DayInYear] = xASL_adm_ConvertDate2Nr(TempDate)","title":"Format"},{"location":"Functions/#description_8","text":"Converts date to number input mmdd -> output mm (with days in fractions/floating point). Inverse from ConvertNrDate.","title":"Description"},{"location":"Functions/#xasl_adm_convertnr2timem","text":"","title":"xASL_adm_ConvertNr2Time.m"},{"location":"Functions/#format_9","text":"Time = xASL_adm_ConvertNr2Time(Nr)","title":"Format"},{"location":"Functions/#description_9","text":"Converts number to time input hh (with minutes in fractions/floating point) -> output hhmm. Inverse from xASL_adm_ConvertTime2Nr.","title":"Description"},{"location":"Functions/#xasl_adm_convertsubjsess2subj_sessm","text":"","title":"xASL_adm_ConvertSubjSess2Subj_Sess.m"},{"location":"Functions/#format_10","text":"[iSubj iSess] = xASL_adm_ConvertSubjSess2Subj_Sess(nSessions, iSubjSess)","title":"Format"},{"location":"Functions/#description_10","text":"Converts combined SubjectSession index to subject & session indices. Useful for data lists in ExploreASL.","title":"Description"},{"location":"Functions/#xasl_adm_converttime2nrm","text":"","title":"xASL_adm_ConvertTime2Nr.m"},{"location":"Functions/#format_11","text":"Nr = xASL_adm_ConvertTime2Nr(Time)","title":"Format"},{"location":"Functions/#description_11","text":"Converts time to number input hhmm -> output hh (with minutes in fractions/floating point). Inverse from xASL_adm_ConvertNr2Time.","title":"Description"},{"location":"Functions/#xasl_adm_copymovefilelistm","text":"","title":"xASL_adm_CopyMoveFileList.m"},{"location":"Functions/#format_12","text":"[List] = xASL_adm_CopyMoveFileList(OriDir, DstDir, StrRegExp, bMove[, bDir, bRecursive, bOverwrite, bVerbose])","title":"Format"},{"location":"Functions/#description_12","text":"Moves a file to a file, a file to a directory, or a directory to a directory. It keeps the initial extensions, no unzipping or zipping after the move. But it makes sure that only one of .nii and .nii.gz exists in the destination directory. Useful to split a large database.","title":"Description"},{"location":"Functions/#xasl_adm_correctnamem","text":"","title":"xASL_adm_CorrectName.m"},{"location":"Functions/#format_13","text":"strOut = xASL_adm_CorrectName(strIn[, bOption, strExclude])","title":"Format"},{"location":"Functions/#description_13","text":"Finds and replaces all non-word characters either by empty space or by an underscore. Optionally leaves in few selected special characters. Note that if '_' is excluded from replacement, but option 2 is on, then underscores are replaced anyway.","title":"Description"},{"location":"Functions/#xasl_adm_createfilereportm","text":"","title":"xASL_adm_CreateFileReport.m"},{"location":"Functions/#format_14","text":"x = xASL_adm_CreateFileReport(x, bHasFLAIR, bHasMoCo, bHasM0, bHasLongitudinal)","title":"Format"},{"location":"Functions/#description_14","text":"Prints a summary of created files or the individual modules (i.e. Structural, Longiutudinal & ASL modules). Provides a quick check to see what has been skipped, an whether all files are present. This script iterates across: Native space 1) subject and 2) session files, Resampled 3) subject and 4) session files, 5) Lock files and 6) QC Figure files. For all we perform a: A) Count of the files present, summarized in FileReportSummary.csv B) List of the missing files in \"Missing*.csv\" files PM: Simplify/optimize this code, to make filename variable changing, search within subject-directories, etc. Combine the parts searching for missing & summarizing count.","title":"Description"},{"location":"Functions/#xasl_adm_defineaslresolutionm","text":"","title":"xASL_adm_DefineASLResolution.m"},{"location":"Functions/#format_15","text":"x = xASL_adm_DefineASLResolution(x)","title":"Format"},{"location":"Functions/#description_15","text":"If the parameters x.ResolutionEstimation == 1, it initializes the resolution with expected values per sequence type and then runs the procedure xASL_im_ResolutionEstim to estimate the resolution from the mismatch between ASL and structural data. For x.ResolutionEstimation == 0, xASL_init_DefaultEffectiveResolution the educated guess is used for the estimated resolution using previous data and analyzis.","title":"Description"},{"location":"Functions/#xasl_adm_defineaslsequencem","text":"","title":"xASL_adm_DefineASLSequence.m"},{"location":"Functions/#format_16","text":"[x] = xASL_adm_DefineASLSequence(x)","title":"Format"},{"location":"Functions/#description_16","text":"This ExploreASL function tries to check what ASL sequence is being processed, if this was not already defined in x.Sequence. It does so by checking known combinations of readout dimensionality (x.readout_dim) and vendor, knowing the product sequences of the vendors.","title":"Description"},{"location":"Functions/#xasl_adm_deletefilepairm","text":"","title":"xASL_adm_DeleteFilePair.m"},{"location":"Functions/#format_17","text":"filepaths = xASL_adm_DeleteFilePair(path, ext1[, ext2 [, ext3 ...]]) xASL_adm_DeleteFilePair(path, ext1[, ext2 [, ext3 ...]])","title":"Format"},{"location":"Functions/#description_17","text":"Delete the file given in PATH, and also deletes files with the same name, but with extension given in EXT1, and potentially also EXT2, EXT3...","title":"Description"},{"location":"Functions/#xasl_adm_dicom2parmsm","text":"","title":"xASL_adm_Dicom2Parms.m"},{"location":"Functions/#format_18","text":"[parms pathDcmDictOut] = xASL_adm_Dicom2Parms(inp[, parmsfile, dcmExtFilter, bUseDCMTK, pathDcmDictIn])","title":"Format"},{"location":"Functions/#description_18","text":"The function goes through the INP files, reads the DICOM or PAR/REC files and parses their headers. It extracts the DICOM parameters important for ASL, makes sure they are in the correct format, if missing then replaces with default value, it also checks if the parameters are consistent across DICOM files for a single sequence.","title":"Description"},{"location":"Functions/#xasl_adm_doccrawlerm","text":"","title":"xASL_adm_DocCrawler.m"},{"location":"Functions/#format_19","text":"xASL_adm_DocCrawler(inputPath)","title":"Format"},{"location":"Functions/#description_19","text":"This function checks each individual file header and extracts the information. The results is saved as a markdown file. If you want to use star symbols (*testFile.m e.g.) we recommend not to use them in the same line with bold text (which is written like this: bold text ).","title":"Description"},{"location":"Functions/#xasl_adm_docinitializem","text":"","title":"xASL_adm_DocInitialize.m"},{"location":"Functions/#format_20","text":"xASL_adm_DocInitialize","title":"Format"},{"location":"Functions/#description_20","text":"This function generates all markdown files, which are necessary for the mkdocs documentation.","title":"Description"},{"location":"Functions/#xasl_adm_findbyregexpm","text":"","title":"xASL_adm_FindByRegExp.m"},{"location":"Functions/#format_21","text":"xasl_adm_FindByRegExp(root, dirSpecs[, varargin])","title":"Format"},{"location":"Functions/#description_21","text":"Recursively find files in the root directory according to the dirSpecs.","title":"Description"},{"location":"Functions/#xasl_adm_findstrindexm","text":"","title":"xASL_adm_FindStrIndex.m"},{"location":"Functions/#format_22","text":"INDEX = xASL_adm_FindStrIndex(ARRAY, STRING)","title":"Format"},{"location":"Functions/#description_22","text":"Similar to find, but then for a cell array filled with strings. Only takes 4 dimensions.","title":"Description"},{"location":"Functions/#xasl_adm_getfslistm","text":"","title":"xASL_adm_GetFsList.m"},{"location":"Functions/#format_23","text":"RES = xASL_adm_GetFsList([strDirectory, strRegEx, bGetDirNames, bExcludeHidden, bIgnoreCase, nRequired])","title":"Format"},{"location":"Functions/#description_23","text":"List files or directories from a given path. And optionally uses regular expressions to filter the result with options to exclude hidden files, ignore case, and set a minimal requirement on the number of results. Sorts the results at the end.","title":"Description"},{"location":"Functions/#xasl_adm_getnumfromstrm","text":"","title":"xASL_adm_GetNumFromStr.m"},{"location":"Functions/#format_24","text":"num = xASL_adm_GetNumFromStr(str)","title":"Format"},{"location":"Functions/#description_24","text":"Obtains single number from string. CAVE there should only be one number!","title":"Description"},{"location":"Functions/#xasl_adm_getphilipsscalingm","text":"","title":"xASL_adm_GetPhilipsScaling.m"},{"location":"Functions/#format_25","text":"scaleFactor = xASL_adm_GetPhilipsScaling(pathParmsMat,pathNifti)","title":"Format"},{"location":"Functions/#description_25","text":"This script provides the correct scaling factors for a NIfTI file. It checks the header of the NIfTI that normally has the same scaling as RescaleSlope in DICOM, it checks if dcm2nii (by the info in JSON) has already converted the scale slopes to floating point. And if not, the derive the correct scaling factor to be applied.","title":"Description"},{"location":"Functions/#xasl_adm_getusernamem","text":"","title":"xASL_adm_GetUserName.m"},{"location":"Functions/#format_26","text":"UserName = xASL_adm_GetUserName()","title":"Format"},{"location":"Functions/#description_26","text":"Get the name of the current user.","title":"Description"},{"location":"Functions/#xasl_adm_hex2numm","text":"","title":"xASL_adm_Hex2Num.m"},{"location":"Functions/#format_27","text":"outNum = xASL_adm_hex2num(inStr)","title":"Format"},{"location":"Functions/#description_27","text":"Takes a hexadecimal string and converts it to number or string. Works also when the string contains escape characters, and for single-floats and for a little and big endian. If containing 8 and less characters than treat as float, if more than as double.","title":"Description"},{"location":"Functions/#xasl_adm_lesionreslicelistm","text":"","title":"xASL_adm_LesionResliceList.m"},{"location":"Functions/#format_28","text":"[INname, OUTname] = xASL_wrp_LesionResliceList(x,bLesion_T1,bLesion_FLAIR,bROI_T1,bROI_FLAIR)","title":"Format"},{"location":"Functions/#description_28","text":"Creates list of structural image paths to reslice.","title":"Description"},{"location":"Functions/#xasl_adm_loadparmsm","text":"","title":"xASL_adm_LoadParms.m"},{"location":"Functions/#format_29","text":"[Parms, x] = xASL_adm_LoadParms(ParmsPath[, x, bVerbose])","title":"Format"},{"location":"Functions/#description_29","text":"This function loads the internal memory x struct, any legacy *_parms.mat sidecar, any *.json BIDS sidecar, to use scan-specific parameters for image processing/quantification. Also, per BIDS inheritance, any x.S.SetsID parameters (from participants.tsv) are loaded as well. This function performs the following steps: Load .mat parameter file Load JSON file Deal with warnings Find fields with scan-specific data in x.S.Sets, and use this if possible (per BIDS inheritance) Sync Parms.* with x.(Q.)* (overwrite x/x.Q) Fix M0 parameter if not set","title":"Description"},{"location":"Functions/#xasl_adm_loadxm","text":"","title":"xASL_adm_LoadX.m"},{"location":"Functions/#format_30","text":"[x[, IsLoaded]] = xASL_adm_LoadX(x[, Path_xASL, bOverwrite])","title":"Format"},{"location":"Functions/#description_30","text":"This function loads x.Output & x.Output_im struct fields from the x.mat on the hard drive & adds them to the current x struct located in memory. If it didnt exist in the x.mat, it will set IsLoaded to false, which can be catched externally & a warning issued if managed so in the calling function. If it didnt exist in the memory x struct, or bOverwrite was requested, the contents of x.mat will be loaded to the memory x struct","title":"Description"},{"location":"Functions/#xasl_adm_makestandalonem","text":"","title":"xASL_adm_MakeStandalone.m"},{"location":"Functions/#format_31","text":"xASL_adm_MakeStandalone(outputPath, bCompileSPM, importDCM, markAsLatest);","title":"Format"},{"location":"Functions/#description_31","text":"This function creates an output folder including a standalone version of ExploreASL, which can be used with the Matlab Runtime outside of Matlab itself. A quick fix to solve path dependencies etc. is to first compile SPM (but this can be turned off for speed). This function performs the following steps: Manage ExploreASL and compiler code folders Capture version/date/time File management output folder & starting diary Handle SPM Specific Options Manage compilation paths Run SPM compilation Run ExploreASL compilation Print done","title":"Description"},{"location":"Functions/#xasl_adm_orderfieldsm","text":"","title":"xASL_adm_OrderFields.m"},{"location":"Functions/#format_32","text":"outStruct = xASL_adm_OrderFields(inStruct,orderStruct)","title":"Format"},{"location":"Functions/#description_32","text":"Order fields in the structure inStruct to match orderStruct , unmatching fields in inStruct are copied as they are at the end, unmatching fields in orderStruct are ignored. This is just a cosmetic change and no values are edited.","title":"Description"},{"location":"Functions/#xasl_adm_otherlistspmm","text":"","title":"xASL_adm_OtherListSPM.m"},{"location":"Functions/#format_33","text":"[OtherListSPM, OtherListOut] = xASL_adm_OtherListSPM(OtherList, bList4D)","title":"Format"},{"location":"Functions/#description_33","text":"bPadComma1 is to add the ,1 to the end of the pathstring, which SPM uses to assign the first image of a 4D image array (OPTIONAL, DEFAULT = true) bList4D: boolean, true for listing multiple 4D volumes separately in the list (OPTIONAL, DEFAULT=true).","title":"Description"},{"location":"Functions/#xasl_adm_parreadheaderm","text":"","title":"xASL_adm_ParReadHeader.m"},{"location":"Functions/#format_34","text":"info =xASL_adm_ParReadHeader(filename)","title":"Format"},{"location":"Functions/#description_34","text":"Function for reading the header of a Philips Par / Rec MR V4.* file.","title":"Description"},{"location":"Functions/#xasl_adm_removelogfilesforrerunm","text":"","title":"xASL_adm_RemoveLogFilesForRerun.m"},{"location":"Functions/#format_35","text":"xASL_adm_RemoveLogFilesForRerun(rootDir);","title":"Format"},{"location":"Functions/#description_35","text":"Removes all log files from any directory containing .log files.","title":"Description"},{"location":"Functions/#xasl_adm_remove_1_spmm","text":"","title":"xASL_adm_Remove_1_SPM.m"},{"location":"Functions/#format_36","text":"[OtherList] = xASL_adm_Remove_1_SPM(OtherList)","title":"Format"},{"location":"Functions/#description_36","text":"Remove ,1 at end of OtherLists, if exists. These are appended in CoregInit, OldNormalizeWrapper etc, since this should allow 4rd dim (e.g. as in ASL4D).","title":"Description"},{"location":"Functions/#xasl_adm_replacesymbolsm","text":"","title":"xASL_adm_ReplaceSymbols.m"},{"location":"Functions/#format_37","text":"strOut = xASL_adm_ReplaceSymbols(strIn, symbolTable[, bracketLeft, bracketRight])","title":"Format"},{"location":"Functions/#description_37","text":"It takes the STRIN on input, then looks for symbols between BRACKETLEFT and BRACKETRIGHT and replaces these symbols in in the string by the values provided in the SYMBOLTABLE as SYMBOLTABLE.SYMBOL, SYMBOLTABLE.D.SYMBOL, or SYMBOLTABLE.P.SYMBOL","title":"Description"},{"location":"Functions/#xasl_adm_resetvisualizationslicesm","text":"","title":"xASL_adm_ResetVisualizationSlices.m"},{"location":"Functions/#format_38","text":"[x] = xASL_adm_ResetVisualizationSlices(x)","title":"Format"},{"location":"Functions/#description_38","text":"Removes any predefined slices that should be visualized, allowing to show the default slices. Comes in handy when different pipeline visualization parts are repeated.","title":"Description"},{"location":"Functions/#xasl_adm_savexm","text":"","title":"xASL_adm_SaveX.m"},{"location":"Functions/#format_39","text":"xASL_adm_SaveX(x[, Path_xASL, bOverwrite])","title":"Format"},{"location":"Functions/#description_39","text":"This function saves the x.mat either to the predefined path or the the subject x.mat","title":"Description"},{"location":"Functions/#xasl_adm_unziporcopym","text":"","title":"xASL_adm_UnzipOrCopy.m"},{"location":"Functions/#format_40","text":"unpackedFiles = xASL_adm_UnzipOrCopy(srcDir, wildCard, destDir [, bOverwrite])","title":"Format"},{"location":"Functions/#description_40","text":"This is a simple wrapper function to (g)unzip one or more files to the specified destination directory. Existing files or directories will not be overwritten, unless forced with bOverwrite. A regular file-copy will be used if the source files don't have gz or zip filename extensions.","title":"Description"},{"location":"Functions/#xasl_adm_voxel2realworldcoordinatesm","text":"","title":"xASL_adm_Voxel2RealWorldCoordinates.m"},{"location":"Functions/#format_41","text":"[X Y Z] = xASL_adm_Voxel2RealWorldCoordinates(X,Y,Z,VoxelSize)","title":"Format"},{"location":"Functions/#description_41","text":"Converts MNI coordinates from voxel coordinates/indices. Assumes X Y Z = LR LeftRight AP AnteriorPosterior IS InferiorSuperior. VoxelSize should be [1 3]-sized input.","title":"Description"},{"location":"Functions/#xasl_adm_zipfilelistm","text":"","title":"xASL_adm_ZipFileList.m"},{"location":"Functions/#format_42","text":"filepaths = xASL_adm_ZipFileList(strDirectory, strRegExp[, bRecurse, bUseGzip, nRequired]) xASL_adm_ZipFileList(strDirectory, strRegExp[, bRecurse, bUseGzip, nRequired])","title":"Format"},{"location":"Functions/#description_42","text":"Zip the files that match regular expression STRREGEXP in the given directory STRDIRECTORY. Zips recursively if specified in BRECURSE. Zips all files unless the number is specified by NREQUIRED, if the number is not met, then does not zip anything and throws an error.","title":"Description"},{"location":"Functions/#xasl_adm_uigetinputm","text":"","title":"xASL_adm_uiGetInput.m"},{"location":"Functions/#format_43","text":"[Parms] = xASL_adm_uiGetInput(Parms)","title":"Format"},{"location":"Functions/#description_43","text":"Checks whether input fields are present, or requests them.","title":"Description"},{"location":"Functions/#bids","text":"","title":"BIDS"},{"location":"Functions/#xasl_bids_add2participantstsvm","text":"","title":"xASL_bids_Add2ParticipantsTSV.m"},{"location":"Functions/#format_44","text":"xASL_bids_Add2ParticipantsTSV(DataIn, DataName, x, bOverwrite)","title":"Format"},{"location":"Functions/#description_44","text":"This function adds metadata/statistical variables to the participants.tsv in the root/analysis folder, by the following steps. This function will iterate over Data provided at DataIn and fill them in the participants.tsv, overwriting if allowed. Empty data is filled in as 'n/a', and the first column \"participants_id\" is sorted for participants. This function runs the following steps: Admin - Validate that there are not too many columns Admin - Detect nSubjectsSessions Admin - Load pre-existing participants.tsv or create one Admin - Get column number of data Add data to CellArray Sort rows on subjects Fill empty cells Write data to participants.tsv","title":"Description"},{"location":"Functions/#xasl_bids_bids2legacym","text":"","title":"xASL_bids_BIDS2Legacy.m"},{"location":"Functions/#format_45","text":"xASL_bids_BIDS2Legacy(pathStudy[, bOverwrite, dataPar])","title":"Format"},{"location":"Functions/#description_45","text":"This function converts BIDS rawdata (in pathStudy/rawdata/) to xASL legacy derivative format (e.g. pathStudy/derivatives/ExploreASL/) Can be updated step-by-step when ExploreASL's derivative structure moves to BIDS NB: ask how Visits/session layer is defined in bids-matlab (should be separate layer within subjects, but now isn't?) This function performs the following steps: Parse a folder using bids-matlab Define Subject Define SubjectVisit Parse modality Parse scantype Compile paths for copying Manage sidecars to copy Copy files Parse M0 Create DataPar.json","title":"Description"},{"location":"Functions/#xasl_bids_comparestructuresm","text":"","title":"xASL_bids_CompareStructures.m"},{"location":"Functions/#format_46","text":"[identical,results] = xASL_bids_CompareStructures(pathDatasetA,pathDatasetB,[bPrintReport,threshRmseNii]);","title":"Format"},{"location":"Functions/#description_46","text":"Function that compares two BIDS folders with several subfolders and studies and prints the differences. We recommend to set bPrintReport to true, because you otherwise can't see significant file content differences.","title":"Description"},{"location":"Functions/#xasl_bids_configm","text":"","title":"xASL_bids_Config.m"},{"location":"Functions/#format_47","text":"bidsPar = xASL_bids_Config()","title":"Format"},{"location":"Functions/#description_47","text":"Creates several structures necessary for configuring the DICOM to BIDS conversion and saving of BIDS JSON files and NII structure.","title":"Description"},{"location":"Functions/#xasl_bids_createdatasetdescriptiontemplatem","text":"","title":"xASL_bids_CreateDatasetDescriptionTemplate.m"},{"location":"Functions/#format_48","text":"[json] = xASL_bids_CreateDatasetDescriptionTemplate(draft)","title":"Format"},{"location":"Functions/#description_48","text":"This script creates a JSON structure which can be saved using spm_jsonwrite to get a dataset_description.json template. Missing fields that are required are added. BIDSVersion checked against the current configured version. Remaining fields will be validated. Other fields not belonging to dataset_description.json are ignored.","title":"Description"},{"location":"Functions/#xasl_bids_dro2bidsm","text":"","title":"xASL_bids_DRO2BIDS.m"},{"location":"Functions/#format_49","text":"xASL_bids_DRO2BIDS(droTestPatient,[droSubject])","title":"Format"},{"location":"Functions/#description_49","text":"Prepare DRO test patient for BIDS2RAW conversion. This script uses the output of the asldro python script and converts it into a bids structure that can be read by our xASL_bids_BIDS2Legacy script. An exemplary usage is shown in the unit test called xASL_ut_UnitTest_function_BIDS2Legacy.","title":"Description"},{"location":"Functions/#xasl_bids_dicom2jsonm","text":"","title":"xASL_bids_Dicom2JSON.m"},{"location":"Functions/#format_50","text":"[parms pathDcmDictOut] = xASL_bids_Dicom2Parms(imPar, pathIn[, pathJSON, dcmExtFilter, bUseDCMTK, pathDcmDictIn])","title":"Format"},{"location":"Functions/#description_50","text":"The function goes through the pathIn files, reads the DICOM or PAR/REC files and parses their headers. It extracts the DICOM parameters important for ASL, makes sure they are in the correct format, if missing then replaces with default value, it also checks if the parameters are consistent across DICOM files for a single sequence.","title":"Description"},{"location":"Functions/#xasl_bids_getphoenixprotocolm","text":"","title":"xASL_bids_GetPhoenixProtocol.m"},{"location":"Functions/#format_51","text":"[xasl,parameters,parameterList,phoenixProtocol] = xASL_bids_GetPhoenixProtocol(pathData,bUseDCMTK)","title":"Format"},{"location":"Functions/#description_51","text":"Function that reads raw DICOM data (\".dcm\" or \".IMA\") and extracts the phoenix protocol parameters. Only works for Siemens DICOM data with phoenix protocol (tag = [0x29,0x1020]).","title":"Description"},{"location":"Functions/#xasl_bids_jsoncheckm","text":"","title":"xASL_bids_JsonCheck.m"},{"location":"Functions/#format_52","text":"jsonOut = xASL_bids_JsonCheck(jsonIn,fileType)","title":"Format"},{"location":"Functions/#description_52","text":"It checks the existence of all BIDS fields, removes superfluous fields, checks all the conditions and orderes the structure on the output. It works according to the normal BIDS, or ASL-BIDS definition","title":"Description"},{"location":"Functions/#xasl_bids_mergeniftim","text":"","title":"xASL_bids_MergeNifti.m"},{"location":"Functions/#format_53","text":"NiftiPaths = xASL_bids_MergeNifti(NiftiPaths, seqType)","title":"Format"},{"location":"Functions/#description_53","text":"This function takes a list of M0 or ASL4D files and concatenates them together in a longer 4D volume if possible following certain patterns: works only with 3D and 4D files; all files in the list must have the same size of the first three dimensions; files are generarily sorted according to the last number in the filename and outputted to M0.nii or ASL4D.nii; first JSON is taken and renamed, all other JSONs and NIIs are deleted after merging; M0*_parms.m or ASL*_parms.mat is renamed to M0_parms.m or ASL4D_parms.m; M0 files are checked if the field PhaseEncodingAxis is consistent through all the volumes, if not the nothing is merged; this is applied to a generic case and 3 other specific Siemens scenarios are implemented: i) All NII files have two volumes, then simply concatenate according to the last number. ii) Two files with a single volume each are merged according to the last number in the file name. iii) Multiple files with each containing a single volume are sorted to tags ASL4D_x_x_Y and controls ASL4D_Y and merged in the order of the last number in the filename (Y) alternating the tags and controls This function performs the following steps in subfunctions: xASL_bids_MergeNifti_M0Files Generic merging of M0 files xASL_bids_MergeNifti_GEASLFiles Merge GE ASL files and extract scan order from DICOM tags xASL_bids_MergeNifti_SiemensASLFiles Merge Siemens ASL files with specific filename pattern xASL_bids_MergeNifti_AllASLFiles Merge any ASL files xASL_bids_MergeNifti_Merge Merge NiftiPaths & save to pathMerged xASL_bids_MergeNifti_Delete Delete NiftiPaths and associated JSONs xASL_bids_MergeNifti_RenameParms Find *_parms.m files in directory and shorten to provided name","title":"Description"},{"location":"Functions/#xasl_bids_par2jsonm","text":"","title":"xASL_bids_Par2JSON.m"},{"location":"Functions/#format_54","text":"parms = xASL_bids_Par2JSON(pathPar, pathJSON)","title":"Format"},{"location":"Functions/#description_54","text":"Opens the Philips PAR file. Reads the relevant DICOM headers and saves them to JSON sidecar in a BIDS format. The JSON file is created automatically by the dcm2nii readout, so it always looks for this JSON file and add the same time reads the PAR file and adds further parameters to the JSON that were not identified by the dcm2nii tool.","title":"Description"},{"location":"Functions/#xasl_bids_phoenixprotocolanalyzerm","text":"","title":"xASL_bids_PhoenixProtocolAnalyzer.m"},{"location":"Functions/#format_55","text":"[bidsPar,sourcePar] = xASL_bids_PhoenixProtocolAnalyzer(parameterList);","title":"Format"},{"location":"Functions/#description_55","text":"This function analyzes the parameter list of the phoenix protocol (tag = [0x29,0x1020]). This function is usually called from xASL_bids_GetPhoenixProtocol.","title":"Description"},{"location":"Functions/#xasl_bids_phoenixprotocolreaderm","text":"","title":"xASL_bids_PhoenixProtocolReader.m"},{"location":"Functions/#format_56","text":"[parameterList,phoenixProtocol] = xASL_bids_PhoenixProtocolReader(rawPhoenixProtocol)","title":"Format"},{"location":"Functions/#description_56","text":"Function to parse the raw phoenix protocol. This function is usually called from xASL_bids_GetPhoenixProtocol.","title":"Description"},{"location":"Functions/#xasl_bids_vendorfieldcheckm","text":"","title":"xASL_bids_VendorFieldCheck.m"},{"location":"Functions/#format_57","text":"jsonOut = xASL_bids_VendorFieldCheck(jsonIn,bIsASL)","title":"Format"},{"location":"Functions/#description_57","text":"It checks all the JSON fields, make sure that they are renamed from vendor specific names to common BIDS names","title":"Description"},{"location":"Functions/#xasl_bids_parms2bidsm","text":"","title":"xASL_bids_parms2BIDS.m"},{"location":"Functions/#format_58","text":"outBids = xASL_bids_parms2BIDS(inXasl[, inBids, bOutBids, priorityBids])","title":"Format"},{"location":"Functions/#description_58","text":"This functions takes two parameter structures and merges them. At the same time, renames all fields according to the output type (note that only some fields have two standardised names different between the two formats. In case of duplicities, takes the field value from the preferred format. Also takes into account that the units in BIDS are s, but in xASL ms. This function performs the following steps: Define field names that need to be convert/renamed/merged Convert XASL fields to the output format (BIDS or XASL) Convert BIDS fields to the output format (BIDS or XASL) Merge the BIDS and XASL fields, convert field values","title":"Description"},{"location":"Functions/#xasl_bids_parsem0m","text":"","title":"xASL_bids_parseM0.m"},{"location":"Functions/#format_59","text":"xASL_bids_parseM0(pathASLNifti)","title":"Format"},{"location":"Functions/#description_59","text":"Check the .JSON and aslContext.tsv sidecards of an ASL file in BIDS format and find the specified M0 possibilities. Then it converts the ASL file to ExploreASL legacy format including splitting of ASL and M0 NIFTIes if needed. Note that the sidecars are in BIDS, but the file-structure is already expected to be in Legacy format","title":"Description"},{"location":"Functions/#fsl","text":"","title":"FSL"},{"location":"Functions/#xasl_fsl_runfslm","text":"","title":"xASL_fsl_RunFSL.m"},{"location":"Functions/#format_60","text":"[x] = xASL_adm_RunFSL(FSLCommand, x[, OutputZipping])","title":"Format"},{"location":"Functions/#description_60","text":"This function runs an FSL command from ExploreASL: Checking the FSL dir Manage CUDA/CPU parallelization (currently disabled, WIP) Setting up FSL environment Running the command Supports .nii & .nii.gz, Linux, MacOS & Windows (WSL)","title":"Description"},{"location":"Functions/#xasl_fsl_setfsldirm","text":"","title":"xASL_fsl_SetFSLdir.m"},{"location":"Functions/#format_61","text":"[FSLdir[, x, RootWSLdir]] = xASL_adm_SetFSLdir(x, bUseLatestVersion)","title":"Format"},{"location":"Functions/#description_61","text":"This function finds the FSLdir & puts it out, also in x.FSLdir to allow repeating this function without having to repeat searching. If the FSLdir & RootFSLDir are already defined in x.FSLdir & x.RootFSLDir, this function is skipped. Supports Linux, MacOS & Windows (WSL), & several different default installation folders for different Linux distributions","title":"Description"},{"location":"Functions/#xasl_fsl_topupm","text":"","title":"xASL_fsl_TopUp.m"},{"location":"Functions/#format_62","text":"xASL_fsl_TopUp(InDir[, ScanType], x)","title":"Format"},{"location":"Functions/#description_62","text":"This function runs FSL TopUp. It assumes that there are 2 TopUp images, i.e. 1 blip up & 1 blip down. Admin: manage ScanType, NIfTI paths, create TopUp parameter file for image to apply TopUp to & for the TopUp NIfTIs, delete files from previous run, define the image with the same acquisition parameters as TopUp (does the image we apply TopUp to, have the Blip up or down?) Register images to image that we apply TopUp to (registration between blip up/down images is performed by TopUp) Run TopUp estimate (i.e. estimate the geometric distortion field from B0 NIfTI & parameters file), this takes quite long. Also has a x.Quality=0 option that is very fast but inaccurate, to try out this pipeline part. Before TopUp, NaNs (e.g. from resampling) are removed from the images TopUp is run with default settings Apply TopUp","title":"Description"},{"location":"Functions/#imaging","text":"","title":"Imaging"},{"location":"Functions/#xasl_im_bilateralfilterm","text":"","title":"xASL_im_BilateralFilter.m"},{"location":"Functions/#format_63","text":"[ovol] = xASL_im_BilateralFilter(volIM, mask, VoxelSize, x)","title":"Format"},{"location":"Functions/#description_63","text":"This function runs a spatial lowpass temporally highpass filter, and removes outliers within this signal, and adapts the time-series accordingly.","title":"Description"},{"location":"Functions/#xasl_im_centerofmassm","text":"","title":"xASL_im_CenterOfMass.m"},{"location":"Functions/#format_64","text":"xASL_im_CenterOfMass(PathNIfTI, OtherList, AllowedDistance)","title":"Format"},{"location":"Functions/#description_64","text":"This function estimates the center of mass of the image matrix, and if this is too far off the current orientation matrix center, the center will be reset. This fixes any incorrect orientation outputted by the scanner. The realignment is only applied when any of the X/Y/Z dimensions have a higher offset than AllowedDistance.","title":"Description"},{"location":"Functions/#xasl_im_cleanupwmhnoisem","text":"","title":"xASL_im_CleanupWMHnoise.m"},{"location":"Functions/#format_65","text":"xASL_im_CleanupWMHnoise(InputPath, OutputPath, MinLesionVolume, pThresh)","title":"Format"},{"location":"Functions/#description_65","text":"Threshold white matter lesions, acknowledging the fact that they may be confluent with subresolution connection through a dilation. This part is executed conservatively, as FLAIR hyperintensities inside the GM can be erroneously segmented as WMH, and should not be lesion-filled (otherwise these cannot be fixed later in the Structural module). Note that LST lesion filling expects a probability map, doesnt work nicely with binary mask","title":"Description"},{"location":"Functions/#xasl_im_clipextremesm","text":"","title":"xASL_im_ClipExtremes.m"},{"location":"Functions/#format_66","text":"[NewIM] = xASL_im_ClipExtremes(InputIm[, ThreshHigh, ThreshLow, bVerbose, bNormalize])","title":"Format"},{"location":"Functions/#description_66","text":"This function clips an image to a given percentile. The percentile is found using non-zeros sorted intensities, so both isfinite & non-zeros. This function performs the following steps: Constrain clippable intensities Clip high intensities Clip low intensities Normalize to 4096 (12 bit, 12^2) Save as NIfTI if the input was a NIfTI","title":"Description"},{"location":"Functions/#xasl_im_column2imm","text":"","title":"xASL_im_Column2IM.m"},{"location":"Functions/#format_67","text":"[ImageOut] = xASL_im_Column2IM(ColumnIn, BrainMask)","title":"Format"},{"location":"Functions/#description_67","text":"This function \"decompresses\" an image matrix (or multiple matrices) from a single-dimensional column, by reconstructing the image matrix from the voxel positions within the BrainMask. NB: Important to use the same BrainMask as used for converting the image matrix to the column! See also: xASL_im_IM2Column.m The mask mostly used for xASL_im_IM2Column is x.WBmask, which completely engulfes pGM, pWM & pCSF.","title":"Description"},{"location":"Functions/#xasl_im_compareniftiresolutionxyzm","text":"","title":"xASL_im_CompareNIfTIResolutionXYZ.m"},{"location":"Functions/#format_68","text":"[IsEqualResolution] = xASL_im_CompareNIfTIResolutionXYZ(PathNIfTI1, PathNIfTI2)","title":"Format"},{"location":"Functions/#description_68","text":"This function checks whether the X, Y and Z resolution of a NIfTI with any number of dimensions is equal. It rounds for 2 floating points, for both NIfTIs, to ensure that the same precision is compared.","title":"Description"},{"location":"Functions/#xasl_im_computedicem","text":"","title":"xASL_im_ComputeDice.m"},{"location":"Functions/#format_69","text":"[DiceCoeff] = xASL_im_ComputeDice(imA, imB)","title":"Format"},{"location":"Functions/#description_69","text":"This function calculates the Dice coefficient of image overlap.","title":"Description"},{"location":"Functions/#xasl_im_createasldeformationfieldm","text":"","title":"xASL_im_CreateASLDeformationField.m"},{"location":"Functions/#format_70","text":"xASL_im_CreateASLDeformationField(x, bOverwrite, EstimatedResolution)","title":"Format"},{"location":"Functions/#description_70","text":"This function smooths a transformation flow field to a lower resolution. Usually, we use a high resolution anatomical image (e.g. 3D T1w ) to obtain the flowfields from native space to standard space, and apply these to the lower resolution ASL images. Because of the resolution differences, the flowfields need to be downsampled/smoothed, to avoid deformation effects that are crispier than the functional image that is investigated. This function performs the following steps: Obtain resolutions Fill NaNs at edges y_T1.nii flowfield to prevent interpolation artifact Smooth flowfield Fill NaNs at edges y_ASL.nii Note that if the resolution of ASL is not significantly (i.e. >0.5 mm in any dimension) lower than T1w, the y_T1.nii is copied to y_ASL.nii","title":"Description"},{"location":"Functions/#xasl_im_createpseudocbfm","text":"","title":"xASL_im_CreatePseudoCBF.m"},{"location":"Functions/#format_71","text":"xASL_im_CreatePseudoCBF(x, spatialCoV[, bPVC])","title":"Format"},{"location":"Functions/#description_71","text":"This function creates a pseudo-CBF image from mean CBF template, arterial transit time (ATT) bias field & vascular artifacts, weighted through spatial CoV The first part of this code puts templates in the native space and creates a pseudoCBF image from a downsampled pGM & pWM tissue (PseudoTissue). The latter is used for registration but also as reference for the template registration, to speed this up. The second part of this code computes a pseudoCBF image based on the pseudoTissue & the CBF templates of CBF, ATT biasfield and vascular peaks, based on spatial CoV. This submodule performs the following steps: Create the pseudoTissue CBF reference image, if it doesnt exist already Create the native space copies of ASL templates, if they dont exist already Spatial CoV input argument check Load native space copies of templates Create pseudoTissue from segmentations, mix this with the mean CBF template depending on spatial CoV Create pseudoCBF reference image used for CBF-based registration Scale mean_PWI_Clipped source image to the same range as PseudoCBF","title":"Description"},{"location":"Functions/#xasl_im_createslicegradientm","text":"","title":"xASL_im_CreateSliceGradient.m"},{"location":"Functions/#format_72","text":"xASL_im_CreateSliceGradient(x)","title":"Format"},{"location":"Functions/#description_72","text":"Create slice gradient in same space as input file Reslice slice gradient to MNI (using existing ASL matrix changes from e.g. registration to MNI, motion correction, registration to GM) Creating average slice gradient","title":"Description"},{"location":"Functions/#xasl_im_decomposeaffinetransformationm","text":"","title":"xASL_im_DecomposeAffineTransformation.m"},{"location":"Functions/#format_73","text":"[M, P] = xASL_im_DecomposeAffineTransformation(Mtransformation)","title":"Format"},{"location":"Functions/#description_73","text":"This function splits a transformation matrix into individual components, which can be useful to guide the SPM reslicing. The components are the same as in spm_(i)matrix.m, except for the shearing: these are included in the rotations, and the 90 degree rotations, these are separated. Reason for the separation of the 90 degree rotations, is that these indicate if orientations (transversal, coronal & sagittal) have been switched in the NIfTI. This can be useful to correct for any erroneous 90degree rotations from registration, or to put two images in the same orientation order or voxelsize without applying their subtle realignment (e.g. for manipulating registration references) THEORY 90 degree rotations: Any rotation will always swap the other dims (X rotation swaps Y/Z, Y rotation swaps X/Z etc.) because they are perpendicular (haaks) Dims X Y Z care for LR, AP and IS translation. - X-rotation will rotate the transverse slice (LR <-> AP) swapping Y (coronal) & Z (saggital) - Y-rotation will rotate the coronal slice (IS <-> LR) slice, swapping X (transversal) and Z (sagittal) - Z-rotation will rotate the sagittal slice (AP <-> IS) swapping X (transversal) and Y (sagittal) E.g., MPRAGE is acquired in sagittal slices, and ASL/fMRI/BOLD in transversal slices. This is an Y rotation (you look into the coronal plane, rotate this, which will swap the sagittal slices into transversal) This function performs the following steps: Start with an output P and M struct Obtain translations Obtain zoom Obtain 90degree rotations Obtain subtle rotations & shearing Check the rounding errors of the decomposition","title":"Description"},{"location":"Functions/#xasl_im_determineflipm","text":"","title":"xASL_im_DetermineFlip.m"},{"location":"Functions/#format_74","text":"[QCstruct] = xASL_im_DetermineFlip(x,iS,PathOrientationResults,QCstruct)","title":"Format"},{"location":"Functions/#description_74","text":"Check determinants, should be the same before & after registration, otherwise a left-right flip is applied This is not visible, but detrimental for image analysis/stats.","title":"Description"},{"location":"Functions/#xasl_im_dilateerodefullm","text":"","title":"xASL_im_DilateErodeFull.m"},{"location":"Functions/#format_75","text":"imOut = xASL_im_DilateErodeFull(imIn, type, kernel)","title":"Format"},{"location":"Functions/#description_75","text":"Runs dilation or erosion on a binary imIn in full three dimensions. It uses its own dilate_erode function and crops the image so that it contains only the mask. The size of all three dimensions of the kernel needs to be an odd number.","title":"Description"},{"location":"Functions/#xasl_im_dilateerodeseparablem","text":"","title":"xASL_im_DilateErodeSeparable.m"},{"location":"Functions/#format_76","text":"imOut = xASL_im_DilateErodeSeparable(imIn, type, kernel_x, kernel_y, kernel_z)","title":"Format"},{"location":"Functions/#description_76","text":"Runs dilation or erosion on a binary imIn separably in three dimensions. Dilation/erosion in each dimension is done by using the specified kernels. It uses its own dilate_erode function and crops the image so that it contains only the mask. Works only with odd sized kernels","title":"Description"},{"location":"Functions/#xasl_im_dilateerodespherem","text":"","title":"xASL_im_DilateErodeSphere.m"},{"location":"Functions/#format_77","text":"el = xASL_im_DilateErodeSphere(R)","title":"Format"},{"location":"Functions/#description_77","text":"Creates a 3D structuring element (binary) sphere with the given diameter (R) and size 2*R+1","title":"Description"},{"location":"Functions/#xasl_im_dummyorientationniftim","text":"","title":"xASL_im_DummyOrientationNIfTI.m"},{"location":"Functions/#format_78","text":"xASL_im_DummyOrientationNIfTI(PathSrc, PathRef, PathDummyOut[, bApplyRotationMinor, bApplyRotation90, bApplyZoom, bApplyTranslation])","title":"Format"},{"location":"Functions/#description_78","text":"This function creates a dummy image as reference for xASL_spm_reslice, allowing to only apply specific parts of the transformation between the two images. E.g. only the rotation, or only the zooming. This can be useful to correct for any erroneous rotations from registration, or to put two images in the same space without applying their realignment. This function performs the following steps: Load orientations & calculate transformation Calculate the desired transformation Calculate new orientation matrix Calculate the new image size Save the dummy NIfTI","title":"Description"},{"location":"Functions/#xasl_im_estimateresolutionm","text":"","title":"xASL_im_EstimateResolution.m"},{"location":"Functions/#format_79","text":"[resFWHM, resSigma, resErr, imSmo, imMask] = xASL_im_EstimateResolution(imCBF, imGM, imWM[, imMaskOrig, PSFtype, maxIter])","title":"Format"},{"location":"Functions/#description_79","text":"Creates a high-resolution pseudo-CBF image based on segmented GM and WM maps and iteratively adjusts its resolution by smoothing until reaching a perfect fit with the CBF image thus obtaining the resolution difference between the GM and CBF image and uses this to calculate the estimated effective resolution of hte CBF. Note that all the calculations are done using voxels as measures and not mm, so the output resolution is also in voxels and has to be transfered to mm by using the knowledge about the voxel size. It is assumed that for imGM and imWM, the voxel size equals the resolution, and the imCBF is upsampled to the smaller voxels of imGM.","title":"Description"},{"location":"Functions/#xasl_im_flipm","text":"","title":"xASL_im_Flip.m"},{"location":"Functions/#format_80","text":"[MatrixOut] = xASL_im_Flip(MatrixIn, varargin)","title":"Format"},{"location":"Functions/#description_80","text":"Backwards compatibility for flipping left-right in standard space (NB: this can be different than in native space!).","title":"Description"},{"location":"Functions/#xasl_im_im2columnm","text":"","title":"xASL_im_IM2Column.m"},{"location":"Functions/#format_81","text":"[ColumnOut] = xASL_im_IM2Column(ImageIn, BrainMask[, ApplyShiftDim])","title":"Format"},{"location":"Functions/#description_81","text":"This function \"compresses\" an image matrix (or multiple matrices) for optimization of memory and CPU resources. The output column only includes voxels that lie within the BrainMask. This excludes extracranial zero-information voxels from computations and memory use. NB: Important to use the same BrainMask for converting the column back to an image matrix! See also: xASL_im_Column2IM.m The mask mostly used for xASL_im_IM2Column is x.WBmask, which completely engulfes pGM, pWM & pCSF","title":"Description"},{"location":"Functions/#xasl_im_jointhistm","text":"","title":"xASL_im_JointHist.m"},{"location":"Functions/#format_82","text":"imHist = xASL_im_JointHist(imA,imB[,imMask,minA,maxA,minB,maxB,nBins])","title":"Format"},{"location":"Functions/#description_82","text":"It calculates a joint histogram of two images of any dimensions over a mask of the same size. The boundaries and number of bins can either be given or min and max values are used. Values outside of the bins are counted to the first/last bin.","title":"Description"},{"location":"Functions/#xasl_im_lesion2catm","text":"","title":"xASL_im_Lesion2CAT.m"},{"location":"Functions/#format_83","text":"LesionPathOut = xASL_im_Lesion2CAT(PathIn)","title":"Format"},{"location":"Functions/#description_83","text":"For all lesion masks in the anatomical directory, load them, merge them and save them for the CAT segmentation. If there are no lesions found, the images are untouched.","title":"Description"},{"location":"Functions/#xasl_im_lesion2maskm","text":"","title":"xASL_im_Lesion2Mask.m"},{"location":"Functions/#format_84","text":"LesionIM = xASL_im_Lesion2Mask(LesionPath, x)","title":"Format"},{"location":"Functions/#description_84","text":"This function takes a mask and adds several ROIs, to be used as custom \"atlas\", e.g. when computing region-average CBF values. The mask % can be an ROI or lesion, if we assume it is a lesion, the following masks are created: Intralesional Perilesional (15 mm rim around the lesion) Hemisphere (ipsilateral to lesion) Contralateral version of 1 Contralateral version of 2 Contralateral version of 3 All these masks are masked by a brainmask (pGM+pWM)>0.5 This function performs the following steps: If lesion is empty, skip this & delete the file BrainMasking Create hemispheres Save mutually exclusive masks Create tsv-sidecar containing the names of the ROIs Visual QC","title":"Description"},{"location":"Functions/#xasl_im_m0erodesmoothextrapolatem","text":"","title":"xASL_im_M0ErodeSmoothExtrapolate.m"},{"location":"Functions/#format_85","text":"[ImOut] = xASL_im_M0ErodeSmoothExtrapolate(ImIn, x)","title":"Format"},{"location":"Functions/#description_85","text":"This function erodes, smooths & extrapolates M0 in standard space. It assumes that the M0 image is in standard space & that the GM & WM probability maps are aligned. Here, we mask the M0, to remove high CSF signal and low extracranial signal, enabling us to smooth the image without inserting wrong signal. See also the ExploreASL manuscript for a more extensive explanation. This function performs the following steps: Mask: Load segmentations, create structural mask Mask: Create intensity-based mask to remove extracranial signal Mask: Erode the combined masks Mask: Determine any odd borders Smoothing Extrapolating only Scale back to the GM M0 Print visual QC figure A visual QC figure is created, showing the M0 image processing steps for a single transversal slice (slice 53 in 1.5 mm MNI standard space) OutputFile = fullfile(x.D.M0regASLdir,['M0_im_proc_' x.P.SubjectID '.jpg']); The original M0 image (a) is masked with a (pGM+pWM)>50% mask (b) eroded with a two-voxel sphere to limit the influence of the ventricular and extracranial signal (c) and thresholded to exclude significantly high (i.e. median + 3*mean absolute deviation (MAD)) border region values (d) This masked M0 image is smoothed with a 16x16x16 mm full- width-half-maximum Gaussian filter (Mutsaerts et al., 2018) (e) after which the signal at the border is smoothly extrapolated until the full image is filled (f). Whereas the masking avoids mixing with cerebrospinal fluid or extracranial signal, the extrapolation avoids M0 division artifacts","title":"Description"},{"location":"Functions/#xasl_im_masknegativevascularsignalm","text":"","title":"xASL_im_MaskNegativeVascularSignal.m"},{"location":"Functions/#format_86","text":"[NegativeMask, TreatedPWI] = xASL_quant_DetectNegativeVascularSignal(x)","title":"Format"},{"location":"Functions/#description_86","text":"This function segments clusters with significant negative ASL signal. This can be tricky as there is also the negative tail of Gaussian noise from the ASL subtraction. The image feature we use here, is that negative vascular signal will be a relatively large region with significant median negative value, whereas noise will be regions with relatively small negative signal. Negative signal from wrong background suppression timing (e.g. in the first slice with 2D EPI) can be masked out with this as well. The procedure works as follows: Obtain mask of negative voxels within pGM>0.5 mask Obtain distribution of subzero clusters Define the negative threshold Create mask by thresholding whole image Note that the definition of the threshold is obtained within the GM only, but that this threshold is applied to the full image. Note that instead of the PWI path input, a CBF image should work equally well, as we don't expect a smooth M0 biasfield to change the distribution of negative clusters","title":"Description"},{"location":"Functions/#xasl_im_maskpeakvascularsignalm","text":"","title":"xASL_im_MaskPeakVascularSignal.m"},{"location":"Functions/#format_87","text":"[MaskIM, CBF] = xASL_quant_VascularContrast(PathPWI, Path_M0, CompressionRate, ClipThresholdValue, bClip)","title":"Format"},{"location":"Functions/#description_87","text":"This function searches for an acceptable high threshold as definition of high intra-vascular ASL signal. It also allows to compress the values here (when bClip==true). Compression retains some variability, but limits their outlying influence on statistics. The procedure works as follows: Segment GM on ASL image at 80th percentile of CBF image distribution For PWI & CBF images, select voxels higher than median + ClipThresholdValue MAD Vascular artifacts will have a high intensity in both images, whereas errors by division by M0 will only have a high intensity on the M0 image, and high values due to a biasfield will only be noticeable on the PWI image Combine the two created masks Obtain average clipping value from selected voxels from the combined masks Apply compression if requested. If not, output image will have NaNs for intra-vascular voxels. Note that the definition of the threshold is obtained within the GM only, but that this threshold is applied to the full image to also remove extracranial extreme values. Note that the performance may change when using this script with or without M0, as this will change the distribution that determines where the threshold for extremes lies.","title":"Description"},{"location":"Functions/#xasl_im_modulationm","text":"","title":"xASL_im_Modulation.m"},{"location":"Functions/#format_88","text":"xASL_im_Modulation(x)","title":"Format"},{"location":"Functions/#description_88","text":"Combines the transformations to create Jacobians, & multiplies the standard space segmentations with these to create volumetric images for volumetric analyses.","title":"Description"},{"location":"Functions/#xasl_im_normalizelabelingterritoriesm","text":"","title":"xASL_im_NormalizeLabelingTerritories.m"},{"location":"Functions/#format_89","text":"image_out = xASL_im_NormalizeLabelingTerritories( imageIN, GMmask, x)","title":"Format"},{"location":"Functions/#description_89","text":"Normalizes per perfusion territory mask should be GM mask.","title":"Description"},{"location":"Functions/#xasl_im_pcam","text":"","title":"xASL_im_PCA.m"},{"location":"Functions/#format_90","text":"[pc, score, eigenvalues, tsquare, loadings, Xmean] = xASL_im_PCA(dataIn)","title":"Format"},{"location":"Functions/#description_90","text":"Perform a Principal Component Analysis.","title":"Description"},{"location":"Functions/#xasl_im_pvcbsplinem","text":"","title":"xASL_im_PVCbspline.m"},{"location":"Functions/#format_91","text":"[imPVEC,imCBFrec,imResidual,FWHM] = xASL_im_PVCbspline(imCBF,imPV[,bsplineNum])","title":"Format"},{"location":"Functions/#description_91","text":"PVC of ASL data using prior GM-,WM-partial volume maps. Follows the principles of the PVEc algorithm by I. Asllani (MRM, 2008). The PV-corrected CBF_GM and CBF_WM maps are approximated using an uniformly sampled cubic B-splines. REFERENCES: -Asllani I, Borogovac A, Brown TR. Regression algorithm correcting for partial volume effects in arterial spin labeling MRI. Magnetic Resonance in Medicine. 2008 Dec 1;60(6):1362-71. -Petr J, Mutsaerts HJ, De Vita E, Steketee RM, Smits M, Nederveen AJ, Hofheinz F, van den Hoff J, Asllani I. Effects of systematic partial volume errors on the estimation of gray matter cerebral blood flow with arterial spin labeling MRI. MAGMA 2018. DOI:10.1007/s10334-018-0691-y","title":"Description"},{"location":"Functions/#xasl_im_pvckernelm","text":"","title":"xASL_im_PVCkernel.m"},{"location":"Functions/#format_92","text":"[imPVC,imCBFrec,imResidual] = xASL_im_PVCkernel(imCBF, imPV [,kernel,mode])","title":"Format"},{"location":"Functions/#description_92","text":"Partial volume correction (PVC) of ASL data using prior GM-,WM-partial volume maps. Follows the principles of the PVC algorithm by I. Asllani (MRM, 2008).","title":"Description"},{"location":"Functions/#xasl_im_presmoothm","text":"","title":"xASL_im_PreSmooth.m"},{"location":"Functions/#format_93","text":"pathOut = xASL_im_PreSmooth(pathRef,pathSrc[,pathSmo,resRef,resSrc,srcAffinePath, bInvAffine])","title":"Format"},{"location":"Functions/#description_93","text":"It assumes that the FWHM is equal to voxel size, unless the real resolution is given. Then takes into account the voxel sizes and orientation difference between the volumes, but performs the smoothing according to the given real resolution (it is possible to supply the resolution for just one image) - this should be helpful primarily when the It creates a Gaussian covariance matrix for the reference, transforms it according to the difference between the two images a produces the Gaussian covariance matrix of the pre-smoothing in the source space. Then it performs the smoothing. The following steps are performed: Obtain the voxel size Skip this function if reference resolution is equal to, or lower than source resolution Deal with affine transformation Obtain the transformation matrix from the Reference to the Source space Apply the smoothing filter on the source image(s) Save the smoothed image","title":"Description"},{"location":"Functions/#xasl_im_processm0conventionalm","text":"","title":"xASL_im_ProcessM0Conventional.m"},{"location":"Functions/#format_94","text":"[Corr_M0] = xASL_im_ProcessM0Conventional(ImIn, x)","title":"Format"},{"location":"Functions/#description_94","text":"This function uses the conventional M0 masking, and only a little smoothing, following what Philips uses for its 3D {{GRASE}}. Advantages of the newer M0 processing in ExploreASL are the lack of use of M0 threshold-based masking, the removal of high CSF values and higher SNR for ASL division.","title":"Description"},{"location":"Functions/#xasl_im_projectlabelsoverdatam","text":"","title":"xASL_im_ProjectLabelsOverData.m"},{"location":"Functions/#format_95","text":"OutputIM = xASL_im_ProjectLabelsOverData(DataIM,LabelIM,x,ScaleFactorData,ScaleFactorLabel)","title":"Format"},{"location":"Functions/#description_95","text":"This script projects labels over an image, but works only in 2D. Make sure to make a 2D image from a 3D or 4D image using xASL_vis_TransformData2View.m can be used in combination with xASL_vis_Imwrite.m","title":"Description"},{"location":"Functions/#xasl_im_resamplelinearfairm","text":"","title":"xASL_im_ResampleLinearFair.m"},{"location":"Functions/#format_96","text":"[output_res]=xASL_im_ResampleLinearFair(im_input,newsize)","title":"Format"},{"location":"Functions/#description_96","text":"Downsample (or upsample, works similarly) old_res image to low_res image, trilinear. We recommend using \"xASL_spm_Resample\" instead, because of better performance. NB: new_res should fit exactly integer fold in old_res NB: all dimensions of new_res should have equal size","title":"Description"},{"location":"Functions/#xasl_im_restoreorientationm","text":"","title":"xASL_im_RestoreOrientation.m"},{"location":"Functions/#format_97","text":"xASL_im_RestoreOrientation(PathNIfTI)","title":"Format"},{"location":"Functions/#description_97","text":"This function reverts the NIfTI header orientation matrix to the original orientation from the scanner/dcm2nii conversion.","title":"Description"},{"location":"Functions/#xasl_im_skullstripm","text":"","title":"xASL_im_SkullStrip.m"},{"location":"Functions/#format_98","text":"xASL_im_SkullStrip(InPath, PathMNIMask, x, OutPath)","title":"Format"},{"location":"Functions/#description_98","text":"Creates skull-stripped T1w image based on MNI -> native space registration from segmentation.","title":"Description"},{"location":"Functions/#xasl_im_smooth3dm","text":"","title":"xASL_im_Smooth3D.m"},{"location":"Functions/#format_99","text":"[imSmo, imGaussX, imGaussY, imGaussZ] = xASL_im_Smooth3D(imIn, sigma[, PSFtype])","title":"Format"},{"location":"Functions/#description_99","text":"It smooths the 3D image with a 3D kernels that has defined the shape and SD of the smoothing separably in three dimension.","title":"Description"},{"location":"Functions/#xasl_im_splitimagelabelsm","text":"","title":"xASL_im_SplitImageLabels.m"},{"location":"Functions/#format_100","text":"xASL_im_SplitImageLabels(ImagePaths, LabelTable[, OutputFolder, bOverwrite, ResampleDir, SubRegExp])","title":"Format"},{"location":"Functions/#description_100","text":"This function allows extracting of labels from a NIfTI file containing multiple labels, into single NIfTI files each containing a single label. Not all existing labels need to be extracted. The following steps are performed: Load TSV file Process images","title":"Description"},{"location":"Functions/#xasl_im_upsamplem","text":"","title":"xASL_im_Upsample.m"},{"location":"Functions/#format_101","text":"xASL_im_Upsample(PathOrig, PathDest, NewVoxelSize, LeaveEmpty, PaddingDim, Kernel)","title":"Format"},{"location":"Functions/#description_101","text":"Upsamples an ASL image, without changing the orientation matrix, which can be used e.g. for PVEc in higher resolution but same space.","title":"Description"},{"location":"Functions/#xasl_im_zeroedgesm","text":"","title":"xASL_im_ZeroEdges.m"},{"location":"Functions/#format_102","text":"[IM] = xASL_im_ZeroEdges(IM[, EdgeThicknessPerc])","title":"Format"},{"location":"Functions/#description_102","text":"Resampling can sometimes give some strange errors near image edges. These should be NaNs, but sometimes can be zeros or ones, or even weird numbers. For resampling, NaNs should be set to 0 (this is done in another function) as they can influence the resampling (depending on the transformation matrix). To be sure that the edges are nicely fixed, this function sets a border at the image matrix edges to zero.","title":"Description"},{"location":"Functions/#xasl_im_dilateroim","text":"","title":"xASL_im_dilateROI.m"},{"location":"Functions/#format_103","text":"xASL_im_dilateROI(PathIn, [PathOut, minVolume])","title":"Format"},{"location":"Functions/#description_103","text":"The function loads a binary image from PathIn and if smaller than the defined volume (40 mL by default) it dilates it with a 3x3 sphere element until a minimal volume is reached. When it is small enough, it is saved to PathOut. 40 mm^3 is equal to 3 voxels in all directions in DARTEL space, or around the highest obtainable ASL effective resolution (3x3x4 mm).","title":"Description"},{"location":"Functions/#xasl_im_rotatem","text":"","title":"xASL_im_rotate.m"},{"location":"Functions/#format_104","text":"rotated = xASL_im_rotate(im, angle)","title":"Format"},{"location":"Functions/#description_104","text":"Simple rotation of the first two dimension of a ND image by 0, 90, 180, 270 degrees.","title":"Description"},{"location":"Functions/#initialization","text":"","title":"Initialization"},{"location":"Functions/#xasl_init_defaulteffectiveresolutionm","text":"","title":"xASL_init_DefaultEffectiveResolution.m"},{"location":"Functions/#format_105","text":"[EffectiveResolution] = xASL_init_DefaultEffectiveResolution(PathASL, x)","title":"Format"},{"location":"Functions/#description_105","text":"This ExploreASL module provides an educated guess on the effective spatial resolution of ASL. This may depend on the combination of acquisition PSF, reconstruction filter, head motion. Note that the derived/processed images may have a lower effective resolution because of smoothing effects from interpolation. Note that this remains an educated-guess, the actual FWHM may still differ, especially for 3D GRASE sequences, where e.g. the choice of number of segments can affect the smoothness. This function conducts the following steps: Educated-guess FWHM Attempt accounting for in-plane interpolation in reconstruction Calculate and report effective spatial resolution","title":"Description"},{"location":"Functions/#xasl_init_definestudydatam","text":"","title":"xASL_init_DefineStudyData.m"},{"location":"Functions/#format_106","text":"[x] = xASL_init_DefineStudyData(x)","title":"Format"},{"location":"Functions/#description_106","text":"This initialization wrapper initializes the parameters for this pipeline run, i.e. subjects, sessions (runs), timepoints (visits), exclusions, sites, cohorts etc. Note that ASL sessions are defined here as what BIDS calls \"runs\". The \"longitudinal_Registration functions here manage different TimePoints, which is what BIDS calls \"visits\". With different structural scans, from the same participant. This is managed by subject name suffixes _1 _2 _n, and can be used for comparing visits in the population module, or running SPM's longitudinal within-subject registration. Parallelization is allowed here by calling ExploreASL different times, where it divides the subjects/images for processing across the nWorkers, using iWorker as the reference for the part that the current ExploreASL call will process. This requires having a Matlab license that can be started multiple times on a server, or alternatively running the ExploreASL compilation, and doesn't require the Matlab parallel toolbox. This function exists from the following parts: Manage included & excluded subjects Create dummy defaults (exclusion list, ASL sessions) Create list of total baseline & follow-up subjects, before exclusions Create TimePoint data-lists Manage exclusions Add sessions as statistical variable, if they exist Parallelization: If running parallel, select cases for this worker Add Longitudinal TimePoints (different T1 volumes) as covariate/set, after excluding Load & add statistical variables Make x.S.SetsOptions horizontal if vertical by transposing Create single site dummy, if there were no sites specified Check for time points sets Create list of baseline & follow-up subjects (i.e. after exclusion) Check what excluded from which TimePoints","title":"Description"},{"location":"Functions/#xasl_init_filesystemm","text":"","title":"xASL_init_FileSystem.m"},{"location":"Functions/#format_107","text":"[x] = xASL_init_FileSystem(x)","title":"Format"},{"location":"Functions/#description_107","text":"This function initializes the file system used throughout ExploreASL, for processing a single dataset/scan. It is repeated for each scan, and runs the following parts: Create folders Subject/session definitions Add prefixes & suffixes Add Subject-specific prefixes Add sidecars Add atlas paths","title":"Description"},{"location":"Functions/#xasl_init_initializemutexm","text":"","title":"xASL_init_InitializeMutex.m"},{"location":"Functions/#format_108","text":"[x] = xASL_init_InitializeMutex(x, ModuleName)","title":"Format"},{"location":"Functions/#description_108","text":"This function initializes the mutex/lock system of ExploreASL for a module. Mutex (for mutual exclusion) is a synchronization mechanism for enforcing limits of access to data (here a module for a single scan) to allow parallelization. It also allows stopping and continuing of ExploreASL. This function runs the following steps: Lock folder management Initialize mutex object","title":"Description"},{"location":"Functions/#xasl_init_loadmetadatam","text":"","title":"xASL_init_LoadMetadata.m"},{"location":"Functions/#format_109","text":"[x] = xASL_init_LoadMetadata(x)","title":"Format"},{"location":"Functions/#description_109","text":"This function loads all metadata used in the study, either statistical covariates (age, MMSE) or groups to compare between (site, sequence, cohort), or parameters to be used in quantification/image processing These parameters should be provided in .mat files in the root analysis folder. Each .mat file should contain a single type of metadata, and the filename should equal the variable name. Metadata content should be a cell array with subjects as first column and metadata as last column. Sessions (runs) can be included as second column. Metadata can be in any string or numerical format. participants.tsv is now added per BIDS. It looks for metadata in participants.tsv first, before going through the mat-files This function iterates through the following steps for each variable: Admin (what nOptions do we call ordinal, convert subject numeric to string, remove white spaces from data) Get unique list of data options & check for missing data Deal with data format (correct NaNs, deal with numeric vs strings) Distinguish continous data (e.g. age) or ordinal data (groups to compare, e.g. cohort) Check if data is complete for all subjects Include complete data in x.S.SETS","title":"Description"},{"location":"Functions/#xasl_init_longitudinalregistrationm","text":"","title":"xASL_init_LongitudinalRegistration.m"},{"location":"Functions/#format_110","text":"[SubjectNlist, TimePoint, IsSubject, SubjectID_FirstVolume] = xASL_init_LongitudinalRegistration(x)","title":"Format"},{"location":"Functions/#description_110","text":"This function initializes the longitudinal registration for ExploreASL, which implements the SPM longitudinal registration. This function recognizes and defines visits (i.e. multiple scans per subject) in the initialization of ExploreASL, based on the suffixes _1 _2 _n in the subject names (identified as foldernames). Specifically, this function is called in the registration modules LongReg and DARTEL, the first carrying out within-subject registration and the second between-subject registration, based on the first time point only. For the first function, we specify here a list of visits/timepoints that should be registered longitudinally, for the second function we specify a list of first visits only, as the between-subject registration in ExploreASL is based on the first scan (as opposed to the average subject's scan). This function runs the following steps: Get TimePoint-list (list of visits) Find subject IDs","title":"Description"},{"location":"Functions/#xasl_init_visualizationsettingsm","text":"","title":"xASL_init_VisualizationSettings.m"},{"location":"Functions/#format_111","text":"[x] = xASL_init_VisualizationSettings(x)","title":"Format"},{"location":"Functions/#description_111","text":"This function defines several visualization settings are used throughout ExploreASL's pipeline and tools, assuming a [121 145 121] matrix with 1.5 mm isotropic resolution in MNI space.","title":"Description"},{"location":"Functions/#input-and-output","text":"","title":"Input and Output"},{"location":"Functions/#xasl_io_createniftim","text":"","title":"xASL_io_CreateNifti.m"},{"location":"Functions/#format_112","text":"xASL_io_CreateNifti(pathNewNifti, imNew, resMat, nBits, bGZip)","title":"Format"},{"location":"Functions/#description_112","text":"This function creates a new NIfTI file, using the SPM \"nifti\" functionality, with the parameters specified as input arguments. This function performs the following steps: Initialize NIfTI Choose datatype (bit resolution) Create scale slopes Create orientation matrix Write the new NIfTI, image matrix & scale slopes Zip and deal with zipping (.nii vs. .nii.gz)","title":"Description"},{"location":"Functions/#xasl_io_dcmtkreadm","text":"","title":"xASL_io_DcmtkRead.m"},{"location":"Functions/#format_113","text":"header = xASL_io_DcmtkRead(filepath, bPixel)","title":"Format"},{"location":"Functions/#description_113","text":"SHORT Reads DICOM headers using DCMTK FORMAT: header = xASL_io_DcmtkRead(filepath, bPixel) INPUT: filepath (string) - full path to the DICOM file bPixel (bool) - read pixel data, default 0 OUTPUT: header (structure) - structure containing parsed DICOM header Calls the MEX function that uses DCMTK library to read the DICOM header. To change which parameters are read and their names - the MEX file needs to be edited. This function also corrects formating of certain parameters.","title":"Description"},{"location":"Functions/#xasl_io_exportvtkm","text":"","title":"xASL_io_ExportVTK.m"},{"location":"Functions/#format_114","text":"xASL_io_ExportVTK(nifti, [mask, exportPath])","title":"Format"},{"location":"Functions/#description_114","text":"Export a VTK image file based on a 3D NIFTI or a 3D/4D image matrix. 4D images will be exported as a VTK time series (export-1.vtk, export-2.vtk, etc.). This script uses vtkwrite (MIT License, Copyright 2016, Joe Yeh).","title":"Description"},{"location":"Functions/#xasl_io_makenifti4dicomm","text":"","title":"xASL_io_MakeNifti4DICOM.m"},{"location":"Functions/#format_115","text":"xASL_io_MakeNifti4DICOM(PathIn, x)","title":"Format"},{"location":"Functions/#description_115","text":"This function converts a NIfTI file to one that is ready to convert to DICOM for PACS visualization purposes: For scaling/visualization: Remove peak signal Remove valley signal Remove NaNs Rescale to 12 bit integers Save NIfTI. We also zip the NIfTI as this NIfTI won't be opened by ExploreASL Manage scale slope/datatype Apply original orientation Zip NIfTI","title":"Description"},{"location":"Functions/#xasl_io_pairwisesubtractionm","text":"","title":"xASL_io_PairwiseSubtraction.m"},{"location":"Functions/#format_116","text":"xASL_io_PairwiseSubtraction(InputFile,outputPath,do_mask,switch_sign)","title":"Format"},{"location":"Functions/#description_116","text":"Subtracts controls from labels and takes mean. Creates new perfusion-weighted delta_M file, prefaced with 's'. Converts into single precision floating point values (32 bit), removes scale slope. Only runs if ['s' input_file_ASL] doesn't exist. Remember to consider motion correction/ SPM realign (isotropically). Alternative to this function is robust fit (Camille Maumet).","title":"Description"},{"location":"Functions/#xasl_io_readdataparm","text":"","title":"xASL_io_ReadDataPar.m"},{"location":"Functions/#format_117","text":"[x] = xASL_io_ReadDataPar(pathDataPar)","title":"Format"},{"location":"Functions/#description_117","text":"This function reads the data-parameter file, which is a file containing settings specific to processing a certain dataset or study (abbreviated as DataPar) and creates the x-structure out of it. The file can be in .json or .m format. The input file name pathDataPar is given as a string or character array. The output is the x structure. It only loads the data, removes the x-prefixes, but keeps all the field names and units. It doesn't do any conversions to or from BIDS. The only added value to normal json-read is that it detects invalid entries (numbers in strings, and weird arrays), converts them correctly and reports this incorrect entries so that they can be manually fixed. Also, if an .m file is provided, it converts and saves it to a JSON file (doesn't overwrite) and reports that you should stop using .m files.","title":"Description"},{"location":"Functions/#xasl_io_readthedicomm","text":"","title":"xASL_io_ReadTheDicom.m"},{"location":"Functions/#format_118","text":"[Info] = xASL_io_ReadTheDicom(bUseDCMTK, DicomPath)","title":"Format"},{"location":"Functions/#description_118","text":"This function tries to read a DICOM and throws a warning if it fails to","title":"Description"},{"location":"Functions/#xasl_io_splitaslm","text":"","title":"xASL_io_SplitASL.m"},{"location":"Functions/#format_119","text":"xASL_io_SplitASL(inPath[, iM0, iDummy])","title":"Format"},{"location":"Functions/#description_119","text":"This function splits ASL4D & M0 & Dummy images if they were in the same sequence. If dcm2niiX has already splitted the ASL4D NIfTI, this is reconstructed first. If no M0 exists, or only ASL splitting is desired, leave iM0 empty ([]). The dummy scans can be excluded from the ASL sequence during the splitting. Both iM0 and iDummy are the absolute positions of both in the original time series Vendor product sequence examples: GE 3D spiral sometimes puts the M0 at the last volume of the series -> iM0 = [2]; Philips 3D GRASE puts the M0 as control-label volume pair -> iM0 = [1 2]; Siemens 3D GRASE puts the M0 as the first volume -> iM0 = 1; Some Siemens 3D GRASE puts a second Dummy control image -> iDummy = 2;","title":"Description"},{"location":"Functions/#xasl_io_dcm2niim","text":"","title":"xASL_io_dcm2nii.m"},{"location":"Functions/#format_120","text":"[niifiles, ScanNameOut, usedinput, msg] = xASL_io_dcm2nii(inpath, destdir, series_name, varargin)","title":"Format"},{"location":"Functions/#description_120","text":"Convert DICOM NIfTI/BIDS format using the dcm2nii command line utility.","title":"Description"},{"location":"Functions/#xasl_num2strm","text":"","title":"xASL_num2str.m"},{"location":"Functions/#format_121","text":"[DataOut] = xASL_num2str(DataIn[, f, bConcatenate, strDelimiter])","title":"Format"},{"location":"Functions/#description_121","text":"When the provided data is numeric, this function will convert the number to string/characters, rewriting NaN into 'n/a' (BIDS convention) but otherwise preserving the Matlab builtin functionality, also for the second argument \"f\". If non-numeric data is provided, it is bypassed (avoiding any issues \"num2str\" will have with non-numeric data). It can concatenate an array/matrix of strings, taking first the columns in the first row, and then going across the rows. See builtin num2str for more details","title":"Description"},{"location":"Functions/#qc","text":"","title":"QC"},{"location":"Functions/#xasl_qc_asymmetryindexm","text":"","title":"xASL_qc_AsymmetryIndex.m"},{"location":"Functions/#format_122","text":"[AI_perc] = xASL_qc_AsymmetryIndex(ImageIn)","title":"Format"},{"location":"Functions/#description_122","text":"Extract voxel-wise asymmetry index for QC purposes.","title":"Description"},{"location":"Functions/#xasl_qc_cat12_iqrm","text":"","title":"xASL_qc_CAT12_IQR.m"},{"location":"Functions/#format_123","text":"[QA_Output] = xASL_qc_CAT12_IQR(InputImage, InputC1, InputC2, InputC3, bFLAIR)","title":"Format"},{"location":"Functions/#description_123","text":"Prepare and run CAT12s QC parameters (also for other images).","title":"Description"},{"location":"Functions/#xasl_qc_collectparametersm","text":"","title":"xASL_qc_CollectParameters.m"},{"location":"Functions/#format_124","text":"x = xASL_qc_CollectParameters(x, iSubject, ScanType, CollectQCFunction)","title":"Format"},{"location":"Functions/#description_124","text":"This function collects QC parameters for a module.","title":"Description"},{"location":"Functions/#xasl_qc_collectqc_aslm","text":"","title":"xASL_qc_CollectQC_ASL.m"},{"location":"Functions/#format_125","text":"[x] = xASL_qc_CollectQC_ASL(x, iSubject)","title":"Format"},{"location":"Functions/#description_125","text":"This functions collects QC parameters for the ASL module These are stored in x.Output.ASL: ID - SubjectName ASL_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 SPM realign (too much motion is suspicious) MotionMean_mm - mean motion MotionExcl_Perc - percentage of excluded outliers MotionMax_mm - max motion MotionSD_mm - SD motion ASL quantification (strange average CBF, or strange GM-WM contrast) ASL acquisition parameters (should be fairly consistent over subjects/scans): TE - echo time TR - repetition time RescaleSlope - Philips Scaleslope - Philips Matrix X Y Z - matrix size Matrix Z - number of slices VoxelSize X Y - in plane resolution VoxelSize Z - slice thickness RigidBody2Anat_mm - Net Displacement Vector (RMS) from ASL to T1w image (mm) from registration","title":"Description"},{"location":"Functions/#xasl_qc_collectqc_structuralm","text":"","title":"xASL_qc_CollectQC_Structural.m"},{"location":"Functions/#format_126","text":"[x] = xASL_qc_CollectQC_Structural(x, iSubject)","title":"Format"},{"location":"Functions/#description_126","text":"This functions collects QC parameters for the structural module These are stored in x.Output.Structural: ID - SubjectName T1w_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 LST output: WMH_vol_mL - WMH volume WMH_n - WMH number of lesions CAT12 output: T1w_IQR_Perc - CAT12 IQR quality parameter for T1w volumetric: GM_vol_mL, WM_vol_mL, CSF_vol_mL, ICV_vol_mL, GM_ICV_Ratio","title":"Description"},{"location":"Functions/#xasl_qc_collectqc_funcm","text":"","title":"xASL_qc_CollectQC_func.m"},{"location":"Functions/#format_127","text":"[x] = xASL_qc_CollectQC_func(x, iSubject)","title":"Format"},{"location":"Functions/#description_127","text":"This functions collects QC parameters for the func module These are stored in x.Output.func: ID - SubjectName func_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 SPM realign (too much motion is suspicious) MotionMean_mm - mean motion MotionExcl_Perc - percentage of excluded outliers MotionMax_mm - max motion MotionSD_mm - SD motion func quantification (strange average CBF, or strange GM-WM contrast) CBF_GM_Median_mL100gmin - median GM CBF CBF_WM_Median_mL100gmin - median WM CBF SpatialCoV_GM_Perc - GM spatial CoV SpatialCoV_WM_Perc - WM spatial CoV CBF_GM_WM_Ratio - GM-WM CBF ratio func acquisition parameters (should be fairly consistent over subjects/scans): TE - echo time TR - repetition time RescaleSlope - Philips Scaleslope - Philips Matrix X Y Z - matrix size Matrix Z - number of slices VoxelSize X Y - in plane resolution VoxelSize Z - slice thickness RigidBody2Anat_mm - Net Displacement Vector (RMS) from func to T1w image (mm) from registration","title":"Description"},{"location":"Functions/#xasl_qc_collectsoftwareversionsm","text":"","title":"xASL_qc_CollectSoftwareVersions.m"},{"location":"Functions/#format_128","text":"[x] = xASL_qc_CollectSoftwareVersions(x)","title":"Format"},{"location":"Functions/#description_128","text":"This functions collects software versions for Matlab, SPM, CAT, LST & ExploreASL If FSL is installed, it will obtain its version as well. These are stored in x.Output.Software.","title":"Description"},{"location":"Functions/#xasl_qc_comparetemplatem","text":"","title":"xASL_qc_CompareTemplate.m"},{"location":"Functions/#format_129","text":"[QC] = xASL_qc_CompareTemplate(x, ModPrefix, iSubjectSession)","title":"Format"},{"location":"Functions/#description_129","text":"This function computes several advanced template-based QC parameters: RMSE_Perc - Root Mean Square Error between image and template (%) nRMSE_Perc - Same but then normalized AI_Perc - Asymmetry Index between image and template (%) Mean_SSIM_Perc - mean structural similarity index -> xASL_stat_MeanSSIM.m PeakSNR_Ratio - peak signal-to-noise ratio -> xASL_stat_PSNR.m","title":"Description"},{"location":"Functions/#xasl_qc_computefovcoveragem","text":"","title":"xASL_qc_ComputeFoVCoverage.m"},{"location":"Functions/#format_130","text":"[CoveragePerc] = xASL_qc_ComputeFoVCoverage(InputPath, x)","title":"Format"},{"location":"Functions/#description_130","text":"This function computes the intersection/overlap between brainmask on field-of-view (FoV) of low resolution image (native space) & the same brainmask with expanded FoV. It uses the pGM+pWM+pCSF as brainmask This assumes that the structural reference image has full brain coverage, and was properly segmented into GM, WM and CSF Also, we assume that the InputPath contains a single 3D volume","title":"Description"},{"location":"Functions/#xasl_qc_computeniftiorientationm","text":"","title":"xASL_qc_ComputeNiftiOrientation.m"},{"location":"Functions/#format_131","text":"[structOut] = xASL_qc_ComputeNiftiOrientation(PathNIfTI[, structIn])","title":"Format"},{"location":"Functions/#description_131","text":"It loads the input Nifti, finds its dimension, voxel size and a net vector distance from its original position before registration. Adds all these information into an output structure structOut while copying all from structIn and keeping it intact.","title":"Description"},{"location":"Functions/#xasl_qc_createpdfm","text":"","title":"xASL_qc_CreatePDF.m"},{"location":"Functions/#format_132","text":"xASL_qc_CreatePDF(x[, DoSubject])","title":"Format"},{"location":"Functions/#description_132","text":"This function iterates over all values in x.Output and all images in x.Output_im, and prints them in a PDF file. x.Output & x.Output_im should contain the QC/result output of all ExploreASL pipeline steps. Further code explanation: Below, using the Matlab & SPM Figure tools we create an image, which is then printed to a PDF file fg = the main Figure handle ax = \"axes\" handles, these are objects containing either 1) text or 2) images, with fg as \"parent\" (1) & (2) images have ax as \"parent\" Positions are calculated in such a way that 4 categories can be printed, which will be the first 4 fields found in x.Output then allowing 8 single slice images, and 15 text lines (name & value columns)","title":"Description"},{"location":"Functions/#xasl_qc_fa_outliersm","text":"","title":"xASL_qc_FA_Outliers.m"},{"location":"Functions/#format_133","text":"[FA_Outliers_mL] = xASL_qc_FA_Outliers(InputFA)","title":"Format"},{"location":"Functions/#description_133","text":"Extract the number of FA outliers, i.e. values of FA above 1 or below 0, from a FA image.","title":"Description"},{"location":"Functions/#xasl_qc_obtainqccategoriesfromjpgm","text":"","title":"xASL_qc_ObtainQCCategoriesFromJPG.m"},{"location":"Functions/#format_134","text":"xASL_qc_ObtainQCCategoriesFromJPG(x)","title":"Format"},{"location":"Functions/#description_134","text":"This function obtains QC categories as covariant/set, based on the JPGs in //Population/ASLCheck. These are initially sorted by spatial CoV, and should be visually checked & put in the correct folder.","title":"Description"},{"location":"Functions/#xasl_qc_pcpstructuralm","text":"","title":"xASL_qc_PCPStructural.m"},{"location":"Functions/#format_135","text":"[anatQA] = xASL_qc_PCPStructural(PathT1, Pathc1T1, Pathc2T1, x, PopPathT1)","title":"Format"},{"location":"Functions/#description_135","text":"This function computes several anatomical QC parameters as proposed in SPM Univariate Plus: WM_ref_vol_mL - volume of the WM reference region (mL) WMref_vol_Perc - same but as percentage of total WM volume SNR_GM - GM signal-to-Noise Ratio (SNR), ie the mean intensity within GM divided by SD of WM reference region. Higher = better. CNR_GM_WM - GM-WM Contrast-to-Noise Ratio (CNR), i.e. the mean of GM - mean of WM divided by the SD of the WM reference region. Higher = better. FBER_WMref_Ratio - Foreground to Background Energy Ratio (FBER), i.e. the variance of voxels within the brain (in pGM+pWM mask) divided by the variance of voxels in the WM reference region. Higher = better. EFC_bits - Shannon Entropy Focus Criterion (EFC), i.e. the entropy of voxel intensities proportional to the maximum possibly entropy for a similarly sized image. Indicates ghosting and head motion-induced blurring. Lower = better. Mean_AI_Perc - mean relative voxel-wise absolute Asymmetry Index (AI) within the brain (pGM+pWM mask) (%) SD - same but SD (%) REFERENCES: Preprocessed Connectome Project Quality Assurance Protocol (QAP): http://preprocessed-connectomes-project.org/quality-assessment-protocol/ http://ieeexplore.ieee.org/document/650886/","title":"Description"},{"location":"Functions/#xasl_qc_printorientationm","text":"","title":"xASL_qc_PrintOrientation.m"},{"location":"Functions/#format_136","text":"xASL_qc_PrintOrientation(DIR, reg_exp_INPUT,OUTPUT_DIR,Name);","title":"Format"},{"location":"Functions/#description_136","text":"Check orientation of niftis, useful to detect accidental left-right flips (all other flips will be visible). translations, rotations or shears are not to be worried about, only negative zooms. This can be detected by negative determinants. So orientation parameters and determinants should be similar across all scans from single scanner/coil, and registration should not give negative determinant.","title":"Description"},{"location":"Functions/#xasl_qc_tanimotocoeffm","text":"","title":"xASL_qc_TanimotoCoeff.m"},{"location":"Functions/#format_137","text":"TC = xASL_qc_TanimotoCoeff(Image1, Image2[, imMask, type])","title":"Format"},{"location":"Functions/#description_137","text":"Compares images Image1 and Image2 within the mask imMask. TYPE specifies the input data type. RATIONALE: Note that the Tanimoto Coefficient is a measure of image overlap/intersection, similar to the Dice coefficient. With the option type 3, this is a fuzzy coefficient, which doesn't require to convert the two images to a binary mask. The TC can be interpreted as a stringent Kappa, ranging from 0 (completely dissimilar) to 100% (identical images). Assuming that perfect registration should not lead to identical images but still retain physiological differences, TC>70% can be regarded as excellent image agreement. The TC will be overestimated when smoothing, but this may lead to more stable artifact detection.","title":"Description"},{"location":"Functions/#xasl_qc_wadqcdcm","text":"","title":"xASL_qc_WADQCDC.m"},{"location":"Functions/#format_138","text":"xASL_qc_WADQCDC(x, iSubject[, ScanType])","title":"Format"},{"location":"Functions/#description_138","text":"This QC function runs WAD-QC specific Python script to zip QC information & incorporate this into a DICOM field for analysis on the WAD-QC server, by the following: Define QCDC script: this is the Python script written by Gaspare, edited by Joost Kuijer & copied to the EPAD CustomScripts folder of ExploreASL Python installation location is checked, with several known locations, for several servers. If we cannot find it, the QCDC is not ran Previous QCDC results are cleaned. QCDC stores all its results in a separate folder (Something like 2 layers up from the current folder, here referred to as QCDCDir = [x.D.ROOT 'qcdc_output']) from these result files, only the filled DICOM file is interesting, all the rest are copies of the QC results that we embedded into the DICOM Run QCDC (if Python installation detected) The following files need to be set as executable: ('QCDC', 'src', 'qc_data_collector.py') ('QCDC', 'src', 'bash', 'create_dcm_only_wadqc.sh') ('QCDC', 'src', 'bash', 'sendwadqc.sh') Clean up new QCDC results (as above) & move the filled DICOM to ['qcdc_' DummyFile] within the current ScanType folder Sending the DICOM to the WAD-QC server using storescu","title":"Description"},{"location":"Functions/#xasl_qc_wadqc_generatedescriptorm","text":"","title":"xASL_qc_WADQC_GenerateDescriptor.m"},{"location":"Functions/#format_139","text":"xASL_qc_WADQC_GenerateDescriptor(x, iSubject)","title":"Format"},{"location":"Functions/#description_139","text":"This QC function generates a JSON descriptor for Gaspare' QCDC script, by the following steps: a) include information about where to find the dummy DICOM (i.e. placeholder DICOM) b) For ExploreASL' QC fields (as passed through in x.Output), here we note all these QC fields for each ScanType, as the x.Output should have been collected equally in the QC file 'QC_collection_SubjectName.json' by function xASL_qc_CollectParameters c) Subfunction xASL_qc_WADQC_images - Includes visual standard space QC images, by searching them on prescribed paths within the Population folder (where currently all derivatives reside) d) Insert the PDF report; this PDF report is subject-specific, not scan-specific. For completeness it is added to each QCDC descriptor e) Add WAD-QC server details (i.e. IP address etc) f) Save the Descriptor JSON file.","title":"Description"},{"location":"Functions/#xasl_qc_temporalsnrm","text":"","title":"xASL_qc_temporalSNR.m"},{"location":"Functions/#format_140","text":"tSNR = xASL_qc_temporalSNR(pathIm4D,pathImTissueProb)","title":"Format"},{"location":"Functions/#description_140","text":"This function computes several temporal SNR QC parameters as proposed in SPM Univariate Plus: tSNR.tSNR_GM_Ratio : mean GM signal / std GM over time tSNR.tSNR.tSNR_WM_Ratio : mean WM signal / std WM over time tSNR.tSNR.tSNR_CSF_Ratio: mean CSF signal / std CSF over time tSNR.tSNR_WMref_Ratio : mean signal/std over time in eroded deep WM tSNR.tSNR_GMWM_Ratio : mean (GM+WM) signal / sqrt(std(GM+WM)^2+std(WMref)^2) tSNR.tSNR_GMWM_WMref_Ratio: mean (GM+WM) signal / std WMref over time tSNR.tSNR_Physio2Thermal_Ratio: sqrt((tSNR(GM+WM)/tSNR_GMWM_WMref_Ratio))^2-1) tSNR.tSNR_Slope_Corr: Differences to the SPM U+ suggestion: eroded WM is used for estimating background noise Brainmask is determined in the same way as the structural anatQC, CSF is determined from the pGM&pWM maps; REFERENCES: 1. Thomas Liu (2016). Noise contributions to the fMRI signal: An overview NeuroImage, 343, 141-151 http://dx.doi.org/10.1016/j.neuroimage.2016.09.008 2. Cesar Caballero-Gaudes and Richard C. Reynolds (2016). Methods For Cleaning The BOLD fMRI Signal. NeuroImage, 154,128-149 3. Lawrence Wald and Jonathan R Polimeni (2016). Impacting the effect of fMRI noise through hardware and acquisition choices ??? Implications for controlling false positive rates. NeuroImage, 154,15-22 4. SPM Utility + toolbox. Cyril Pernet. https://osf.io/wn3h8/","title":"Description"},{"location":"Functions/#quantization","text":"","title":"Quantization"},{"location":"Functions/#xasl_quant_agesex2hctm","text":"","title":"xASL_quant_AgeSex2Hct.m"},{"location":"Functions/#format_141","text":"[Hematocrit] = xASL_quant_AgeSex2Hct([age, sex])","title":"Format"},{"location":"Functions/#description_141","text":"This function estimates a participants hematocrit, based on literature-based values for age and sex. It performs the following steps: Warning unknown age/sex Imputing unknown age/sex Define hematocrit per age for unknown sex Define Hematocrit per age for males Define Hematocrit per age for females","title":"Description"},{"location":"Functions/#xasl_quant_bsupcalculationm","text":"","title":"xASL_quant_BSupCalculation.m"},{"location":"Functions/#format_142","text":"signalPercentage = xASL_quant_BSupCalculation(BackgroundSuppressionPulseTime, ReadoutTime[, PresaturationTime, T1Time, SliceTime, PathGraph])","title":"Format"},{"location":"Functions/#description_142","text":"This function computes the tissue signal percentage that remains after background suppression pulses are played in the ASL acquisition. It assumes that the signal is, at first, optionally saturated by a 90 degree flip at PresaturationTime before readout. Then follows a series of BSup pulses (times before readout are given) that do a 180 degree flip. The observed tissue relaxes with time T1time and the signal attenuation is calculated for several slices acquired at times relative to the readout.","title":"Description"},{"location":"Functions/#xasl_quant_feastm","text":"","title":"xASL_quant_FEAST.m"},{"location":"Functions/#format_143","text":"xASL_quant_FEAST(x)","title":"Format"},{"location":"Functions/#description_143","text":"This function quantifies ATT using the FEAST equations, using crushed and non-crushed sessions, of which the ratio is proportional to ATT. Note that the order of sessions should be 1) crushed 2) non-crushed This function runs the following steps: Skip this function if no FEAST data available Admin Load data & correct for timing differences (PLD etc) Smooth and clip CBF maps & FEAST ratio Compute TT maps","title":"Description"},{"location":"Functions/#xasl_quant_getcontrollabelorderm","text":"","title":"xASL_quant_GetControlLabelOrder.m"},{"location":"Functions/#format_144","text":"[ControlIM, LabelIM, OrderContLabl] = xASL_quant_GetControlLabelOrder(FramesIn, x)","title":"Format"},{"location":"Functions/#description_144","text":"This function automatically checks (and corrects if required) the control and label order of ASL timeseries based on the larger signal in control volumes. It supposes that data is acquired in pairs.","title":"Description"},{"location":"Functions/#xasl_quant_hct2bloodt1m","text":"","title":"xASL_quant_Hct2BloodT1.m"},{"location":"Functions/#format_145","text":"BloodT1 = xASL_quant_Hct2BloodT1(Hematocrit, Y, B0, bVerbose)","title":"Format"},{"location":"Functions/#description_145","text":"This function converts hematocrit to blood T1, according to calculations defined by Patrick Hales. With courtesy and thanks! Note that we assume a venous O2 saturation of 68% (Yv=0.68) This function performs the following steps: Check fraction vs percentage hematocrit & Y, should be between 0 and 1 Specify defaults (Hb, Fe) Perform calculation Convert s to ms Print what we did","title":"Description"},{"location":"Functions/#xasl_quant_m0m","text":"","title":"xASL_quant_M0.m"},{"location":"Functions/#format_146","text":"[M0IM] = xASL_quant_M0(inputM0, x)","title":"Format"},{"location":"Functions/#description_146","text":"This function quantifies the M0, except for the difference in voxel size between the M0 and ASL source data (which is scaled in xASL_wrp_ProcessM0.m). This function runs the following steps: Correct scale slopes, if Philips Convert control image with background suppression to pseudo-M0 Skip M0 quantification if ~x.ApplyQuantification(4) Set TR specifically for GE Check for correct TR values Quantify the M0, either for single 3D volume or slice-wise Apply custom scalefactor if requested (x.M0_GMScaleFactor)","title":"Description"},{"location":"Functions/#xasl_quant_singlepldm","text":"","title":"xASL_quant_SinglePLD.m"},{"location":"Functions/#format_147","text":"[ScaleImage[, CBF]] = xASL_quant_SinglePLD(PWI, M0_im, imSliceNumber, x)","title":"Format"},{"location":"Functions/#description_147","text":"This script performs a multi-step quantification, by initializing a ScaleImage that travels through this script & gets changed by the following quantification factors: PLD scalefactor (gradient if 2D multi-slice) (if x.ApplyQuantification(3)) Label decay scale factor for single (blood T1) - or dual-compartment (blood+tissue T1) model, CASL or PASL Single-compartment model: Alsop MRM 2014 Dual-compartment model: Wang MRM 2002: Gevers JMRI 2012 (if x.ApplyQuantification(3)) Scaling to physiological units [ml/gr/ms =>ml/100gr/min =>(60,000 ms=>min)(1 gr=>100gr)] (if x.ApplyQuantification(3)) Vendor-specific scalefactor (if x.ApplyQuantification(1) -> future move to dcm2niiX stage) Finally, we: Divide PWI/M0 (if x.ApplyQuantification(5)) Print parameters used Note that the output always goes to the CBF image (in the future this could go to different stages, e.g. dcm2niiX or PWI stage)","title":"Description"},{"location":"Functions/#xasl_quant_slicetimingm","text":"","title":"xASL_quant_SliceTiming.m"},{"location":"Functions/#format_148","text":"SliceTiming = xASL_quant_SliceTiming(x, inputIm)","title":"Format"},{"location":"Functions/#description_148","text":"This function takes the x.Q.SliceReadoutTime and returns the SliceTiming parameter. The function creates a vector (of the relatives timings for each slices) out of it with the correct length corresponding to the number of slices in the inputIm corresponding to the BIDS definition. It also checks the x.readout_dim, and for 3D readouts it returns 0. It loads the image from inputIm and calculates the SliceTiming according to the number of slices in the third dimension If a path is given, it also checks if it can find a JSON sidecar, then it loads the JSON sidecar, and looks for SliceTiming inside it. If SliceTiming/SliceReadoutTime is found in the JSON sidecar, it prioritize it over the value in the x-struct For reference, we use these terms: SliceTiming (the BIDS parameter) - it is a vector with the same length as the number of slices and contains the timing of the start of the readout of each slice relative to the first slice SliceReadoutTime - Legacy xASL parameter that will be phased out. It contains either a vector matching the BIDS definition of SliceTiming or a scalar with difference in readout times between the consecutives slices (i.e. the xASL legacy definition of SliceTiming) SliceTimingDiff - Internal parameter in this function for calculating the time difference between consecutive slices. Admin ShortestTR Assign the vector value and check for vector consistency","title":"Description"},{"location":"Functions/#xasl_quant_slicetiming_shortesttrm","text":"","title":"xASL_quant_SliceTiming_ShortestTR.m"},{"location":"Functions/#format_149","text":"[x] = xASL_quant_SliceTiming_ShortestTR(x)","title":"Format"},{"location":"Functions/#description_149","text":"When the TR is set to \"shortestTR\" in the ASL acquisition, each ASL scan will have its unique TR. As this is shortest, there won't be a delay between the readout of the last slice and the end of the TR. Therefore, the time to read out all slices is TR - InitialPostLabelDelay - LabelingDuration, and dividing this by the number of slices gives the SliceReadoutTime","title":"Description"},{"location":"Functions/#spm","text":"","title":"SPM"},{"location":"Functions/#xasl_spm_biasfieldcorrectionm","text":"","title":"xASL_spm_BiasfieldCorrection.m"},{"location":"Functions/#format_150","text":"xASL_spm_BiasfieldCorrection(PathIn, SPMdir, Quality, MaskName, PathOut)","title":"Format"},{"location":"Functions/#description_150","text":"This function is a wrapper around the SPM \"old segment\" function, for biasfield removal. It is tested for M0 and mean control images. It conducts the following steps: Create implicit mask Define SPM 'old segmentation' settings Run SPM 'old segmentation' Delete temporary files Rename temporary SPM file into output file","title":"Description"},{"location":"Functions/#xasl_spm_affinem","text":"","title":"xASL_spm_affine.m"},{"location":"Functions/#format_151","text":"xASL_spm_affine(srcPath, refPath, fwhmSrc, fwhmRef[,otherList, bDCT, bQuality])","title":"Format"},{"location":"Functions/#description_151","text":"This SPM wrapper runs SPM's old normalize-estimate function, which calculates the affine transformation (i.e. linear + zooming and shearing) that is required to align the source image with the reference image. By default it does not estimate the low-degree Discrete Cosine Transform (DCT) to have a simple affine transformation but this can be enabled in this wrapper. Also note that this affine transformation uses a correlation cost function, hence it requires the source and reference images to have similar contrasts and resolution - or provide the resolution estimates so the smoothing can be done. This function does not change the orientation header by default, but it allows to change those of others through the otherList. If bDCT is used or no otherList given, it stores its estimated affine transformation as orientation difference matrix in a file with the same path but _sn.mat extension. For the provided smoothing FWHM, note that smoothnesses combine with Pythagoras' rule (i.e. square summing).","title":"Description"},{"location":"Functions/#xasl_spm_coregm","text":"","title":"xASL_spm_coreg.m"},{"location":"Functions/#format_152","text":"xASL_spm_coreg(refPath, srcPath[, OtherList, x, sep, FastReg])","title":"Format"},{"location":"Functions/#description_152","text":"This SPM wrapper runs SPMs coregister-estimate function, which calculates the 6 parameter rigid-body transformation (a.k.a. linear) that is required to align the source image with the reference image. This 6 parameter transformation (i.e. 3 XYZ translations and 3 rotations) is applied to the orientation header of the source NIfTI image, and also to the images provided in OtherList (optional). Note that this SPM registration function uses a normalized mutual information (NMI) by default, enabling registration between two images with different contrast. Note that this algorithm will use the first volume of a multi-volume NIfTI","title":"Description"},{"location":"Functions/#xasl_spm_defacem","text":"","title":"xASL_spm_deface.m"},{"location":"Functions/#format_153","text":"xASL_spm_deface(PathIn, bReplace)","title":"Format"},{"location":"Functions/#description_153","text":"This function removes the face from an anatomical NIfTI image, e.g. T1w or FLAIR, for disidentification/privacy purposes. When this script is run after the ExploreASL structural module, it does a pretty good job even for 2D images. However, note that this can always fail, strip part of the brain, or change the output of pipelines. So best not to compare results from defaced and non-defaced images. Also, note that defacing makes it difficult to ensure that the FLAIR and T1w are from the same subject.","title":"Description"},{"location":"Functions/#xasl_spm_deformationsm","text":"","title":"xASL_spm_deformations.m"},{"location":"Functions/#format_154","text":"xASL_spm_deformations([x,] PathIn, PathOut[, Interpolation, InverseSpace, AffineTrans, DeformationPath])","title":"Format"},{"location":"Functions/#description_154","text":"This ExploreASL wrapper manages the SPM deformation tool. It takes multiple (ExploreASL pipeline) transformations and combines/concatenates them into a single transformation prior to applying it to the input images. This allows to apply multiple transformations with a single interpolation, avoiding propagation of undesired interpolation effects. Mainly used to get native space images into standard space, or vice versa. Best to combine as many files as possible within this function, since the deformation calculation (which is the most computation intensive part) needs to be performed once for multi-file resampling This function runs the following steps:","title":"Description"},{"location":"Functions/#statistics","text":"","title":"Statistics"},{"location":"Functions/#xasl_stat_atlasforstatsm","text":"","title":"xASL_stat_AtlasForStats.m"},{"location":"Functions/#format_155","text":"[x] = xASL_stat_AtlasForStats(x)","title":"Format"},{"location":"Functions/#description_155","text":"This function loads atlases, checks them, and their ROI names, for later use as ROI definition in xASL_stat_GetROIstatistics Note that the atlases should be integer values, or different 4rd dimensions (i.e. multiple images), that are mutually exclusive. This function takes the following steps: Load atlas ROI names There should be a TSV sidecar to the atlas NIfTI file, as explained above. deal with memory mapping Resample atlas 50 1.5 mm^3 MNI Converted atlas with integers to 4D binary image Convert/compress masks into Columns Print atlas overview image","title":"Description"},{"location":"Functions/#xasl_stat_computediffercovm","text":"","title":"xASL_stat_ComputeDifferCoV.m"},{"location":"Functions/#format_156","text":"diffCoV = xASL_stat_ComputeDifferCoV(imCBF) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask,bPVC,imGM,imWM) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask,bPVC,imGM,imWM,b3D)","title":"Format"},{"location":"Functions/#description_156","text":"It calculates the spatial DiffCoV value on finite part of imCBF. Optionally a mask IMMASK is provide, and PVC is done for bPVC==2 using imGM and imWM masks and constructing pseudoCoV from pseudoCBF image. For bPVC~=2, imGM and imWM are ignored. It is calculated in 2D or assuming also 3D edges based on B3D. Calculate derivate spatial CoV, by summing up differences in CBF between neighbors. The derivative uses Sobels filter.","title":"Description"},{"location":"Functions/#xasl_stat_computemeanm","text":"","title":"xASL_stat_ComputeMean.m"},{"location":"Functions/#format_157","text":"[CBF_GM CBF_WM] = xASL_stat_ComputeMean(imCBF[, imMask, nMinSize, bPVC, bParametric, imGM, imWM])","title":"Format"},{"location":"Functions/#description_157","text":"It calculates mean or median of CBF over the mask imMask if the mask volume exceeds nMinSize. It calculates either a mean, a median, or a mean after PVC, depending on the settings of bPVC. For the PVC options, it needs also imGM and imWM and returns the separate PV-corrected values calculated over the entire ROI. Admin Mask calculations Calculate the ROI statistics 3a. No PVC and simple mean 3b. No PVC and median 3c. Simple PVC 3d. Full PVC on a region","title":"Description"},{"location":"Functions/#xasl_stat_computespatialcovm","text":"","title":"xASL_stat_ComputeSpatialCoV.m"},{"location":"Functions/#format_158","text":"sCov = xASL_stat_ComputeSpatialCoV(imCBF[, imMask, nMinSize, bPVC, bParametric, imGM, imWM])","title":"Format"},{"location":"Functions/#description_158","text":"It calculates the spatial CoV value on finite part of imCBF. Optionally a mask IMMASK is provide, ROIs of size < NMINSIZE are ignored, and PVC is done for bPVC==2 using imGM and imWM masks and constructing pseudoCoV from pseudoCBF image. For bPVC~=2, imGM and imWM are ignored Admin Create masks sCoV computation","title":"Description"},{"location":"Functions/#xasl_stat_equalvariancestestm","text":"","title":"xASL_stat_EqualVariancesTest.m"},{"location":"Functions/#format_159","text":"[resTest, P] = xASL_stat_EqualVariancesTest(X[, alpha, type])","title":"Format"},{"location":"Functions/#description_159","text":"Brown-Forsythe or Levene's test for equality of variances. The response variable is transformed (yij = abs(xij - median(xj)) for Brown-Forsythe and yij = abs(xij - mean(xj)) for Levene's test). And then runs a one-way ANOVA F-test to check if the variances are equal.","title":"Description"},{"location":"Functions/#xasl_stat_getroistatisticsm","text":"","title":"xASL_stat_GetROIstatistics.m"},{"location":"Functions/#format_160","text":"[x] = xASL_stat_GetROIstatistics(x)","title":"Format"},{"location":"Functions/#description_160","text":"This function computes mean and spatial CoV for each ROI, in a [1.5 1.5 1.5] mm MNI space, with several ASL-specific adaptions: Skip ROI masks that are smaller than 1 mL as this would be too noisy for ASL (ignored when x.S.IsASL==false) Expand each ROI mask such that it has sufficient WM content (skipped when IsASL==false) Create for each ROI mask a left, right and bilateral copy Iterate over all subjects: a) Load partial volume maps b) Correct for WMH SEGM -> IS THIS STILL REQUIRED??? c) Load data d) Show ROIs projected on ASL image e) Actual data computations Partial Volume Correction (PVC) options: PVC==0 -> perform masking only, no regression PVC==1 -> single compartment regression, for pGM PVC==2 -> dual compartment regression for pGM & pWM (i.e. normal PVC) Here we mask out susceptibility artifacts (including outside FoV) for all ASL computations, and also mask out vascular artifacts for computing the mean. While other artifacts/FoV can be masked out on population level (i.e. >0.95 subjects need to have a valid signal in a certain voxel), vascular artifacts differ too much in their location between subjects, so we mask this on subject-level. Note that the words \"mask\" and \"ROI\" are used interchangeably throughout this function, where they can have a different or the same meaning PM: WE COULD CHANGE THIS, INTO MASK BEING USED TO EXCLUDE VOXELS AND ROI FOR INCLUDING VOXELS","title":"Description"},{"location":"Functions/#xasl_stat_madnanm","text":"","title":"xASL_stat_MadNan.m"},{"location":"Functions/#format_161","text":"y = xASL_stat_MadNan(x[,flag, dim])","title":"Format"},{"location":"Functions/#description_161","text":"Calculates a Median/Mean Absolute deviation, but ignoring NaNs in the calculation. xASL_stat_MadNan(X) or xASL_stat_MadNan(X,0) computes xASL_stat_MeanNan(ABS(X-xASL_stat_MeanNan(X)) xASL_stat_MadNan(X,1) computes xASL_stat_MedianNan(ABS(X-xASL_st_MedianNan(X)).","title":"Description"},{"location":"Functions/#xasl_stat_meanssimm","text":"","title":"xASL_stat_MeanSSIM.m"},{"location":"Functions/#format_162","text":"mssim=xASL_stat_MeanSSIM(imRef,imSrc[,dynRange])","title":"Format"},{"location":"Functions/#description_162","text":"Calculates the similarity index according to Want et al.","title":"Description"},{"location":"Functions/#xasl_stat_multiplelinregm","text":"","title":"xASL_stat_MultipleLinReg.m"},{"location":"Functions/#format_163","text":"[b,CI,pval,stats] = xASL_stat_MultipleLinReg(X,Y[,bIntercept])","title":"Format"},{"location":"Functions/#description_163","text":"Performs a multiple linear regression Y=b*X+a and provides the intercept and regression coefficients beta including their significance and confidence intervals. It calculates additionally the goodness of the fit.","title":"Description"},{"location":"Functions/#xasl_stat_psnrm","text":"","title":"xASL_stat_PSNR.m"},{"location":"Functions/#format_164","text":"PSNR=xASL_stat_PSNR(imRef,imSrc)","title":"Format"},{"location":"Functions/#description_164","text":"Calculates the PSNR, needs two input arguments - 3D images of the same size. Uses 95% percentile instead of MAX.","title":"Description"},{"location":"Functions/#xasl_stat_pairwisedicem","text":"","title":"xASL_stat_PairwiseDice.m"},{"location":"Functions/#format_165","text":"[DiceCoeff] = xASL_stat_PairwiseDice(GroupA, GroupB)","title":"Format"},{"location":"Functions/#description_165","text":"This function obtains for two lists of images Dice coefficients, for all possible permutations of both lists, by the following steps: 1. Admin (check cell, image exist etc) 2. Obtain matrix of pair-wise permutations 3. Obtain DICE scores PM: Allow entering one group only PM: could extend with xASL_qc_TanimotoCoeff","title":"Description"},{"location":"Functions/#xasl_stat_printstatsm","text":"","title":"xASL_stat_PrintStats.m"},{"location":"Functions/#format_166","text":"[x] = xASL_stat_PrintStats(x)","title":"Format"},{"location":"Functions/#description_166","text":"This function prints an overview of statistics from data that were acquired per ROI, in a TSV file. It starts by printing covariates (called \"Sets\"). Rows will be subjects/sessions, columns will be the sets and ROI-statistics. Any missing data will be skipped (setting them to NaN should have happened in a previous function). This function performs the following steps: First remove previous TSV-file, if already existed printing to a TSV file can be tricky if it is opened by Excel. Make sure to close previous versions first, otherwise this part will crash. Print overview of sets to TSV as explained above. Uses subfunction xASL_stat_CreateLegend to put legends. Aim is to create a single TSV file that has a proper overview of the data, & is self-explanatory to those reading/using it. Define number of ASL sessions, force to 1 in case of TT or volume metrics Print the overview","title":"Description"},{"location":"Functions/#xasl_stat_quantilenanm","text":"","title":"xASL_stat_QuantileNan.m"},{"location":"Functions/#format_167","text":"y = xASL_stat_QuantileNan(x[,quant, dim])","title":"Format"},{"location":"Functions/#description_167","text":"Calculates a quantile, but ignoring NaNs in the calculation","title":"Description"},{"location":"Functions/#xasl_stat_robustmeanm","text":"","title":"xASL_stat_RobustMean.m"},{"location":"Functions/#format_168","text":"[NoOutliers, iOutliers, ThresholdDeviation] = xASL_stat_RobustMean(IM, ParameterFunction)","title":"Format"},{"location":"Functions/#description_168","text":"This function detects outlier images, that can be used to create a robust average, e.g. for template or biasfield creation. This is based either on the sum-of-squares with the mean image (SoS), or on the average relative asymmetry index (AI). Images that are median+/-3 mad off are defined as outliers. MAD = median/mean absolute difference","title":"Description"},{"location":"Functions/#xasl_stat_shapirowilkm","text":"","title":"xASL_stat_ShapiroWilk.m"},{"location":"Functions/#format_169","text":"[H, P, W] = xASL_stat_ShapiroWilk(x[, alpha])","title":"Format"},{"location":"Functions/#description_169","text":"Performs the statistical test of normality - null hypothesis is that the sample is from normal distribution with unspecified mean and variance. Based on the sample kurtosis it performs either Shapiro-Wilk (for platykurtic) or Shapiro-Francia test (for leptokurtic).","title":"Description"},{"location":"Functions/#xasl_stat_stdnanm","text":"","title":"xASL_stat_StdNan.m"},{"location":"Functions/#format_170","text":"y = xASL_stat_StdNan(x[,w,dim])","title":"Format"},{"location":"Functions/#description_170","text":"It behaves in a similar way as VAR - it directly passes all arguments to xASL_stat_VarNan.","title":"Description"},{"location":"Functions/#xasl_stat_sumnanm","text":"","title":"xASL_stat_SumNan.m"},{"location":"Functions/#format_171","text":"y = xASL_stat_SumNan(x[,dim])","title":"Format"},{"location":"Functions/#description_171","text":"It uses the function SUM, but it sets all the NaNs to zero before calling it.","title":"Description"},{"location":"Functions/#xasl_stat_uniquepairwisepermutationsm","text":"","title":"xASL_stat_UniquePairwisePermutations.m"},{"location":"Functions/#format_172","text":"[PermutationList] = xASL_stat_UniquePairwisePermutations(GroupA, GroupB)","title":"Format"},{"location":"Functions/#description_172","text":"This function lists for one or two samples of indices all possible permutations of indices, performing the following steps: One sample permutations Two sample permutations Print conclusion PM: Allow entering one group only PM: could extend with xASL_qc_TanimotoCoeff","title":"Description"},{"location":"Functions/#xasl_stat_varnanm","text":"","title":"xASL_stat_VarNan.m"},{"location":"Functions/#format_173","text":"y = xASL_stat_VarNan(x[,w,dim])","title":"Format"},{"location":"Functions/#description_173","text":"It behaves in a similar way as VAR.","title":"Description"},{"location":"Functions/#xasl_stat_fcdfm","text":"","title":"xASL_stat_fcdf.m"},{"location":"Functions/#format_174","text":"F = xASL_stat_fcdf(F,M,N)","title":"Format"},{"location":"Functions/#description_174","text":"Calculates the cumulative distribution function of the F-distribution for degrees of freedom M,N at value F.","title":"Description"},{"location":"Functions/#xasl_stat_tcdfm","text":"","title":"xASL_stat_tcdf.m"},{"location":"Functions/#format_175","text":"F = xASL_stat_tcdf(T,nu)","title":"Format"},{"location":"Functions/#description_175","text":"Calculates the cumulative distribution function of the Student's t-distribution for degrees of freedom nu at value T.","title":"Description"},{"location":"Functions/#xasl_stat_ticdfm","text":"","title":"xASL_stat_ticdf.m"},{"location":"Functions/#format_176","text":"T = xASL_stat_ticdf(P,nu)","title":"Format"},{"location":"Functions/#description_176","text":"Calculates the inverse of cumulative distribution function of the Student's t-distribution for degrees of freedom nu at value P.","title":"Description"},{"location":"Functions/#xasl_stat_ttestm","text":"","title":"xASL_stat_ttest.m"},{"location":"Functions/#format_177","text":"[H,P,CI,stats] = xASL_stat_ttest(X[,M,alpha,tail,dim])","title":"Format"},{"location":"Functions/#description_177","text":"Performs a t-test that the distribution of the input data X has a mean different from 0 (or from a given mean M, or that the distributions X and Y have different means). A normal distribution of the data with an unknown variance is assumed.","title":"Description"},{"location":"Functions/#xasl_stat_ttest2m","text":"","title":"xASL_stat_ttest2.m"},{"location":"Functions/#format_178","text":"[H,P,CI,stats] = xASL_stat_ttest2(X,Y[,alpha,tail,vartype,dim])","title":"Format"},{"location":"Functions/#description_178","text":"Performs a unpaired t-test that the distribution of the input data X has a mean different from that of Y. A normal distribution of the data with an unknown variance is assumed.","title":"Description"},{"location":"Functions/#xasl_str2numm","text":"","title":"xASL_str2num.m"},{"location":"Functions/#format_179","text":"[DataOut] = xASL_str2num(DataIn[, bKeepCell, bReplaceNonNumerical])","title":"Format"},{"location":"Functions/#description_179","text":"str2num wrapper, which only converts strings to numbers, and allows inputting cells. Also, it replaces 'n/a' with NaN (BIDS convention). And it has some other functionality as described in bKeepCell & bReplaceNonNumerical above.","title":"Description"},{"location":"Functions/#xasl_test_getlogcontentm","text":"","title":"xASL_test_GetLogContent.m"},{"location":"Functions/#format_180","text":"[logContent] = xASL_test_GetLogContent(rootDir, [printContent], [storeRelativePath], [exportTable])","title":"Format"},{"location":"Functions/#description_180","text":"Get warnings and errors from log files. Input check Load all log files Iterate over log files Optional: Print log content Optional: Export (0 = no export, 1 = TSV export, 2 = XLSX export)","title":"Description"},{"location":"Functions/#visualization","text":"","title":"Visualization"},{"location":"Functions/#xasl_vis_addim2qcm","text":"","title":"xASL_vis_AddIM2QC.m"},{"location":"Functions/#format_181","text":"[x] = xASL_vis_AddIM2QC(x,parms);","title":"Format"},{"location":"Functions/#description_181","text":"Checks which images already are loaded, and adds new image.","title":"Description"},{"location":"Functions/#xasl_vis_createvisualfigm","text":"","title":"xASL_vis_CreateVisualFig.m"},{"location":"Functions/#format_182","text":"[ImOut, FileName] = xASL_vis_CreateVisualFig(x, ImIn, DirOut, IntScale, NamePrefix, ColorMap, bClip)","title":"Format"},{"location":"Functions/#description_182","text":"This function creates a visualization Figure by merging flexibly rearranging NIfTI slices, input matrix or path, managing colormaps for different merged image layers. Current use is for visual QC figures and overview in papers. Function is structured as: Admin, deal with input arguments Process image layers separately * xASL_im_TransformData2View: Reshapes image data into visualization figure * xASL_im_ClipExtremes: Clips image to given percentile also we scale for peak intensity, we make sure that there is no visible clipping/distortion * Convert to colors, using any input colormaps combine image layers, using input argument IntScale print figure This function assumes that the first image is a grayscale background image (e.g. for transparancy reasons), if there are multiple images","title":"Description"},{"location":"Functions/#xasl_vis_cropparmsacquirem","text":"","title":"xASL_vis_CropParmsAcquire.m"},{"location":"Functions/#format_183","text":"[xmin xmax ymin ymax] = xASL_vis_CropParmsAcquire(temp_image)","title":"Format"},{"location":"Functions/#description_183","text":"Goes from outside to inside to acquire crop settings. Works with grayscale images (2 dimensions per slice). Image position information (2D matrix) should be first 2 dimensions. Could include colordimension later on.","title":"Description"},{"location":"Functions/#xasl_vis_cropparmsapplym","text":"","title":"xASL_vis_CropParmsApply.m"},{"location":"Functions/#format_184","text":"ImageOut = xASL_vis_CropParmsApply(ImageIn,CropParameters)","title":"Format"},{"location":"Functions/#description_184","text":"This function crops 2D image matrices.","title":"Description"},{"location":"Functions/#xasl_vis_imwritem","text":"","title":"xASL_vis_Imwrite.m"},{"location":"Functions/#format_185","text":"[ImOut] = xASL_vis_Imwrite(ImIn, PathOut[, ColorMap, bRescale])","title":"Format"},{"location":"Functions/#description_185","text":"This functions takes an input image matrix, interpolates it to HD resolution (1920x1080) for visibility, and saves the image as jpg. This function avoids the graphic interface of Matlab, for running from CLI Careful: this function overwrites any existing PathOut.","title":"Description"},{"location":"Functions/#xasl_vis_overlapt1_aslm","text":"","title":"xASL_vis_OverlapT1_ASL.m"},{"location":"Functions/#format_186","text":"xASL_vis_OverlapT1_ASL( x, ASL)","title":"Format"},{"location":"Functions/#description_186","text":"Part of ExploreASL. Shows spatial agreement ASL and probability maps.","title":"Description"},{"location":"Functions/#xasl_vis_tileimagesm","text":"","title":"xASL_vis_TileImages.m"},{"location":"Functions/#format_187","text":"[ImOut] = xASL_vis_TileImages(ImIn, nColumns)","title":"Format"},{"location":"Functions/#description_187","text":"Merges selected slices (3D) into one single 2D picture. Plots all slices in one figure with specified rows and columns, aiming for a square tile. PM: can be extended to multiple slices","title":"Description"},{"location":"Functions/#xasl_vis_transformdata2viewm","text":"","title":"xASL_vis_TransformData2View.m"},{"location":"Functions/#format_188","text":"FigureOut = xASL_vis_TransformData2View(ImagesIn, x)","title":"Format"},{"location":"Functions/#description_188","text":"This function changes the dimensionality and reshapes the input images in such a way that they are nicely tiled in a mosaic for visualization purposes. Reshaping a series of images with this function can be useful for visualization of SPM/voxel-based analyses.","title":"Description"},{"location":"Functions/#xasl_vis_visualqc_topupm","text":"","title":"xASL_vis_VisualQC_TopUp.m"},{"location":"Functions/#format_189","text":"[MeanAI_PreTopUp_Perc, MeanAI_PostTopUp_Perc] = xASL_vis_VisualQC_TopUp(PathPopB0, PathPopUnwarped, x, iSubject, CheckDir)","title":"Format"},{"location":"Functions/#description_189","text":"This function creates a Figure that showes the effect of TopUp with 6 images with axial slices: the NormPE, RevPE and their difference image in colorscale, and this before (upper row) & after (lower row) TopUp.","title":"Description"},{"location":"Functions/#xasl_vis_visualizeroism","text":"","title":"xASL_vis_VisualizeROIs.m"},{"location":"Functions/#format_190","text":"xASL_vis_VisualizeROIs(x, ROI_list)","title":"Format"},{"location":"Functions/#description_190","text":"Creates for each subject a JPEG image containing the original T1w, WMH_SEGM and T1w after lesion-filling.","title":"Description"},{"location":"Functions/#xasl_wrp_linearreg_others2t1wm","text":"","title":"xASL_wrp_LinearReg_Others2T1w.m"},{"location":"Functions/#format_191","text":"xASL_wrp_LinearReg_Others2T1w(x[, bAutoACPC])","title":"Format"},{"location":"Functions/#description_191","text":"This submodule registers T1c and T2 linearly to the T1w","title":"Description"},{"location":"Import_Module/","text":"Submodules of the Import Module xASL_imp_ANONYMIZE.m Format xASL_imp_ANONYMIZE(imPar) Description Run defacing. xASL_imp_AppendNiftiParameters.m Format s = xASL_imp_AppendNiftiParameters(nii_files) Description Append Nifti Parameters. xASL_imp_AppendParmsParameters.m Format [s, FieldNames] = xASL_imp_AppendParmsParameters(parms) Description Append Parms Parameters. xASL_imp_CatchErrors.m Format [dcm2niiCatchedErrors] = xASL_imp_CatchErrors(WarningID, WarningMessage, WarningLine, WarningFileName, WarningPath, scan_name, scanpath, destdir, dcm2niiCatchedErrors, imPar, StackIn) Description Catch reported warnings/errors, print them if verbose, & add them to a structure of warnings/errors to be stored for later QC. xASL_imp_CreateSummaryFile.m Format xASL_imp_CreateSummaryFile(imPar, numOf, listsIDs, PrintDICOMFields, globalCounts, scanNames, summary_lines, fid_summary) Description Create summary file. xASL_imp_DCM2NII.m Format xASL_imp_DCM2NII(imPar, bCopySingleDicoms, bUseDCMTK, bCheckPermissions, bClone2Source,x) Description Run the dcm2nii part of the import. xASL_imp_DCM2NII_Initialize.m Format imPar = xASL_imp_DCM2NII_Initialize(studyPath, imParPath) Description Initialize DCM2NII. xASL_imp_DCM2NII_Subject.m Format [imPar, summary_lines, PrintDICOMFields, globalCounts, dcm2niiCatchedErrors, pathDcmDict] = xASL_imp_DCM2NII_Subject(x, imPar, listsIDs, numOf, settings, globalCounts, iSubject, summary_lines, matches, dcm2niiCatchedErrors, pathDcmDict) Description Run DCM2NII for one individual subject. xASL_imp_NII2BIDS.m Format xASL_imp_NII2BIDS(imPar, studyPath, studyParPath) Description Run the NII2BIDS conversion. xASL_imp_NII2BIDS_Subject.m Format xASL_imp_NII2BIDS_Subject(imPar, bidsPar, studyPar, listSubjects, iSubject) Description Run NII to ASL-BIDS for one individual subject.","title":"Module Import"},{"location":"Import_Module/#submodules-of-the-import-module","text":"","title":"Submodules of the Import Module"},{"location":"Import_Module/#xasl_imp_anonymizem","text":"","title":"xASL_imp_ANONYMIZE.m"},{"location":"Import_Module/#format","text":"xASL_imp_ANONYMIZE(imPar)","title":"Format"},{"location":"Import_Module/#description","text":"Run defacing.","title":"Description"},{"location":"Import_Module/#xasl_imp_appendniftiparametersm","text":"","title":"xASL_imp_AppendNiftiParameters.m"},{"location":"Import_Module/#format_1","text":"s = xASL_imp_AppendNiftiParameters(nii_files)","title":"Format"},{"location":"Import_Module/#description_1","text":"Append Nifti Parameters.","title":"Description"},{"location":"Import_Module/#xasl_imp_appendparmsparametersm","text":"","title":"xASL_imp_AppendParmsParameters.m"},{"location":"Import_Module/#format_2","text":"[s, FieldNames] = xASL_imp_AppendParmsParameters(parms)","title":"Format"},{"location":"Import_Module/#description_2","text":"Append Parms Parameters.","title":"Description"},{"location":"Import_Module/#xasl_imp_catcherrorsm","text":"","title":"xASL_imp_CatchErrors.m"},{"location":"Import_Module/#format_3","text":"[dcm2niiCatchedErrors] = xASL_imp_CatchErrors(WarningID, WarningMessage, WarningLine, WarningFileName, WarningPath, scan_name, scanpath, destdir, dcm2niiCatchedErrors, imPar, StackIn)","title":"Format"},{"location":"Import_Module/#description_3","text":"Catch reported warnings/errors, print them if verbose, & add them to a structure of warnings/errors to be stored for later QC.","title":"Description"},{"location":"Import_Module/#xasl_imp_createsummaryfilem","text":"","title":"xASL_imp_CreateSummaryFile.m"},{"location":"Import_Module/#format_4","text":"xASL_imp_CreateSummaryFile(imPar, numOf, listsIDs, PrintDICOMFields, globalCounts, scanNames, summary_lines, fid_summary)","title":"Format"},{"location":"Import_Module/#description_4","text":"Create summary file.","title":"Description"},{"location":"Import_Module/#xasl_imp_dcm2niim","text":"","title":"xASL_imp_DCM2NII.m"},{"location":"Import_Module/#format_5","text":"xASL_imp_DCM2NII(imPar, bCopySingleDicoms, bUseDCMTK, bCheckPermissions, bClone2Source,x)","title":"Format"},{"location":"Import_Module/#description_5","text":"Run the dcm2nii part of the import.","title":"Description"},{"location":"Import_Module/#xasl_imp_dcm2nii_initializem","text":"","title":"xASL_imp_DCM2NII_Initialize.m"},{"location":"Import_Module/#format_6","text":"imPar = xASL_imp_DCM2NII_Initialize(studyPath, imParPath)","title":"Format"},{"location":"Import_Module/#description_6","text":"Initialize DCM2NII.","title":"Description"},{"location":"Import_Module/#xasl_imp_dcm2nii_subjectm","text":"","title":"xASL_imp_DCM2NII_Subject.m"},{"location":"Import_Module/#format_7","text":"[imPar, summary_lines, PrintDICOMFields, globalCounts, dcm2niiCatchedErrors, pathDcmDict] = xASL_imp_DCM2NII_Subject(x, imPar, listsIDs, numOf, settings, globalCounts, iSubject, summary_lines, matches, dcm2niiCatchedErrors, pathDcmDict)","title":"Format"},{"location":"Import_Module/#description_7","text":"Run DCM2NII for one individual subject.","title":"Description"},{"location":"Import_Module/#xasl_imp_nii2bidsm","text":"","title":"xASL_imp_NII2BIDS.m"},{"location":"Import_Module/#format_8","text":"xASL_imp_NII2BIDS(imPar, studyPath, studyParPath)","title":"Format"},{"location":"Import_Module/#description_8","text":"Run the NII2BIDS conversion.","title":"Description"},{"location":"Import_Module/#xasl_imp_nii2bids_subjectm","text":"","title":"xASL_imp_NII2BIDS_Subject.m"},{"location":"Import_Module/#format_9","text":"xASL_imp_NII2BIDS_Subject(imPar, bidsPar, studyPar, listSubjects, iSubject)","title":"Format"},{"location":"Import_Module/#description_9","text":"Run NII to ASL-BIDS for one individual subject.","title":"Description"},{"location":"License/","text":"The ExploreASL Software is distributed under the license described below, designed to encourage collabortion while at the same time aiming to reuse commercial profit for academical purpose (e.g. hire an ExploreASL developer). All contents, except for those in the folder //External, are proprietary of ExploreASL . The content in the folder //External is not subject to this license. Provisionary license ExploreASL . This license will be renewed soon after legal checks. ExploreASL , Release 0.999 (c) 2020, Amsterdam University Medical Center (the \"Software\") The Software remains the property of Amsterdam University Medical Center (AUMC, \" the University \"). The Software is distributed \"AS IS\" under this License solely for non-commercial use in the hope that it will be useful, but in order that the University as a charitable foundation protects its assets for the benefit of its educational and research purposes, the University makes clear that no condition is made or to be implied, nor is any warranty given or to be implied, as to the accuracy of the Software , or that it will be suitable for any particular purpose or for use under any specific conditions. Furthermore, the University disclaims all responsibility for the use which is made of the Software . It further disclaims any liability for the outcomes arising from using the Software . The Licensee agrees to indemnify the University and hold the University harmless from and against any and all claims, damages and liabilities asserted by third parties (including claims for negligence) which arise directly or indirectly from the use of the Software or the sale of any products based on the Software . No part of the Software may be reproduced, modified, transmitted or transferred in any form or by any means, electronic or mechanical, without the express permission of the University . The permission of the University is not required if the said reproduction, modification, transmission or transference is done without financial return, the conditions of this License are imposed upon the receiver of the product, and all original and amended source code is included in any transmitted product. You may be held legally responsible for any copyright infringement that is caused or encouraged by your failure to abide by these terms and conditions. You are not permitted under this License to use this Software commercially. Use for which any financial return is received shall be defined as commercial use, and includes (1) integration of all or part of the source code or the Software into a product for sale or license by or on behalf of Licensee to third parties or (2) use of the Software or any derivative of it for research with the final aim of developing software products for sale or license to a third party or (3) use of the Software or any derivative of it for research with the final aim of developing non-software products for sale or license to a third party, or (4) use of the Software to provide any service to an external organization for which payment is received. If you are interested in collaborating or contributing to this Software, please contact Henk Mutsaerts (h.j.mutsaerts@amsterdamumc.nl). If you are interested in using this Software commercially, please contact Innovation Exchange Amsterdam (\"IXA\"), the technology transfer company of the University , to negotiate a license.","title":"License"},{"location":"Modules/","text":"Modules 1. Import Module xASL_module_Import Format xASL_module_Import(studyPath, imParPath, studyParPath, bRunSubmodules, bCopySingleDicoms, bUseDCMTK, bCheckPermissions, bClone2Source, x) Description Import batch T1 , T2 , FLAIR , DWI , fMRI , M0 , ASL data from dicom 2 NIfTI in ASL-BIDS format and structure. Uses dcm2niiX for the conversion, and additionally collects important DICOM header data and puts them in .json sidecars to be used with the ExploreASL pipeline. This function takes any folder input, but the folder input should be specified in the imPar definition. Follow the steps below, for study \"MyStudy\" located on \"//MyDisk\" : Make sure you have your DICOM data. Export them from XNAT, download them, or whatsoever Create a root folder with study ID name, and put the DICOMs in any structure in the sourcedata folder within the study ID root folder Examples: imPar.StudyID: MyStudy StudyRoot folder: //MyDisk/MyStudy sourcedata folder containing DICOMs: //MyDisk/MyStudy/sourcedata Make sure that your DICOM data has any structure that can be retrieved from the folder and/or file names. This function doesn't yet read the DICOM headers For a quick and dirty (but actually slow) function that converts a DICOM folder/file structure into readable format, first run ConvertDicomFolderStructure_CarefulSlow.m. This will read each DICOM individually, and put it in a folder with the name identical to the DICOMs SeriesName/ProtocolName. Once you have all DICOMs in folderstructure with identifyable names inside //MyDisk/MyStudy/sourcedata , set up the folderstructure in ExploreASL_ImportConfig.m. This setup uses the SPM form of regular expressions, which can be daunting at first, but are very flexible. Easiest is to study other examples, before creating your own. For this example, let's say we have //MyDisk/MyStudy/sourcedata/ScanType/SubjectName because we downloaded our data from XNAT, ordered per ScanType first, and then per subject. BRIEF EXPLANATION: Let's suppose we don't have sessions (only a single structural and functional scan per subject) The names of our scans comes out of XNAT as '3D\\_FLAIR\\_eyesClosed' , 'T1w\\_MPRAGE' and 'PCASL\\_10\\_min' and the subject names are 'MyStudy001' .. 'MyStudy002' .. etc. imPar.folderHierarchy - contains a a cell array of regular expressions, with each cell specifying a directory layer/level the parts within brackets () tell the script that this is a token (i.e. subject, session, ScanType) Examples: imPar.folderHierarchy = {'^(3D\\_FLAIR|T1w|PCASL).*', '^(Sub-\\d{3})$'}; here we say that there are two folder layers '', separated by comma , where the names between brackets are used to define what is what. ^ means that the foldername has to start with the following, $ means that the previous has to be the end of the foldername .\\* means anything, anylength, \\d{3} means three digits imPar.tokenOrdering - defines which tokens are captured by the brackets () in imPar.folderHierarchy: position 1==subject , 2==visit , 3==session , 4==ScanType Examples: imPar.tokenOrdering = [2 3 0 1]; stating that subject is the 2nd token, visit is the 3rd token, session has no token (i.e. no session) and ScanType is the 1st token imPar.tokenVisitAliases - cell array that defines the aliases for the Visits, i.e. it tells the script which scans are which timepoint/visit. Similar as explained below for ScanAliases. First column contains the names that are recognized in sourcedata DICOM folders for visits, second column how it is named in NIfTI structure (should be _1 _2 _3 etc). Examples: imPar.tokenVisitAliases = {'Screening','\\_1'; 'Month\\_12','\\_2'; 'Month\\_24','\\_3'; 'Month\\_36','\\_4'; 'Month\\_48','\\_5'}; Note that if you specify tokenVisitAliases, the folders will receive the indices (e.g. \\_1 \\_2 \\_3 ), or even \\_1 only with a single Visit). If you don't specify them, they will not get this postfix. imPar.tokenScanAliases - cell array that defines the aliases for the ScanTypes, i.e. it tells the script which scans are which ScanType. First column should contain regular expression corresponding with the matching criteria in imPar.folderHierarchy whereas the second column contains the alias. Following valid aliases exist: 'T1' 'FLAIR' 'ASL4D' 'M0' 'ASL4D\\_RevPE' 'func' 'func\\_NormPE' 'func\\_RevPE' 'dwi' 'dwi\\_RevPE' 'DSC4D' Examples: imPar.tokenScanAliases = {'^3D\\_FLAIR$', 'FLAIR'; '^T1w$', 'T1'; '^PCASL$', 'ASL4D'}; imPar.tokenSessionAliases - same as tokenScanAliases but for sessions Examples: imPar.tokenSessionAliases = {}; % as we don't have sessions imPar.bMatchDirectories - true if the last layer is a folder, false if the last layer is a filename (as e.g. with PAR/REC, enhanced DICOMs) 2. Structural Module xASL_module_Structural Format [result, x] = xASL_module_Structural(x) Description This first ExploreASL module processes the structural images, i.e. high-resolution T1w and FLAIR (if present), on an individual (i.e. subject-to-subject) basis. If a FLAIR is present, this is processed first to obtain a WMH mask to fill the hypointense lesions on the T1w, before segmenting the T1w. For the T1w segmentation this module uses CAT12 by default but if this fails it falls back to SPM after trying to optimize the image contrast. This module has the following steps/submodules/wrappers: 010_LinearReg_T1w2MNI - Ensure the alignment of subjects' anterior commissure (AC) with the AC in MNI & apply this to all images 020_LinearReg_FLAIR2T1w - Align the FLAIR (if present) with T1w 030_FLAIR_BiasfieldCorrection - Perform a biasfield correction (if not performed by LST in following steps) 040_LST_Segment_FLAIR_WMH - Segment WMH lesions on FLAIR (if present) 050_LST_T1w_LesionFilling_WMH - Use WMH segmentation to fill lesions on T1w 060_Segment_T1w - Tissue segmentation on T1w 070_CleanUpWMH_SEGM - Extra WMH cleanup of some over- and under-segmentation 080_Resample2StandardSpace - Clone all images to standard space 090_GetVolumetrics - Obtain whole-brain volumes of GM, WM, CSF, WMH 100_VisualQC - Obtain QC parameters & save QC Figures 110_DoWADQCDC - QC for WAD-QC DICOM server (OPTIONAL) 3. ASL Module xASL_module_ASL Format [result, x] = xASL_module_ASL(x) Description This ExploreASL module processes the ASL images, i.e. ASL4D, M0, etc (if present), on an individual (i.e. session-to-session, where session indicates BIDS \"run\") basis. Both 2D and 3D options are automatially chosen, as well as processing of time-series (if available), such as motion correction and outlier exclusion. This module has the following submodules/wrappers: 010_TopUpASL - FSL TopUp geometric distortion correction (if M0 images with reversed phase-encoding are present) 020_RealignASL - If time-series are present, motion correction and outlier exclusion (ENABLE) 030_RegisterASL - Registration of ASL to T1w anatomical images (if lacking, to MNI images) 040_ResliceASL - Resample ASL images to standard space 050_PreparePV - Create partial volume images in ASL space with ASL resolution 060_ProcessM0 - M0 image processing 070_CreateAnalysisMask- Create mask using FoV, vascular outliers & susceptibility atlas 080_Quantification - CBF quantification 090_VisualQC_ASL - Generate QC parameters & images 100_WADQC - QC for WAD-QC DICOM server (OPTIONAL) 4. Population Module xASL_module_Population Format [result, x] = xASL_module_Population(x) Description This ExploreASL module processes all available images on the group level. It assumes that all images were adequately processed in the previous modules. It will perform the following group-wise processing and checks: 010_CreatePopulationTemplates - Create population average images, to compare scanners, cohorts etc without physiological variance 020_CreateAnalysisMask - Generate a group-level mask by combining individuals masks, for ROI-based analysis & VBA 030_CreateBiasfield - When there are multiple scanners, create scanner-specific biasfields (uses Site.mat for this) 040_GetDICOMStatistics - Create TSV file with overview of DICOM parameters 050_GetVolumeStatistics - Create TSV file with overview of volumetric parameters 060_GetMotionStatistics - Create TSV file with overview of motion parameters 065_GetRegistrationStatistics - Create TSV file with overview of the registration statistics 070_GetROIstatistics - Create TSV file with overview of regional values (e.g. qCBF, mean control, pGM etc) 080_SortBySpatialCoV - Sort ASL_Check QC images by their spatial CoV in quality bins 090_DeleteAndZip - Delete temporary files and gzip all NIfTIs","title":"Modules"},{"location":"Modules/#modules","text":"","title":"Modules"},{"location":"Modules/#1-import-module","text":"","title":"1. Import Module"},{"location":"Modules/#xasl_module_import","text":"","title":"xASL_module_Import"},{"location":"Modules/#format","text":"xASL_module_Import(studyPath, imParPath, studyParPath, bRunSubmodules, bCopySingleDicoms, bUseDCMTK, bCheckPermissions, bClone2Source, x)","title":"Format"},{"location":"Modules/#description","text":"Import batch T1 , T2 , FLAIR , DWI , fMRI , M0 , ASL data from dicom 2 NIfTI in ASL-BIDS format and structure. Uses dcm2niiX for the conversion, and additionally collects important DICOM header data and puts them in .json sidecars to be used with the ExploreASL pipeline. This function takes any folder input, but the folder input should be specified in the imPar definition. Follow the steps below, for study \"MyStudy\" located on \"//MyDisk\" : Make sure you have your DICOM data. Export them from XNAT, download them, or whatsoever Create a root folder with study ID name, and put the DICOMs in any structure in the sourcedata folder within the study ID root folder Examples: imPar.StudyID: MyStudy StudyRoot folder: //MyDisk/MyStudy sourcedata folder containing DICOMs: //MyDisk/MyStudy/sourcedata Make sure that your DICOM data has any structure that can be retrieved from the folder and/or file names. This function doesn't yet read the DICOM headers For a quick and dirty (but actually slow) function that converts a DICOM folder/file structure into readable format, first run ConvertDicomFolderStructure_CarefulSlow.m. This will read each DICOM individually, and put it in a folder with the name identical to the DICOMs SeriesName/ProtocolName. Once you have all DICOMs in folderstructure with identifyable names inside //MyDisk/MyStudy/sourcedata , set up the folderstructure in ExploreASL_ImportConfig.m. This setup uses the SPM form of regular expressions, which can be daunting at first, but are very flexible. Easiest is to study other examples, before creating your own. For this example, let's say we have //MyDisk/MyStudy/sourcedata/ScanType/SubjectName because we downloaded our data from XNAT, ordered per ScanType first, and then per subject. BRIEF EXPLANATION: Let's suppose we don't have sessions (only a single structural and functional scan per subject) The names of our scans comes out of XNAT as '3D\\_FLAIR\\_eyesClosed' , 'T1w\\_MPRAGE' and 'PCASL\\_10\\_min' and the subject names are 'MyStudy001' .. 'MyStudy002' .. etc. imPar.folderHierarchy - contains a a cell array of regular expressions, with each cell specifying a directory layer/level the parts within brackets () tell the script that this is a token (i.e. subject, session, ScanType) Examples: imPar.folderHierarchy = {'^(3D\\_FLAIR|T1w|PCASL).*', '^(Sub-\\d{3})$'}; here we say that there are two folder layers '', separated by comma , where the names between brackets are used to define what is what. ^ means that the foldername has to start with the following, $ means that the previous has to be the end of the foldername .\\* means anything, anylength, \\d{3} means three digits imPar.tokenOrdering - defines which tokens are captured by the brackets () in imPar.folderHierarchy: position 1==subject , 2==visit , 3==session , 4==ScanType Examples: imPar.tokenOrdering = [2 3 0 1]; stating that subject is the 2nd token, visit is the 3rd token, session has no token (i.e. no session) and ScanType is the 1st token imPar.tokenVisitAliases - cell array that defines the aliases for the Visits, i.e. it tells the script which scans are which timepoint/visit. Similar as explained below for ScanAliases. First column contains the names that are recognized in sourcedata DICOM folders for visits, second column how it is named in NIfTI structure (should be _1 _2 _3 etc). Examples: imPar.tokenVisitAliases = {'Screening','\\_1'; 'Month\\_12','\\_2'; 'Month\\_24','\\_3'; 'Month\\_36','\\_4'; 'Month\\_48','\\_5'}; Note that if you specify tokenVisitAliases, the folders will receive the indices (e.g. \\_1 \\_2 \\_3 ), or even \\_1 only with a single Visit). If you don't specify them, they will not get this postfix. imPar.tokenScanAliases - cell array that defines the aliases for the ScanTypes, i.e. it tells the script which scans are which ScanType. First column should contain regular expression corresponding with the matching criteria in imPar.folderHierarchy whereas the second column contains the alias. Following valid aliases exist: 'T1' 'FLAIR' 'ASL4D' 'M0' 'ASL4D\\_RevPE' 'func' 'func\\_NormPE' 'func\\_RevPE' 'dwi' 'dwi\\_RevPE' 'DSC4D' Examples: imPar.tokenScanAliases = {'^3D\\_FLAIR$', 'FLAIR'; '^T1w$', 'T1'; '^PCASL$', 'ASL4D'}; imPar.tokenSessionAliases - same as tokenScanAliases but for sessions Examples: imPar.tokenSessionAliases = {}; % as we don't have sessions imPar.bMatchDirectories - true if the last layer is a folder, false if the last layer is a filename (as e.g. with PAR/REC, enhanced DICOMs)","title":"Description"},{"location":"Modules/#2-structural-module","text":"","title":"2. Structural Module"},{"location":"Modules/#xasl_module_structural","text":"","title":"xASL_module_Structural"},{"location":"Modules/#format_1","text":"[result, x] = xASL_module_Structural(x)","title":"Format"},{"location":"Modules/#description_1","text":"This first ExploreASL module processes the structural images, i.e. high-resolution T1w and FLAIR (if present), on an individual (i.e. subject-to-subject) basis. If a FLAIR is present, this is processed first to obtain a WMH mask to fill the hypointense lesions on the T1w, before segmenting the T1w. For the T1w segmentation this module uses CAT12 by default but if this fails it falls back to SPM after trying to optimize the image contrast. This module has the following steps/submodules/wrappers: 010_LinearReg_T1w2MNI - Ensure the alignment of subjects' anterior commissure (AC) with the AC in MNI & apply this to all images 020_LinearReg_FLAIR2T1w - Align the FLAIR (if present) with T1w 030_FLAIR_BiasfieldCorrection - Perform a biasfield correction (if not performed by LST in following steps) 040_LST_Segment_FLAIR_WMH - Segment WMH lesions on FLAIR (if present) 050_LST_T1w_LesionFilling_WMH - Use WMH segmentation to fill lesions on T1w 060_Segment_T1w - Tissue segmentation on T1w 070_CleanUpWMH_SEGM - Extra WMH cleanup of some over- and under-segmentation 080_Resample2StandardSpace - Clone all images to standard space 090_GetVolumetrics - Obtain whole-brain volumes of GM, WM, CSF, WMH 100_VisualQC - Obtain QC parameters & save QC Figures 110_DoWADQCDC - QC for WAD-QC DICOM server (OPTIONAL)","title":"Description"},{"location":"Modules/#3-asl-module","text":"","title":"3. ASL Module"},{"location":"Modules/#xasl_module_asl","text":"","title":"xASL_module_ASL"},{"location":"Modules/#format_2","text":"[result, x] = xASL_module_ASL(x)","title":"Format"},{"location":"Modules/#description_2","text":"This ExploreASL module processes the ASL images, i.e. ASL4D, M0, etc (if present), on an individual (i.e. session-to-session, where session indicates BIDS \"run\") basis. Both 2D and 3D options are automatially chosen, as well as processing of time-series (if available), such as motion correction and outlier exclusion. This module has the following submodules/wrappers: 010_TopUpASL - FSL TopUp geometric distortion correction (if M0 images with reversed phase-encoding are present) 020_RealignASL - If time-series are present, motion correction and outlier exclusion (ENABLE) 030_RegisterASL - Registration of ASL to T1w anatomical images (if lacking, to MNI images) 040_ResliceASL - Resample ASL images to standard space 050_PreparePV - Create partial volume images in ASL space with ASL resolution 060_ProcessM0 - M0 image processing 070_CreateAnalysisMask- Create mask using FoV, vascular outliers & susceptibility atlas 080_Quantification - CBF quantification 090_VisualQC_ASL - Generate QC parameters & images 100_WADQC - QC for WAD-QC DICOM server (OPTIONAL)","title":"Description"},{"location":"Modules/#4-population-module","text":"","title":"4. Population Module"},{"location":"Modules/#xasl_module_population","text":"","title":"xASL_module_Population"},{"location":"Modules/#format_3","text":"[result, x] = xASL_module_Population(x)","title":"Format"},{"location":"Modules/#description_3","text":"This ExploreASL module processes all available images on the group level. It assumes that all images were adequately processed in the previous modules. It will perform the following group-wise processing and checks: 010_CreatePopulationTemplates - Create population average images, to compare scanners, cohorts etc without physiological variance 020_CreateAnalysisMask - Generate a group-level mask by combining individuals masks, for ROI-based analysis & VBA 030_CreateBiasfield - When there are multiple scanners, create scanner-specific biasfields (uses Site.mat for this) 040_GetDICOMStatistics - Create TSV file with overview of DICOM parameters 050_GetVolumeStatistics - Create TSV file with overview of volumetric parameters 060_GetMotionStatistics - Create TSV file with overview of motion parameters 065_GetRegistrationStatistics - Create TSV file with overview of the registration statistics 070_GetROIstatistics - Create TSV file with overview of regional values (e.g. qCBF, mean control, pGM etc) 080_SortBySpatialCoV - Sort ASL_Check QC images by their spatial CoV in quality bins 090_DeleteAndZip - Delete temporary files and gzip all NIfTIs","title":"Description"},{"location":"Population_Module/","text":"Submodules of the Population Module xASL_adm_DeleteManyTempFiles.m Format xASL_adm_DeleteManyTempFiles(x) Description This function removes as many files as possible. xASL_adm_GzipAllFiles.m Format xASL_adm_GzipAllFiles(ROOT, bFolder, bUseLinux) Description This function zips NIfTI files or folders recursively and deletes the original file/folder after zipping. xASL_im_CreateAnalysisMask.m Format [x] = xASL_im_CreateAnalysisMask(x, Threshold) Description This function takes the mean population-based probability maps of masks, thresholds and combines them: A. Creation GM, WM & WholeBrain masks by p>0.5 B. Create, combine & save vascular, susceptibity & FoV masks: - MaskVascular - MaskSusceptibility = MaskSusceptibility & MaskFoV C. Create & save VBA mask - MaskAnalysis = MaskVascular & MaskSusceptibility - x.S.VBAmask = MaskAnalysis & GMmask D. Visualization: Creates a figure with columns being following maps/masks overlaid over mean population T1w: 1. FoV probability 0-50% missing voxels 2. Vascular 0-7.5% missing voxels 3. Susceptibility 0-50% missing voxels 4. Analysis mask xASL_qc_SortBySpatialCoV.m Format xASL_qc_SortBySpatialCoV(x, Threshold1, Threshold2) Description This function organizes the ASL QC images in //analysis/Population/ASLCheck into CBF, vascular and artifactual contrast per the spatial CoV thresholds defined above, in folders: //analysis/Population/ASLCheck/1_CBFContrast //analysis/Population/ASLCheck/2_VascularContrast //analysis/Population/ASLCheck/3_ArtifactualContrast Invalid spatial CoV numbers (e.g. NaN) will go to: //analysis/Population/ASLCheck/4_Unknown_sCoV Note: these outputs need to be visually checked; but pre-sorting them by spatial CoV puts them already in categories that are quick to skim through and manually correct by moving the images The idea is then that only category 1 images are used for perfusion (CBF) analyses, both categories 1 & 2 for the vascular (sCoV) analyses, and the category 3 images excluded from analysis. PM: this code does not include multiple sessions per subject yet! NB: this code uses the //analysis/Population/Stats/CoV_qCBF*TotalGM*.csv file, make sure that this file isn't edited! xASL_stat_ComputeWsCV.m Format xASL_stat_ComputeWsCV(x) Description Calculates the within and between-subject coefficient of variance (wsCV and bsCV respectively), to estimate the power to detect effects. This requires 4D images that have been split. xASL_stat_GetAcquisitionTime.m Format [x] = xASL_stat_GetAcquisitionTime(x) Description This functions collects the DICOM field AcquisitionTime from each json sidecar (& parms.mat for backward compatibility) and saves them in the participants.tsv. Additionally, it creates a AcquisitionTime histogram of the full study, which can be useful to check time of scanning -> can influence physiological CBF variability. Collect times Save times Create time histogram xASL_stat_GetDICOMStatistics.m Format xASL_stat_GetDICOMStatistics(x, ScanType, HasSessions) Description This functions prints DICOM metadata (e.g. parameters used for quantification) and collects them in a single tsv (per BIDS). Summarizes this for the total population. Can be useful to detect software upgrades, where only slight parameter changes can hint on quantification changes. This function carries out the following steps: Load & save individual parameter files Print summary Write TSV file xASL_stat_GetMotionStatistics.m Format xASL_stat_GetMotionStatistics(x) Description This functions collects motion stats, with the following steps: Collect motion data If no data, skip this function Print motion vs exclusion overview Add motion data to participants.tsv xASL_stat_GetRegistrationStatistics.m Format xASL_stat_GetRegistrationStatistics(x) Description Loads the data from the study given in the QC_collection*.json files. Goes through all subjects and sessions and prints the Tanimoto coefficients that define the quality of the registrations. Steps: Load & extract parameters from individual parameter files Write TSV file xASL_stat_GetVolumeStatistics.m Format xASL_stat_GetVolumeStatistics(x) Description This functions collects motion stats, with the following. Steps: Collect structural volume data Collect WMH data Add stats in participants.tsv xASL_wrp_CreateBiasfield.m Format xASL_wrp_CreateBiasfield(x) Description This function creates a smooth biasfield as intensity map to normalize intensities between different sequences/scanner/sites within a single study. This is a simple pragmatic approach and is not validated, but is the best we can do. First acquires average additive & multiplicative factors for total GM, then does a smooth voxel-wise rescaling. This doesn't make an assumption whether site or sequence differences are additive or multiplicative, but rather fits them both. Global scaling it performed to GM CBF == 60 mL/100g/min NB: make sure that sequence resolution differences have been taken in account before creating these biasfields PM: add normalization of between-subjects SD as well. PM: are there other things we can normalize? xASL_wrp_CreatePopulationTemplates.m Format xASL_wrp_CreatePopulationTemplates(x[, bSaveUnmasked, Compute4Sets, SpecificScantype, bSkipWhenMissingScans, bRemoveOutliers, FunctionsAre]) Description This function creates simple parametric images, a.k.a. templates, for different image/scan types, on population level, as well as for different sets (e.g. sites/scanners/cohorts, etc) if specified. By default these images are masked, and transformed into a single column, for quick computations with low memory usage. The default parametric images that are created are the mean, between-subject SD, and the maximal intensity projection (MIP). The latter can e.g. identify intra-vascular signal that is similar between different subjects. Other parametric maps can be decommented (now commented out for speed). Any new addition to participants.tsv will be recognized and loaded, for the generation of new parametric maps for groups specifically (needs to be set in input argument bCompute4Sets) If a set only includes a combination of the following SetOptions: left, right, l, r, n/a, NaN (irrespective of capitals) each image with option right/r, will be flipped in the left-right direction, and left/right will not be treated as separate groups. This function performs the following steps: Define images/scantypes (if they are not defined by input argument SpecificScantype) Iterate over scan types & sessions Check availability images Load images Remove outliers Compute templates for all subjects together (only for bilateral images) Compute templates for individual sets xASL_wrp_GetROIstatistics.m Format xASL_wrp_GetROIstatistics(x) Description This wrapper organizes the computation of statistics for different ROIs in a [1.5 1.5 1.5] mm MNI space: Load the atlas: xASL_stat_AtlasForStats Organize TSV output name: using x.S.output_ID Obtain the ROI statistics: xASL_stat_GetROIstatistics Print statistics in TSV files: xASL_stat_PrintStats","title":"Module Population"},{"location":"Population_Module/#submodules-of-the-population-module","text":"","title":"Submodules of the Population Module"},{"location":"Population_Module/#xasl_adm_deletemanytempfilesm","text":"","title":"xASL_adm_DeleteManyTempFiles.m"},{"location":"Population_Module/#format","text":"xASL_adm_DeleteManyTempFiles(x)","title":"Format"},{"location":"Population_Module/#description","text":"This function removes as many files as possible.","title":"Description"},{"location":"Population_Module/#xasl_adm_gzipallfilesm","text":"","title":"xASL_adm_GzipAllFiles.m"},{"location":"Population_Module/#format_1","text":"xASL_adm_GzipAllFiles(ROOT, bFolder, bUseLinux)","title":"Format"},{"location":"Population_Module/#description_1","text":"This function zips NIfTI files or folders recursively and deletes the original file/folder after zipping.","title":"Description"},{"location":"Population_Module/#xasl_im_createanalysismaskm","text":"","title":"xASL_im_CreateAnalysisMask.m"},{"location":"Population_Module/#format_2","text":"[x] = xASL_im_CreateAnalysisMask(x, Threshold)","title":"Format"},{"location":"Population_Module/#description_2","text":"This function takes the mean population-based probability maps of masks, thresholds and combines them: A. Creation GM, WM & WholeBrain masks by p>0.5 B. Create, combine & save vascular, susceptibity & FoV masks: - MaskVascular - MaskSusceptibility = MaskSusceptibility & MaskFoV C. Create & save VBA mask - MaskAnalysis = MaskVascular & MaskSusceptibility - x.S.VBAmask = MaskAnalysis & GMmask D. Visualization: Creates a figure with columns being following maps/masks overlaid over mean population T1w: 1. FoV probability 0-50% missing voxels 2. Vascular 0-7.5% missing voxels 3. Susceptibility 0-50% missing voxels 4. Analysis mask","title":"Description"},{"location":"Population_Module/#xasl_qc_sortbyspatialcovm","text":"","title":"xASL_qc_SortBySpatialCoV.m"},{"location":"Population_Module/#format_3","text":"xASL_qc_SortBySpatialCoV(x, Threshold1, Threshold2)","title":"Format"},{"location":"Population_Module/#description_3","text":"This function organizes the ASL QC images in //analysis/Population/ASLCheck into CBF, vascular and artifactual contrast per the spatial CoV thresholds defined above, in folders: //analysis/Population/ASLCheck/1_CBFContrast //analysis/Population/ASLCheck/2_VascularContrast //analysis/Population/ASLCheck/3_ArtifactualContrast Invalid spatial CoV numbers (e.g. NaN) will go to: //analysis/Population/ASLCheck/4_Unknown_sCoV Note: these outputs need to be visually checked; but pre-sorting them by spatial CoV puts them already in categories that are quick to skim through and manually correct by moving the images The idea is then that only category 1 images are used for perfusion (CBF) analyses, both categories 1 & 2 for the vascular (sCoV) analyses, and the category 3 images excluded from analysis. PM: this code does not include multiple sessions per subject yet! NB: this code uses the //analysis/Population/Stats/CoV_qCBF*TotalGM*.csv file, make sure that this file isn't edited!","title":"Description"},{"location":"Population_Module/#xasl_stat_computewscvm","text":"","title":"xASL_stat_ComputeWsCV.m"},{"location":"Population_Module/#format_4","text":"xASL_stat_ComputeWsCV(x)","title":"Format"},{"location":"Population_Module/#description_4","text":"Calculates the within and between-subject coefficient of variance (wsCV and bsCV respectively), to estimate the power to detect effects. This requires 4D images that have been split.","title":"Description"},{"location":"Population_Module/#xasl_stat_getacquisitiontimem","text":"","title":"xASL_stat_GetAcquisitionTime.m"},{"location":"Population_Module/#format_5","text":"[x] = xASL_stat_GetAcquisitionTime(x)","title":"Format"},{"location":"Population_Module/#description_5","text":"This functions collects the DICOM field AcquisitionTime from each json sidecar (& parms.mat for backward compatibility) and saves them in the participants.tsv. Additionally, it creates a AcquisitionTime histogram of the full study, which can be useful to check time of scanning -> can influence physiological CBF variability. Collect times Save times Create time histogram","title":"Description"},{"location":"Population_Module/#xasl_stat_getdicomstatisticsm","text":"","title":"xASL_stat_GetDICOMStatistics.m"},{"location":"Population_Module/#format_6","text":"xASL_stat_GetDICOMStatistics(x, ScanType, HasSessions)","title":"Format"},{"location":"Population_Module/#description_6","text":"This functions prints DICOM metadata (e.g. parameters used for quantification) and collects them in a single tsv (per BIDS). Summarizes this for the total population. Can be useful to detect software upgrades, where only slight parameter changes can hint on quantification changes. This function carries out the following steps: Load & save individual parameter files Print summary Write TSV file","title":"Description"},{"location":"Population_Module/#xasl_stat_getmotionstatisticsm","text":"","title":"xASL_stat_GetMotionStatistics.m"},{"location":"Population_Module/#format_7","text":"xASL_stat_GetMotionStatistics(x)","title":"Format"},{"location":"Population_Module/#description_7","text":"This functions collects motion stats, with the following steps: Collect motion data If no data, skip this function Print motion vs exclusion overview Add motion data to participants.tsv","title":"Description"},{"location":"Population_Module/#xasl_stat_getregistrationstatisticsm","text":"","title":"xASL_stat_GetRegistrationStatistics.m"},{"location":"Population_Module/#format_8","text":"xASL_stat_GetRegistrationStatistics(x)","title":"Format"},{"location":"Population_Module/#description_8","text":"Loads the data from the study given in the QC_collection*.json files. Goes through all subjects and sessions and prints the Tanimoto coefficients that define the quality of the registrations. Steps: Load & extract parameters from individual parameter files Write TSV file","title":"Description"},{"location":"Population_Module/#xasl_stat_getvolumestatisticsm","text":"","title":"xASL_stat_GetVolumeStatistics.m"},{"location":"Population_Module/#format_9","text":"xASL_stat_GetVolumeStatistics(x)","title":"Format"},{"location":"Population_Module/#description_9","text":"This functions collects motion stats, with the following. Steps: Collect structural volume data Collect WMH data Add stats in participants.tsv","title":"Description"},{"location":"Population_Module/#xasl_wrp_createbiasfieldm","text":"","title":"xASL_wrp_CreateBiasfield.m"},{"location":"Population_Module/#format_10","text":"xASL_wrp_CreateBiasfield(x)","title":"Format"},{"location":"Population_Module/#description_10","text":"This function creates a smooth biasfield as intensity map to normalize intensities between different sequences/scanner/sites within a single study. This is a simple pragmatic approach and is not validated, but is the best we can do. First acquires average additive & multiplicative factors for total GM, then does a smooth voxel-wise rescaling. This doesn't make an assumption whether site or sequence differences are additive or multiplicative, but rather fits them both. Global scaling it performed to GM CBF == 60 mL/100g/min NB: make sure that sequence resolution differences have been taken in account before creating these biasfields PM: add normalization of between-subjects SD as well. PM: are there other things we can normalize?","title":"Description"},{"location":"Population_Module/#xasl_wrp_createpopulationtemplatesm","text":"","title":"xASL_wrp_CreatePopulationTemplates.m"},{"location":"Population_Module/#format_11","text":"xASL_wrp_CreatePopulationTemplates(x[, bSaveUnmasked, Compute4Sets, SpecificScantype, bSkipWhenMissingScans, bRemoveOutliers, FunctionsAre])","title":"Format"},{"location":"Population_Module/#description_11","text":"This function creates simple parametric images, a.k.a. templates, for different image/scan types, on population level, as well as for different sets (e.g. sites/scanners/cohorts, etc) if specified. By default these images are masked, and transformed into a single column, for quick computations with low memory usage. The default parametric images that are created are the mean, between-subject SD, and the maximal intensity projection (MIP). The latter can e.g. identify intra-vascular signal that is similar between different subjects. Other parametric maps can be decommented (now commented out for speed). Any new addition to participants.tsv will be recognized and loaded, for the generation of new parametric maps for groups specifically (needs to be set in input argument bCompute4Sets) If a set only includes a combination of the following SetOptions: left, right, l, r, n/a, NaN (irrespective of capitals) each image with option right/r, will be flipped in the left-right direction, and left/right will not be treated as separate groups. This function performs the following steps: Define images/scantypes (if they are not defined by input argument SpecificScantype) Iterate over scan types & sessions Check availability images Load images Remove outliers Compute templates for all subjects together (only for bilateral images) Compute templates for individual sets","title":"Description"},{"location":"Population_Module/#xasl_wrp_getroistatisticsm","text":"","title":"xASL_wrp_GetROIstatistics.m"},{"location":"Population_Module/#format_12","text":"xASL_wrp_GetROIstatistics(x)","title":"Format"},{"location":"Population_Module/#description_12","text":"This wrapper organizes the computation of statistics for different ROIs in a [1.5 1.5 1.5] mm MNI space: Load the atlas: xASL_stat_AtlasForStats Organize TSV output name: using x.S.output_ID Obtain the ROI statistics: xASL_stat_GetROIstatistics Print statistics in TSV files: xASL_stat_PrintStats","title":"Description"},{"location":"Requirements/","text":"Requirements Developer Note The following requirements are necessary to robustly execute the ExploreASL workflow. ExploreASL is tested on Debian/Ubuntu 20.04 LTS with Matlab 2019a. Using an older version of Linux or Matlab could lead to errors. Software Requirements Matlab 2019a Debian/Ubuntu 20.04 LTS Hardware Requirements 4 GB RAM Included Software Versions of included & used third-party tools: SPM12 7219 CAT12 r1615 LST 2.0.15","title":"Requirements"},{"location":"Requirements/#requirements","text":"","title":"Requirements"},{"location":"Requirements/#developer-note","text":"The following requirements are necessary to robustly execute the ExploreASL workflow. ExploreASL is tested on Debian/Ubuntu 20.04 LTS with Matlab 2019a. Using an older version of Linux or Matlab could lead to errors.","title":"Developer Note"},{"location":"Requirements/#software-requirements","text":"Matlab 2019a Debian/Ubuntu 20.04 LTS","title":"Software Requirements"},{"location":"Requirements/#hardware-requirements","text":"4 GB RAM","title":"Hardware Requirements"},{"location":"Requirements/#included-software","text":"Versions of included & used third-party tools: SPM12 7219 CAT12 r1615 LST 2.0.15","title":"Included Software"},{"location":"SPMxASL/","text":"SPM xASL Functions CorrClusTh.m Format function [k,Pc] = CorrClusTh(SPM,u,alpha,guess) Description Finds the corrected cluster size (spatial extent) threshold for a given cluster defining threshold u and FWE-corrected level alpha. xASL_Copy.m Format xASL_Copy(SrxASL_SysCopyath, DstPath[, bOverwrite, bVerbose)]) Description Copies a file to a file or a directory to a directory. For a file, it zips it in the end if the destination path contains nii.gz. It also makes sure that only one of .nii and .nii.gz exists in the destination directory. It is faster than the default Matlab function, and runs on multiple OSes. NB: This function calls xASL_SysMove for the actual copying. Run xASL_SysMove instead of xASL_Move if you don't want the .nii|.nii.gz management/checking xASL_Move.m Format xASL_Move(SrcPath, DstPath[, bOverwrite, bVerbose]) Description Moves a file to a file, a file to a directory, or a directory to a directory. It keeps the initial extensions, no unzipping or zipping after the move. But it makes sure that only one of .nii and .nii.gz exists in the destination directory. Bypass inefficient matlab stuff on linux and windows, but can only move on the same file system. NB: This function calls xASL_SysMove for the actual moving. Run xASL_SysMove instead of xASL_Move if you don't want the .nii|.nii.gz management/checking xASL_SysCopy.m Format xASL_SysCopy(SrcPath, DstPath, bOverwrite, bVerbose) Description Copies a file to a file or a directory to a directory. Bypass inefficient matlab stuff on linux and windows, but can only move on the same file system. xASL_SysMove.m Format xASL_SysMove(SrcPath, DstPath[, bForce, bSourceCheck]) Description Moves a file to a file, a file to a directory, or a directory to a directory. SBypass inefficient matlab stuff on linux and windows, but can only move on same file system! xASL_TrackProgress.m Format xASL_TrackProgress(iCurrent[, iMax]) Description Counts the percentage of the work done and display on the screen. Either iCurrent of iMax are given. Or only the percentages are given. xASL_adm_ConvertSeconds2TimeString.m Format TimeString = xASL_adm_ConvertSeconds2TimeString(Seconds) Description Converts number to time input hh (with minutes in fractions/floating point) -> output hhmm Inverse from xASL_adm_ConvertTime2Nr. xASL_adm_ConvertSlash.m Format [newString] = xASL_adm_ConvertSlash( StringOriginal,ForceUnix) Description Converts Windows forward slashes to backward slashes Prevents confusion file separation & regular expression forward slashes in Windows. xASL_adm_CreateDir.m Format status = xASL_adm_CreateDir(strPath) create all missing subdirs status = xASL_adm_CreateDir(strPath, strBranch) create strBranch (if missing) under existing strPath status = xASL_adm_CreateDir(strPath, nMaxNewDirs) impose limit on the number of new directories Description Recursively creates missing directories at the given path or for given subdirectories, with an option to limit the number of newly created directories. xASL_adm_DeleteFileList.m Format filepaths = xASL_adm_DeleteFileList(strDirectory, strRegEx[, bRecurse, nRequired]) xASL_adm_DeleteFileList(strDirectory, strRegEx[, bRecurse, nRequired]) Description Delete the files that match regular expression STRREGEXP in the given directory STRDIRECTORY. Deletes recursively if specified in BRECURSE. Deletes all files unless the number is specified by NREQUIRED, if the number is not met, then does not delete anything and throws an error. xASL_adm_GetFileList.m Format filepaths = xASL_adm_GetFileList(strDirectory[, strRegEx, mode, nRequired, bGetDirNames]) Description List files or directories from a given path. And optionally uses regular expressions to filter the result with option to set a minimal requirement on the number of results. xASL_adm_GzipNifti.m Format pathOut = xASL_adm_GzipNifti(pathIn [,bOverwrite]) Description Take the input file, zips it, overwriting any existing zipped file and return the path of the zipped file. xASL_adm_ManageMoCoMat.m Format xASL_adm_ManageMoCoMat(PathIn) Description This function manages the orientation matrices that SPM puts in an external .mat sidecar file if there are more than 1 volumes. The first volume should be equal to the orientation header of the NIfTI, if not, we assume that the NIfTI header is correct. This function performs several checks & corrects if necessary, combined with throwing a warning: A) the nVolumes in .mat & .nii image should be equal, if not, delete sidecar B) .mat should have more than one volume, if not delete sidecar C) If there are illegal numbers in the diagonal of the .mat orientation matrices (here only checked for zeros or non finite values) then the .mat is removed D) If this is true for the first volume only, the .mat is retained but the first volume orientation is overwritten with a zero matrix xASL_adm_UnixPath.m Format [PathIs] = xASL_adm_UnixPath(PathIs[, bTryWSL]) Description This function performs the following steps to convert a path to a path that is compatible with the Unix-filesystem as used in e.g. Linux/MacOS. It also has special support for Windows Subsystem for Linux (WSL), though this should only be activated specifically for WSL calls. Note that we want to use this function for most Unix calls (to fix paths), but in the case of WSL only for some calls, where Matlab in Windows calls Linux-code through WSL (e.g. for FSL) - these have to be explicitly specified by the bTryWSL option. Skip this function without Unix-filesystem Trim whitespace Selectively convert forward to backward slashes (ignore already escaped whitespace) Escape characters and residual whitespaces (ignore already escaped whitespaces) If WSL: add mounting prefix xASL_adm_UnzipNifti.m Format pathOut = xASL_adm_UnzipNifti(pathIn[, bOverwrite]) Description Takes the input file, unzips if needed, delete the zipped file and return the path to the unzipped file. If the input is already unzipped, then does nothing, but returns the original filename - so it can be run just to be sure a file is unzipped without much overhead. Returns error if more than one file is in the archive, if the filename does not exist, is a directory etc. If there's a NII and NII.GZ already existing, then return error, or just overwrite in case overwrite is set to 1 xASL_adm_ZipFileNameHandling.m Format [srcOut, dstOut] = xASL_adm_ZipFileNameHandling(srcIn, dstIn) Description Adjusts the source and destination filenames of a nifti file to reflect if NII or NII.GZ exist on the input. If either .nii or .nii.gz is corrupt, it automatically deletes the corrupt one and keeps the healthy one, while reporting a warning. This happens when you restart the pipeline after it crashed, if it crashed while unzipping. xASL_bids_csv2tsvReadWrite.m Format [PathTSV, CellContents] = xASL_bids_csv2tsvReadWrite(PathIn[, bDeleteCSV, bWriteTSV]) Description This function PathIn and loads it, also trying CSV or TSV extensions if these exist. It outputs the contents to a cell array. If a CSV file exists but not a TSV file, it converts and replaces the CSV to TSV file, per BIDS. This function has the following parts: Read the CSV or TSV file Write the TSV file (if requested) Delete the CSV file (if requested) xASL_csvRead.m Format [CellContents] = xASL_csvRead(PathCSV) Description This function loads a comma-separated value (csv) file - which is the format that BIDS prefers - and outputs it to a cell array. xASL_csvWrite.m Format xASL_csvWrite(InputCell, PathCSV, bOverwrite) Description Rudimentary function, please use xASL_tsvWrite instead. For usage, type help xASL_tsvWrite. This function will still work though. xASL_delete.m Format xASL_delete(InputPath) Description Delete the file in the given path. If a NIFTI file with extension '.nii' or '.nii.gz' is given, Then delete both the .nii and .nii.gz files. xASL_exist.m Format xASL_exist(PathIn[,Type]) Description Check if the given path exists, wrapper around the Matlab exist function, to allow checking for either .nii or .nii.gz Otherwise, exist is used normally. xASL_fileparts.m Format [Fpath, Ffile, Fext] = xASL_fileparts(InputPath) Description Returns the path, file name, and file extension for InputPath using the fileparts.m function. If a file ending at nii.gz is given, then the whole nii.gz is returned as the extension. Does not verify the existence of the file, or existence of .nii or .nii.gz xASL_im_ConvertMap2Mask.m Format [IMout] = xASL_im_ConvertMap2Mask(IMin) Description Provides a robust way of conversion of a continuous map to a binary mask, which can be used for lesions, ROIs, or tissue probability maps. Based on the assumption that a map should be thresholded at 50% to form a map, which is often the case for automatic segmentations. xASL_im_DistanceTransform.m Format [dist, x, y, z] = xASL_im_DistanceTransform(im) Description Calculates the distance transform in a binary image Uses Borgefors Chamfers computation of Euclidean distance in 3D using a 5x5x5 window. xASL_im_FillNaNs.m Format xASL_im_FillNaNs(InputPath[, UseMethod, bQuality]) Description This function fills any NaNs in an image. In SPM, any voxels outside the boundary box/field of view are filled by NaNs when resampling. These NaNs can confuse some algorithms, hence it doesn't hurt replacing them in some cases (e.g. for flowfields). Also, smoothing restricted in a mask is done in ExploreASL with the function xASL_im_ndnanfilter, after first setting all voxels outside the mask to NaN. In this case, this functon can be useful to extrapolate the smoothed image to avoid any division artifact near brain edges (e.g. for reducing the M0 image to a smooth biasfield). This function performs the following 3 steps: Load image Replace NaNs Save image xASL_im_LesionRemoval4CAT.m Format [Ycls, LesionImOut] = xASL_im_LesionRemoval4CAT(Ycls, PathIn) Description For all lesion masks in the anatomical directory, remove them from the current segmentations. xASL_im_ResampleIM.m Format [imOut] = xASL_im_ResampleIM(imIn, matIn, matOut, dimOut[, interpolationType]) Description Resamples an input image imIn oriented according to the homogeneous matrix matIn to and output image imOut that has dimension dimOut and matrix matOut. This allows to resample images between two spaces with different orientation and matrix sizes. It uses the Matlab interp3 function and the interpolation method used by this method can be chosen. Note that the recommended use of this function is resampling between space with similar resolution or upsampling. For downsampling, simple interpolation does not delivery correct results respecting the point-spread-function and a combination of xASL_im_PreSmooth and xASL_spm_reslice should be used instead. xASL_im_SaveOriginal4CAT.m Format xASL_im_SaveOriginal4CAT(Ycls, PathIn) Description Save the segmentation before lesion masking. xASL_im_conv3Dsep.m Format [imConv] = xASL_mex_conv3Dsep(im,kX,[kY,kZ]) Description 3D separable convolution with a supplied kernel It converts the results to double Returned is the convoluted image The wrapper makes sure that kX are Nx1 format, removes nan, and removes excessive zeros at the ends. xASL_im_ndnanfilter.m Format [Y,fil] = xASL_im_ndnanfilter(X,filterType,F,WNAN) Description This function applies a 3-dimensional convolution of X with given kernel. NaNs elements are taken into account (ignored). By default, edges are not padded and one-sided filter is used at the image edges. Notes: * Accepts empty value for any input. When X is empty, the program can be used as a N-dimensional window generator. * NaNs elements surrounded by no-NaNs elements (which will depend on window width) are the ones that will be interpolated. The others are leaved untouched. * When WNAN=2, the programs acts like an NAN-interpolat/GAP-filling, leaving untouched the no-NaNs elements but the filtering is perfomed anyway. I recommend the default behaviour (WNAN=0) in order to keep the filtered data in the workspace, and then use the code at the end of this function to get/remove the interpolated NaNs * To achieve similar results as ndnanfilter previously, use same F as with the 'rect' filter. * Note that the FWHM of Gaussian is given in VOXELS, not in mm * For the Gaussian filter, use (previous N, new FWHM) N= 1 ~ FWHM 0.94 N= 2 ~ FWHM 1.885 N= 4 ~ FWHM 3.76 N= 6 ~ FWHM 5.652 N= 8 ~ FWHM 7.536 N=10 ~ FWHM 9.42 N=12 ~ FWHM 11.3 N=16 ~ FWHM 15.07 N=20 ~ FWHM 18.84 N=10/2.355 ~ FWHM 4 Basically divide by 1.06 xASL_io_Nifti2Im.m Format imOut = xASL_io_Nifti2Im(niftiIn [, ImageSize]) Description This function loads a NIfTI image matrix with flexible input (as explained under INPUT: niftiIn). It does the following. Try to load a NIfTI If NIfTI successfully loaded, try to load the NIfTI image If the above didnt work, try to create a dummy image Convert to single precision data format Also able to load NIfTI as .nii.mat format xASL_io_ReadNifti.m Format [NiftiObject, pathIn] = xASL_io_ReadNifti(pathIn) Description Read Nifti file given by the path. Return the NII object. And also return the actual path to the loaded Nifti if by any reason the name changed during the function runtime (e.g. unzipping). xASL_io_SaveNifti.m Format xASL_io_SaveNifti(pathOrigNifti, pathNewNifti, imNew[, nBits, bGZip, newMat]) Description It loads the pathOrigNifti, takes all the parameters from it, and creates a new Nifti file with these parameters, but new image matrix from imNew. It saves the result in pathNewNifti. xASL_round.m Format [OutputN] = xASL_round(InputN[, PrecisionN]) Description Recent Matlab versions support a second input that specifies that number of decimals to round at, but earlier Matlab versions do not support this. For backward compatibility, use this wrapper instead of round. xASL_spm_admin.m Format [InPath] = xASL_spm_admin(InPath, bPadComma1) Description Force ,1 at end of IMname. This is useful for refIM/srcIM in CoregInit, OldNormalizeWrapper etc. xASL_spm_reslice.m Format xASL_spm_reslice(refPath, srcPath[, srcAffinePath, bInvAffine, bQuality, NewName, InterpolationPar]) Description This wrapper runs SPM's reslice function (a.k.a. coregister: reslice) which resamples a source image into the space of a reference image, taking into account any orientation differences between the two images that are defined in the orientation matrix in the NIfTI header. When the source image contains multiple volumes, they are all resampled. The source image will get the same orientation matrix as the reference image, as it is now in the same space as the reference image. This can be useful when two images are to be compared voxel-by-voxel, e.g. when overlaying a CBF image over a structural image, or when wanting to use a mask from a different space. When after running this function, the reference and source images are not in alignment, they need to be registered first (i.e. xASL_spm_register). Resampling/reslicing needs an interpolation method to know from which voxels of the source image, a voxel in the new image will be computed. A simplistic explanation is that this determines the number of surrounding neighborhood voxels it uses to determine the new voxel value. The example syntax below would reslice/resample the CBF image to the T1w space (assuming the Affine was done to register CBF to T1w) It also works with the external .mat file of the source file that has the same name as the source file. It also can optionally take a _sn.mat containing the affine transformation information. xASL_spm_smooth.m Format xASL_spm_smooth(pathIn, fwhmSmooth[, pathNew]) Description This SPM wrapper runs SPM's smooth function, which spatially smooths the input image with a Gaussian kernel. In the case of multiple volumes (i.e. a 4D NIfTI), each 3D volume is spatially smoothed separately. Note that smoothnesses combine with Pythagoras' rule (i.e. sum quadratically) xASL_stat_MeanNan.m Format y = xASL_stat_MeanNan(x[,dim]) Description It calculates the sum using the SUM functions and divides by the number of values but ignoring NaNs. xASL_stat_MedianNan.m Format y = xASL_stat_MedianNan(x[,dim]) Description It calculates the MEDIAN along the given dimension, but it sets all the NaNs to zero before calling it. xASL_tsvRead.m Format [CellContents] = xASL_tsvRead(PathTSV[, bStruct]) Description This function loads a tab-separated value (TSV) file - which is the format that BIDS prefers - and outputs it to a cell array. xASL_tsvWrite.m Format xASL_tsvWrite(InputCell, PathTSV[, bOverwrite, bCSV]) Description This function loads a cell array and prints it to a tab-separated value (TSV) file, which is the format that BIDS prefers. xASL_wrp_DARTELSaveIntermedTrans.m Format xASL_wrp_DARTELSaveIntermedTrans(Yy, u, odim, rdim, idim, Mar, mat, M0, M1, nameOut, numIteration) Description This function is called from the CAT12 segmentation function to save the intermediate results of the DARTEL transformation. Normally, the registration only saves the final results - the final transformation field. This function enables to save also the intermediate transformation field. It takes all the internal variables from the transformation and save the field to a sub-directory 'mri' that normally contains all the intermediate results of the CAT12 segmentation. It adds a 'y_' prefix and adds the specified iteration number as postfix. xASL_wrp_GSSaveIntermedTrans.m Format xASL_wrp_GSSaveIntermedTrans(y, idim, odim, rdim, M0, M1, R, M1t, M1r, nameOut, numIteration) Description This function is called from the CAT12 segmentation function to save the intermediate results of the Geodesic shooting transformation. Normally, the registration only saves the final results - the final transformation field. This function enables to save also the intermediate transformation field. It takes all the internal variables from the transformation and save the field to a sub-directory 'mri' that normally contains all the intermediate results of the CAT12 segmentation. It adds a 'y_' prefix and adds the specified iteration number as postfix.","title":"SPM xASL Functions"},{"location":"SPMxASL/#spm-xasl-functions","text":"","title":"SPM xASL Functions"},{"location":"SPMxASL/#corrclusthm","text":"","title":"CorrClusTh.m"},{"location":"SPMxASL/#format","text":"function [k,Pc] = CorrClusTh(SPM,u,alpha,guess)","title":"Format"},{"location":"SPMxASL/#description","text":"Finds the corrected cluster size (spatial extent) threshold for a given cluster defining threshold u and FWE-corrected level alpha.","title":"Description"},{"location":"SPMxASL/#xasl_copym","text":"","title":"xASL_Copy.m"},{"location":"SPMxASL/#format_1","text":"xASL_Copy(SrxASL_SysCopyath, DstPath[, bOverwrite, bVerbose)])","title":"Format"},{"location":"SPMxASL/#description_1","text":"Copies a file to a file or a directory to a directory. For a file, it zips it in the end if the destination path contains nii.gz. It also makes sure that only one of .nii and .nii.gz exists in the destination directory. It is faster than the default Matlab function, and runs on multiple OSes. NB: This function calls xASL_SysMove for the actual copying. Run xASL_SysMove instead of xASL_Move if you don't want the .nii|.nii.gz management/checking","title":"Description"},{"location":"SPMxASL/#xasl_movem","text":"","title":"xASL_Move.m"},{"location":"SPMxASL/#format_2","text":"xASL_Move(SrcPath, DstPath[, bOverwrite, bVerbose])","title":"Format"},{"location":"SPMxASL/#description_2","text":"Moves a file to a file, a file to a directory, or a directory to a directory. It keeps the initial extensions, no unzipping or zipping after the move. But it makes sure that only one of .nii and .nii.gz exists in the destination directory. Bypass inefficient matlab stuff on linux and windows, but can only move on the same file system. NB: This function calls xASL_SysMove for the actual moving. Run xASL_SysMove instead of xASL_Move if you don't want the .nii|.nii.gz management/checking","title":"Description"},{"location":"SPMxASL/#xasl_syscopym","text":"","title":"xASL_SysCopy.m"},{"location":"SPMxASL/#format_3","text":"xASL_SysCopy(SrcPath, DstPath, bOverwrite, bVerbose)","title":"Format"},{"location":"SPMxASL/#description_3","text":"Copies a file to a file or a directory to a directory. Bypass inefficient matlab stuff on linux and windows, but can only move on the same file system.","title":"Description"},{"location":"SPMxASL/#xasl_sysmovem","text":"","title":"xASL_SysMove.m"},{"location":"SPMxASL/#format_4","text":"xASL_SysMove(SrcPath, DstPath[, bForce, bSourceCheck])","title":"Format"},{"location":"SPMxASL/#description_4","text":"Moves a file to a file, a file to a directory, or a directory to a directory. SBypass inefficient matlab stuff on linux and windows, but can only move on same file system!","title":"Description"},{"location":"SPMxASL/#xasl_trackprogressm","text":"","title":"xASL_TrackProgress.m"},{"location":"SPMxASL/#format_5","text":"xASL_TrackProgress(iCurrent[, iMax])","title":"Format"},{"location":"SPMxASL/#description_5","text":"Counts the percentage of the work done and display on the screen. Either iCurrent of iMax are given. Or only the percentages are given.","title":"Description"},{"location":"SPMxASL/#xasl_adm_convertseconds2timestringm","text":"","title":"xASL_adm_ConvertSeconds2TimeString.m"},{"location":"SPMxASL/#format_6","text":"TimeString = xASL_adm_ConvertSeconds2TimeString(Seconds)","title":"Format"},{"location":"SPMxASL/#description_6","text":"Converts number to time input hh (with minutes in fractions/floating point) -> output hhmm Inverse from xASL_adm_ConvertTime2Nr.","title":"Description"},{"location":"SPMxASL/#xasl_adm_convertslashm","text":"","title":"xASL_adm_ConvertSlash.m"},{"location":"SPMxASL/#format_7","text":"[newString] = xASL_adm_ConvertSlash( StringOriginal,ForceUnix)","title":"Format"},{"location":"SPMxASL/#description_7","text":"Converts Windows forward slashes to backward slashes Prevents confusion file separation & regular expression forward slashes in Windows.","title":"Description"},{"location":"SPMxASL/#xasl_adm_createdirm","text":"","title":"xASL_adm_CreateDir.m"},{"location":"SPMxASL/#format_8","text":"status = xASL_adm_CreateDir(strPath) create all missing subdirs status = xASL_adm_CreateDir(strPath, strBranch) create strBranch (if missing) under existing strPath status = xASL_adm_CreateDir(strPath, nMaxNewDirs) impose limit on the number of new directories","title":"Format"},{"location":"SPMxASL/#description_8","text":"Recursively creates missing directories at the given path or for given subdirectories, with an option to limit the number of newly created directories.","title":"Description"},{"location":"SPMxASL/#xasl_adm_deletefilelistm","text":"","title":"xASL_adm_DeleteFileList.m"},{"location":"SPMxASL/#format_9","text":"filepaths = xASL_adm_DeleteFileList(strDirectory, strRegEx[, bRecurse, nRequired]) xASL_adm_DeleteFileList(strDirectory, strRegEx[, bRecurse, nRequired])","title":"Format"},{"location":"SPMxASL/#description_9","text":"Delete the files that match regular expression STRREGEXP in the given directory STRDIRECTORY. Deletes recursively if specified in BRECURSE. Deletes all files unless the number is specified by NREQUIRED, if the number is not met, then does not delete anything and throws an error.","title":"Description"},{"location":"SPMxASL/#xasl_adm_getfilelistm","text":"","title":"xASL_adm_GetFileList.m"},{"location":"SPMxASL/#format_10","text":"filepaths = xASL_adm_GetFileList(strDirectory[, strRegEx, mode, nRequired, bGetDirNames])","title":"Format"},{"location":"SPMxASL/#description_10","text":"List files or directories from a given path. And optionally uses regular expressions to filter the result with option to set a minimal requirement on the number of results.","title":"Description"},{"location":"SPMxASL/#xasl_adm_gzipniftim","text":"","title":"xASL_adm_GzipNifti.m"},{"location":"SPMxASL/#format_11","text":"pathOut = xASL_adm_GzipNifti(pathIn [,bOverwrite])","title":"Format"},{"location":"SPMxASL/#description_11","text":"Take the input file, zips it, overwriting any existing zipped file and return the path of the zipped file.","title":"Description"},{"location":"SPMxASL/#xasl_adm_managemocomatm","text":"","title":"xASL_adm_ManageMoCoMat.m"},{"location":"SPMxASL/#format_12","text":"xASL_adm_ManageMoCoMat(PathIn)","title":"Format"},{"location":"SPMxASL/#description_12","text":"This function manages the orientation matrices that SPM puts in an external .mat sidecar file if there are more than 1 volumes. The first volume should be equal to the orientation header of the NIfTI, if not, we assume that the NIfTI header is correct. This function performs several checks & corrects if necessary, combined with throwing a warning: A) the nVolumes in .mat & .nii image should be equal, if not, delete sidecar B) .mat should have more than one volume, if not delete sidecar C) If there are illegal numbers in the diagonal of the .mat orientation matrices (here only checked for zeros or non finite values) then the .mat is removed D) If this is true for the first volume only, the .mat is retained but the first volume orientation is overwritten with a zero matrix","title":"Description"},{"location":"SPMxASL/#xasl_adm_unixpathm","text":"","title":"xASL_adm_UnixPath.m"},{"location":"SPMxASL/#format_13","text":"[PathIs] = xASL_adm_UnixPath(PathIs[, bTryWSL])","title":"Format"},{"location":"SPMxASL/#description_13","text":"This function performs the following steps to convert a path to a path that is compatible with the Unix-filesystem as used in e.g. Linux/MacOS. It also has special support for Windows Subsystem for Linux (WSL), though this should only be activated specifically for WSL calls. Note that we want to use this function for most Unix calls (to fix paths), but in the case of WSL only for some calls, where Matlab in Windows calls Linux-code through WSL (e.g. for FSL) - these have to be explicitly specified by the bTryWSL option. Skip this function without Unix-filesystem Trim whitespace Selectively convert forward to backward slashes (ignore already escaped whitespace) Escape characters and residual whitespaces (ignore already escaped whitespaces) If WSL: add mounting prefix","title":"Description"},{"location":"SPMxASL/#xasl_adm_unzipniftim","text":"","title":"xASL_adm_UnzipNifti.m"},{"location":"SPMxASL/#format_14","text":"pathOut = xASL_adm_UnzipNifti(pathIn[, bOverwrite])","title":"Format"},{"location":"SPMxASL/#description_14","text":"Takes the input file, unzips if needed, delete the zipped file and return the path to the unzipped file. If the input is already unzipped, then does nothing, but returns the original filename - so it can be run just to be sure a file is unzipped without much overhead. Returns error if more than one file is in the archive, if the filename does not exist, is a directory etc. If there's a NII and NII.GZ already existing, then return error, or just overwrite in case overwrite is set to 1","title":"Description"},{"location":"SPMxASL/#xasl_adm_zipfilenamehandlingm","text":"","title":"xASL_adm_ZipFileNameHandling.m"},{"location":"SPMxASL/#format_15","text":"[srcOut, dstOut] = xASL_adm_ZipFileNameHandling(srcIn, dstIn)","title":"Format"},{"location":"SPMxASL/#description_15","text":"Adjusts the source and destination filenames of a nifti file to reflect if NII or NII.GZ exist on the input. If either .nii or .nii.gz is corrupt, it automatically deletes the corrupt one and keeps the healthy one, while reporting a warning. This happens when you restart the pipeline after it crashed, if it crashed while unzipping.","title":"Description"},{"location":"SPMxASL/#xasl_bids_csv2tsvreadwritem","text":"","title":"xASL_bids_csv2tsvReadWrite.m"},{"location":"SPMxASL/#format_16","text":"[PathTSV, CellContents] = xASL_bids_csv2tsvReadWrite(PathIn[, bDeleteCSV, bWriteTSV])","title":"Format"},{"location":"SPMxASL/#description_16","text":"This function PathIn and loads it, also trying CSV or TSV extensions if these exist. It outputs the contents to a cell array. If a CSV file exists but not a TSV file, it converts and replaces the CSV to TSV file, per BIDS. This function has the following parts: Read the CSV or TSV file Write the TSV file (if requested) Delete the CSV file (if requested)","title":"Description"},{"location":"SPMxASL/#xasl_csvreadm","text":"","title":"xASL_csvRead.m"},{"location":"SPMxASL/#format_17","text":"[CellContents] = xASL_csvRead(PathCSV)","title":"Format"},{"location":"SPMxASL/#description_17","text":"This function loads a comma-separated value (csv) file - which is the format that BIDS prefers - and outputs it to a cell array.","title":"Description"},{"location":"SPMxASL/#xasl_csvwritem","text":"","title":"xASL_csvWrite.m"},{"location":"SPMxASL/#format_18","text":"xASL_csvWrite(InputCell, PathCSV, bOverwrite)","title":"Format"},{"location":"SPMxASL/#description_18","text":"Rudimentary function, please use xASL_tsvWrite instead. For usage, type help xASL_tsvWrite. This function will still work though.","title":"Description"},{"location":"SPMxASL/#xasl_deletem","text":"","title":"xASL_delete.m"},{"location":"SPMxASL/#format_19","text":"xASL_delete(InputPath)","title":"Format"},{"location":"SPMxASL/#description_19","text":"Delete the file in the given path. If a NIFTI file with extension '.nii' or '.nii.gz' is given, Then delete both the .nii and .nii.gz files.","title":"Description"},{"location":"SPMxASL/#xasl_existm","text":"","title":"xASL_exist.m"},{"location":"SPMxASL/#format_20","text":"xASL_exist(PathIn[,Type])","title":"Format"},{"location":"SPMxASL/#description_20","text":"Check if the given path exists, wrapper around the Matlab exist function, to allow checking for either .nii or .nii.gz Otherwise, exist is used normally.","title":"Description"},{"location":"SPMxASL/#xasl_filepartsm","text":"","title":"xASL_fileparts.m"},{"location":"SPMxASL/#format_21","text":"[Fpath, Ffile, Fext] = xASL_fileparts(InputPath)","title":"Format"},{"location":"SPMxASL/#description_21","text":"Returns the path, file name, and file extension for InputPath using the fileparts.m function. If a file ending at nii.gz is given, then the whole nii.gz is returned as the extension. Does not verify the existence of the file, or existence of .nii or .nii.gz","title":"Description"},{"location":"SPMxASL/#xasl_im_convertmap2maskm","text":"","title":"xASL_im_ConvertMap2Mask.m"},{"location":"SPMxASL/#format_22","text":"[IMout] = xASL_im_ConvertMap2Mask(IMin)","title":"Format"},{"location":"SPMxASL/#description_22","text":"Provides a robust way of conversion of a continuous map to a binary mask, which can be used for lesions, ROIs, or tissue probability maps. Based on the assumption that a map should be thresholded at 50% to form a map, which is often the case for automatic segmentations.","title":"Description"},{"location":"SPMxASL/#xasl_im_distancetransformm","text":"","title":"xASL_im_DistanceTransform.m"},{"location":"SPMxASL/#format_23","text":"[dist, x, y, z] = xASL_im_DistanceTransform(im)","title":"Format"},{"location":"SPMxASL/#description_23","text":"Calculates the distance transform in a binary image Uses Borgefors Chamfers computation of Euclidean distance in 3D using a 5x5x5 window.","title":"Description"},{"location":"SPMxASL/#xasl_im_fillnansm","text":"","title":"xASL_im_FillNaNs.m"},{"location":"SPMxASL/#format_24","text":"xASL_im_FillNaNs(InputPath[, UseMethod, bQuality])","title":"Format"},{"location":"SPMxASL/#description_24","text":"This function fills any NaNs in an image. In SPM, any voxels outside the boundary box/field of view are filled by NaNs when resampling. These NaNs can confuse some algorithms, hence it doesn't hurt replacing them in some cases (e.g. for flowfields). Also, smoothing restricted in a mask is done in ExploreASL with the function xASL_im_ndnanfilter, after first setting all voxels outside the mask to NaN. In this case, this functon can be useful to extrapolate the smoothed image to avoid any division artifact near brain edges (e.g. for reducing the M0 image to a smooth biasfield). This function performs the following 3 steps: Load image Replace NaNs Save image","title":"Description"},{"location":"SPMxASL/#xasl_im_lesionremoval4catm","text":"","title":"xASL_im_LesionRemoval4CAT.m"},{"location":"SPMxASL/#format_25","text":"[Ycls, LesionImOut] = xASL_im_LesionRemoval4CAT(Ycls, PathIn)","title":"Format"},{"location":"SPMxASL/#description_25","text":"For all lesion masks in the anatomical directory, remove them from the current segmentations.","title":"Description"},{"location":"SPMxASL/#xasl_im_resampleimm","text":"","title":"xASL_im_ResampleIM.m"},{"location":"SPMxASL/#format_26","text":"[imOut] = xASL_im_ResampleIM(imIn, matIn, matOut, dimOut[, interpolationType])","title":"Format"},{"location":"SPMxASL/#description_26","text":"Resamples an input image imIn oriented according to the homogeneous matrix matIn to and output image imOut that has dimension dimOut and matrix matOut. This allows to resample images between two spaces with different orientation and matrix sizes. It uses the Matlab interp3 function and the interpolation method used by this method can be chosen. Note that the recommended use of this function is resampling between space with similar resolution or upsampling. For downsampling, simple interpolation does not delivery correct results respecting the point-spread-function and a combination of xASL_im_PreSmooth and xASL_spm_reslice should be used instead.","title":"Description"},{"location":"SPMxASL/#xasl_im_saveoriginal4catm","text":"","title":"xASL_im_SaveOriginal4CAT.m"},{"location":"SPMxASL/#format_27","text":"xASL_im_SaveOriginal4CAT(Ycls, PathIn)","title":"Format"},{"location":"SPMxASL/#description_27","text":"Save the segmentation before lesion masking.","title":"Description"},{"location":"SPMxASL/#xasl_im_conv3dsepm","text":"","title":"xASL_im_conv3Dsep.m"},{"location":"SPMxASL/#format_28","text":"[imConv] = xASL_mex_conv3Dsep(im,kX,[kY,kZ])","title":"Format"},{"location":"SPMxASL/#description_28","text":"3D separable convolution with a supplied kernel It converts the results to double Returned is the convoluted image The wrapper makes sure that kX are Nx1 format, removes nan, and removes excessive zeros at the ends.","title":"Description"},{"location":"SPMxASL/#xasl_im_ndnanfilterm","text":"","title":"xASL_im_ndnanfilter.m"},{"location":"SPMxASL/#format_29","text":"[Y,fil] = xASL_im_ndnanfilter(X,filterType,F,WNAN)","title":"Format"},{"location":"SPMxASL/#description_29","text":"This function applies a 3-dimensional convolution of X with given kernel. NaNs elements are taken into account (ignored). By default, edges are not padded and one-sided filter is used at the image edges. Notes: * Accepts empty value for any input. When X is empty, the program can be used as a N-dimensional window generator. * NaNs elements surrounded by no-NaNs elements (which will depend on window width) are the ones that will be interpolated. The others are leaved untouched. * When WNAN=2, the programs acts like an NAN-interpolat/GAP-filling, leaving untouched the no-NaNs elements but the filtering is perfomed anyway. I recommend the default behaviour (WNAN=0) in order to keep the filtered data in the workspace, and then use the code at the end of this function to get/remove the interpolated NaNs * To achieve similar results as ndnanfilter previously, use same F as with the 'rect' filter. * Note that the FWHM of Gaussian is given in VOXELS, not in mm * For the Gaussian filter, use (previous N, new FWHM) N= 1 ~ FWHM 0.94 N= 2 ~ FWHM 1.885 N= 4 ~ FWHM 3.76 N= 6 ~ FWHM 5.652 N= 8 ~ FWHM 7.536 N=10 ~ FWHM 9.42 N=12 ~ FWHM 11.3 N=16 ~ FWHM 15.07 N=20 ~ FWHM 18.84 N=10/2.355 ~ FWHM 4 Basically divide by 1.06","title":"Description"},{"location":"SPMxASL/#xasl_io_nifti2imm","text":"","title":"xASL_io_Nifti2Im.m"},{"location":"SPMxASL/#format_30","text":"imOut = xASL_io_Nifti2Im(niftiIn [, ImageSize])","title":"Format"},{"location":"SPMxASL/#description_30","text":"This function loads a NIfTI image matrix with flexible input (as explained under INPUT: niftiIn). It does the following. Try to load a NIfTI If NIfTI successfully loaded, try to load the NIfTI image If the above didnt work, try to create a dummy image Convert to single precision data format Also able to load NIfTI as .nii.mat format","title":"Description"},{"location":"SPMxASL/#xasl_io_readniftim","text":"","title":"xASL_io_ReadNifti.m"},{"location":"SPMxASL/#format_31","text":"[NiftiObject, pathIn] = xASL_io_ReadNifti(pathIn)","title":"Format"},{"location":"SPMxASL/#description_31","text":"Read Nifti file given by the path. Return the NII object. And also return the actual path to the loaded Nifti if by any reason the name changed during the function runtime (e.g. unzipping).","title":"Description"},{"location":"SPMxASL/#xasl_io_saveniftim","text":"","title":"xASL_io_SaveNifti.m"},{"location":"SPMxASL/#format_32","text":"xASL_io_SaveNifti(pathOrigNifti, pathNewNifti, imNew[, nBits, bGZip, newMat])","title":"Format"},{"location":"SPMxASL/#description_32","text":"It loads the pathOrigNifti, takes all the parameters from it, and creates a new Nifti file with these parameters, but new image matrix from imNew. It saves the result in pathNewNifti.","title":"Description"},{"location":"SPMxASL/#xasl_roundm","text":"","title":"xASL_round.m"},{"location":"SPMxASL/#format_33","text":"[OutputN] = xASL_round(InputN[, PrecisionN])","title":"Format"},{"location":"SPMxASL/#description_33","text":"Recent Matlab versions support a second input that specifies that number of decimals to round at, but earlier Matlab versions do not support this. For backward compatibility, use this wrapper instead of round.","title":"Description"},{"location":"SPMxASL/#xasl_spm_adminm","text":"","title":"xASL_spm_admin.m"},{"location":"SPMxASL/#format_34","text":"[InPath] = xASL_spm_admin(InPath, bPadComma1)","title":"Format"},{"location":"SPMxASL/#description_34","text":"Force ,1 at end of IMname. This is useful for refIM/srcIM in CoregInit, OldNormalizeWrapper etc.","title":"Description"},{"location":"SPMxASL/#xasl_spm_reslicem","text":"","title":"xASL_spm_reslice.m"},{"location":"SPMxASL/#format_35","text":"xASL_spm_reslice(refPath, srcPath[, srcAffinePath, bInvAffine, bQuality, NewName, InterpolationPar])","title":"Format"},{"location":"SPMxASL/#description_35","text":"This wrapper runs SPM's reslice function (a.k.a. coregister: reslice) which resamples a source image into the space of a reference image, taking into account any orientation differences between the two images that are defined in the orientation matrix in the NIfTI header. When the source image contains multiple volumes, they are all resampled. The source image will get the same orientation matrix as the reference image, as it is now in the same space as the reference image. This can be useful when two images are to be compared voxel-by-voxel, e.g. when overlaying a CBF image over a structural image, or when wanting to use a mask from a different space. When after running this function, the reference and source images are not in alignment, they need to be registered first (i.e. xASL_spm_register). Resampling/reslicing needs an interpolation method to know from which voxels of the source image, a voxel in the new image will be computed. A simplistic explanation is that this determines the number of surrounding neighborhood voxels it uses to determine the new voxel value. The example syntax below would reslice/resample the CBF image to the T1w space (assuming the Affine was done to register CBF to T1w) It also works with the external .mat file of the source file that has the same name as the source file. It also can optionally take a _sn.mat containing the affine transformation information.","title":"Description"},{"location":"SPMxASL/#xasl_spm_smoothm","text":"","title":"xASL_spm_smooth.m"},{"location":"SPMxASL/#format_36","text":"xASL_spm_smooth(pathIn, fwhmSmooth[, pathNew])","title":"Format"},{"location":"SPMxASL/#description_36","text":"This SPM wrapper runs SPM's smooth function, which spatially smooths the input image with a Gaussian kernel. In the case of multiple volumes (i.e. a 4D NIfTI), each 3D volume is spatially smoothed separately. Note that smoothnesses combine with Pythagoras' rule (i.e. sum quadratically)","title":"Description"},{"location":"SPMxASL/#xasl_stat_meannanm","text":"","title":"xASL_stat_MeanNan.m"},{"location":"SPMxASL/#format_37","text":"y = xASL_stat_MeanNan(x[,dim])","title":"Format"},{"location":"SPMxASL/#description_37","text":"It calculates the sum using the SUM functions and divides by the number of values but ignoring NaNs.","title":"Description"},{"location":"SPMxASL/#xasl_stat_mediannanm","text":"","title":"xASL_stat_MedianNan.m"},{"location":"SPMxASL/#format_38","text":"y = xASL_stat_MedianNan(x[,dim])","title":"Format"},{"location":"SPMxASL/#description_38","text":"It calculates the MEDIAN along the given dimension, but it sets all the NaNs to zero before calling it.","title":"Description"},{"location":"SPMxASL/#xasl_tsvreadm","text":"","title":"xASL_tsvRead.m"},{"location":"SPMxASL/#format_39","text":"[CellContents] = xASL_tsvRead(PathTSV[, bStruct])","title":"Format"},{"location":"SPMxASL/#description_39","text":"This function loads a tab-separated value (TSV) file - which is the format that BIDS prefers - and outputs it to a cell array.","title":"Description"},{"location":"SPMxASL/#xasl_tsvwritem","text":"","title":"xASL_tsvWrite.m"},{"location":"SPMxASL/#format_40","text":"xASL_tsvWrite(InputCell, PathTSV[, bOverwrite, bCSV])","title":"Format"},{"location":"SPMxASL/#description_40","text":"This function loads a cell array and prints it to a tab-separated value (TSV) file, which is the format that BIDS prefers.","title":"Description"},{"location":"SPMxASL/#xasl_wrp_dartelsaveintermedtransm","text":"","title":"xASL_wrp_DARTELSaveIntermedTrans.m"},{"location":"SPMxASL/#format_41","text":"xASL_wrp_DARTELSaveIntermedTrans(Yy, u, odim, rdim, idim, Mar, mat, M0, M1, nameOut, numIteration)","title":"Format"},{"location":"SPMxASL/#description_41","text":"This function is called from the CAT12 segmentation function to save the intermediate results of the DARTEL transformation. Normally, the registration only saves the final results - the final transformation field. This function enables to save also the intermediate transformation field. It takes all the internal variables from the transformation and save the field to a sub-directory 'mri' that normally contains all the intermediate results of the CAT12 segmentation. It adds a 'y_' prefix and adds the specified iteration number as postfix.","title":"Description"},{"location":"SPMxASL/#xasl_wrp_gssaveintermedtransm","text":"","title":"xASL_wrp_GSSaveIntermedTrans.m"},{"location":"SPMxASL/#format_42","text":"xASL_wrp_GSSaveIntermedTrans(y, idim, odim, rdim, M0, M1, R, M1t, M1r, nameOut, numIteration)","title":"Format"},{"location":"SPMxASL/#description_42","text":"This function is called from the CAT12 segmentation function to save the intermediate results of the Geodesic shooting transformation. Normally, the registration only saves the final results - the final transformation field. This function enables to save also the intermediate transformation field. It takes all the internal variables from the transformation and save the field to a sub-directory 'mri' that normally contains all the intermediate results of the CAT12 segmentation. It adds a 'y_' prefix and adds the specified iteration number as postfix.","title":"Description"},{"location":"Structural_Module/","text":"Submodules of the Structural Module xASL_wrp_CleanUpWMH_SEGM.m Format xASL_wrp_CleanUpWMH_SEGM(x) Description This submodule aims to clean up WMH under- or oversegmentations in a conservatively & robust way, i.e. erring on the side of caution. It uses input from the tissue class segmentation (e.g. CAT12) to repair the WMH segmentation (e.g. LST LPA/LGA or externally provided). Note that before running the tissue segmentation, the T1w was (conservatively) filled for WMH lesions. % This function is not tested a lot, so mainly conservatively set up to improve the WMH volumetrics, rather than improve the registration. This submodule contains the following steps: Administration Correct pGM islands inside pWM WMH can have an intensity similar to GM on the T1w, which erroneously classifies them as GM instead of WM(H). The rule used here, is to define GM islands within the WM as clusters of pGM>0.05 for which 3 layers (dilations) have at least 95% pWM. For these islands, pGM is given 100% to pWM. 50% of pWM is given to pWMH (the pWMH/pNAWM distinction is made later in the pipeline, here still pWM=pWMH+pNAWM). The reason is that not all low T1w intensities within the WM are WMH, we still expect some lacunes, perivascular (Virchow-Robin) spaces, which could be considered pNAWM rather than pWMH. Perform brainmasking & join masks Correct any WMH inside GM or CSF -> here we assume that CAT12 did a good segmentation job. If pGM is larger than pWM & larger than pWMH, we consider a voxel to be pGM and remove the pWMH. This effectively removes pWMH segmentation noise in the GM or CSF, it doesn't correct any significant misclassification of WMH in the GM or CSF. If the WMH segmentation does a significant misclassification (e.g. setting the pWMH inside GM or CSF to a probability higher than GM or CSF is by tissue segmentation), this is lesion filled after the WMH segmentation, on the T1w, hence the tissue segmentation won't have a chance to correct this. Fortunately, most oversegmentations in the GM/CSF have low pWMH, as WMH segmentation algorithms already perform a light tissue prior-based clean up themselves. Saving & file management Prepare visuals for visual QC & file management xASL_wrp_FLAIR_BiasfieldCorrection.m Format xASL_wrp_FLAIR_BiasfieldCorrection(x) Description This submodule performs a biasfield correction on T1w and applies it on FLAIR. This can be useful, when there are large lesions on the FLAIR that hamper capturing the biasfield nicely on the FLAIR itself. In such cases, the biasfield of the T1w might be easier to obtain and should be the same as the FLAIR, provided they are scanned in the same scan session (i.e.g same scanner, same coil). BE CAREFUL: this submodule assumes that the biasfields of the T1w and FLAIR are comparable, which is not the case when one of the two (or both) are already biasfield corrected. xASL_wrp_GetVolumetrics.m Format xASL_wrp_GetVolumetrics(x) Description This submodule computes the total volume for each of the tissue classes & stores them in a TSV file (per BIDS). This is computed from the native space segmentation derivatives (GM, WM & CSF), from which the ICV & relative volumes can be calculated. This is performed for CAT12 or SPM12 (whichever was used), and optionally for a WMH_SEGM. xASL_wrp_LST_Segment_FLAIR_WMH.m Format xASL_wrp_LST_Segment_FLAIR_WMH(x, rWMHPath[, WMHsegmAlg]) Description This submodule runs the LST WMH segmentation, either with LGA or LPA. LPA is the default choice, it outperforms LGA a bit, depending on the image quality. These algorithms perform optimally with 3T images, with good contrast. Generally, LPA oversegments whereas LGA undersegments. The LPA oversegmentation is corrected in a later submodule. If a WMH_SEGM already existed, the LST is run quickly as dummy only, to be replaced by the original WMH_SEGM image. This function has the following parts: Resample FLAIR (& WMH_SEGM, if exists) to T1w space where we assume WMH_SEGM_ORI == FLAIR space (if externally provided) WMH_SEGM == T1w space Define parameters for segmentation Run the segmentation Replace by already existing WMH_SEGM File management Remove NaNs from segmentations & fix image edges Remove lesion masks from WMH_SEGM xASL_wrp_LST_T1w_LesionFilling_WMH.m Format xASL_wrp_LST_T1w_LesionFilling_WMH(x) Description This submodule runs the LST WMH-based T1w lesion filling, which should improve the registration & segmentation of the T1w by e.g. CAT12/SPM12. The WMH can be either segmented in the previous submodule by LST LGA/LPGA or provided externally. Before lesion filling, we clean up the WMH segmentation, to make the lesion filling a bit more conservative. Sometimes the WMH segmentation oversegments inside the GM (as there can be hyperintensities on the FLAIR) & we don't want to lesion-fill these on the T1w (which would turn their intensities in intensities similar to WM, leading to misclassifications by the T1w segmentation). Note that this is submodule only performs the lesion filling, and the clean up is also performed for the lesion filling only. A more thorough WMH clean up (for e.g. WMH volumetrics) is performed later in the Structural module, using also the results from the T1w segmentation. Note when changing the lesion filling here, LST lesion filling expects a probability map, doesnt work nicely with binary mask This function runs the following steps: File management Clean up the WMH segmentation used for lesion filling Run lesion filling Correction of too much/erronous lesion filling File management xASL_wrp_LinearReg_FLAIR2T1w.m Format xASL_wrp_LinearReg_FLAIR2T1w(x[, bAutoACPC]) Description This submodule registers FLAIR linearly to the T1w The same transformation is applied to all other related scans (FLAIR-segmented lesions, WMH specifically or other lesions) This is required to enable the application of T1w derivatives (e.g. transformations to standard space, tissue segmentation) for FLAIR and vice versa (e.g. WMH lesion-filling). xASL_wrp_LinearReg_T1w2MNI.m Format xASL_wrp_LinearReg_T1w2MNI(x[, bAutoACPC]) Description This submodule registers T1w linearly to the center of MNI space, a.k.a. ACPC alignment The same transformation is applied to all other related scans (ASL4D, M0, FLAIR, etc.) This facilitates MNI-based algorithms (e.g. SPM-based segmentation), and allows for visual QC with all images roughly in the same space. This submodule first clips high values that can bias the registration algorithm, then performs a center of mass-based ACPC alignment, and then several iterations of SPM coregistration. Assuming that this submodule is run at the start of ExploreASL, all NIfTI orientation matrices are restored before running the registration. xASL_wrp_Resample2StandardSpace.m Format xASL_wrp_Resample2StandardSpace(x) Description This submodule resamples all structural images & their derivatives to standard space. It uses the transformation fields that were obtained previously in the Structural module, concatenates all transformations into a single transformation (if not already done) & applies the transformation with a single interpolation (either trilinear for low quality or probability maps, or 2nd order B-spline). Finally, it computes the Jacobian determinants (i.e. the derivative of the transformation field) to obtain a map of the volumetric effects of the transformation. This Jacobian map is multiplied with the standard space resampled images, to restore their (local & global) total volume. The sum of volumes in native & standard space are compared as QC. This submodule is not only part of the structural module, but can be repeated when the transformation map is edited, e.g. after longitudinal registration or after creation of a group-wise template. xASL_wrp_SegmentT1w.m Format [x] = xASL_wrp_SegmentT1w(x, SegmentSPM12) Description This submodule segments high resolution structural/anatomical scans into GM/WM/CSF/soft tissue/bone/air tissue classes. It will save GM/WM/CSF in native space, and the transformation from native to standard space. This transformation includes Geodesic Shooting/DARTEL for CAT12. This submodule contains the following steps: Administration Extra segmentation options by Jan Petr Segmentation using CAT12 -> If CAT12 fails, it will be repeated with higher contrast, higher strength affine preprocessing & less biasfield regularization -> If CAT12 fails twice, it will be skipped & SPM12 will be run Segmentation using SPM12 File management CAT12 File management lesions Resample lesions to standard space -> for the lesion masking. MORE EXPLANATION NEEDED BY JAN Manage flowfields -> smooth combination non-linear flowfield outside the lesion & uniform flowfield within the lesion File management xASL_wrp_VisualQC_Structural.m Format xASL_wrp_VisualQC_Structural(x) Description This submodule performs several visualizations for visual & quantitative QC. After initial admin It starts with the SPM UP parameters (courtesy of Cyril Pernet, his SPM UP scripts were made more robust & accurate by Jan & Henk, & are implemented here for T1w (& optionally FLAIR). Then it performs a collection of visualizations Also repeated specifically for lesions & manually provided ROIs Finally, this contains a report of all missing raw & derivative files, in native & standard space, printing the NIfTI orientation matrix content before (hdr.mat0) & after registrations (hdr.mat) The determinant of these matrices should be the same, otherwise LeftRight has flipped. This should also be the same across a group scanned at the same scanner Then various other QC functions are called & all are summarized in a PDF report.","title":"Module Structural"},{"location":"Structural_Module/#submodules-of-the-structural-module","text":"","title":"Submodules of the Structural Module"},{"location":"Structural_Module/#xasl_wrp_cleanupwmh_segmm","text":"","title":"xASL_wrp_CleanUpWMH_SEGM.m"},{"location":"Structural_Module/#format","text":"xASL_wrp_CleanUpWMH_SEGM(x)","title":"Format"},{"location":"Structural_Module/#description","text":"This submodule aims to clean up WMH under- or oversegmentations in a conservatively & robust way, i.e. erring on the side of caution. It uses input from the tissue class segmentation (e.g. CAT12) to repair the WMH segmentation (e.g. LST LPA/LGA or externally provided). Note that before running the tissue segmentation, the T1w was (conservatively) filled for WMH lesions. % This function is not tested a lot, so mainly conservatively set up to improve the WMH volumetrics, rather than improve the registration. This submodule contains the following steps: Administration Correct pGM islands inside pWM WMH can have an intensity similar to GM on the T1w, which erroneously classifies them as GM instead of WM(H). The rule used here, is to define GM islands within the WM as clusters of pGM>0.05 for which 3 layers (dilations) have at least 95% pWM. For these islands, pGM is given 100% to pWM. 50% of pWM is given to pWMH (the pWMH/pNAWM distinction is made later in the pipeline, here still pWM=pWMH+pNAWM). The reason is that not all low T1w intensities within the WM are WMH, we still expect some lacunes, perivascular (Virchow-Robin) spaces, which could be considered pNAWM rather than pWMH. Perform brainmasking & join masks Correct any WMH inside GM or CSF -> here we assume that CAT12 did a good segmentation job. If pGM is larger than pWM & larger than pWMH, we consider a voxel to be pGM and remove the pWMH. This effectively removes pWMH segmentation noise in the GM or CSF, it doesn't correct any significant misclassification of WMH in the GM or CSF. If the WMH segmentation does a significant misclassification (e.g. setting the pWMH inside GM or CSF to a probability higher than GM or CSF is by tissue segmentation), this is lesion filled after the WMH segmentation, on the T1w, hence the tissue segmentation won't have a chance to correct this. Fortunately, most oversegmentations in the GM/CSF have low pWMH, as WMH segmentation algorithms already perform a light tissue prior-based clean up themselves. Saving & file management Prepare visuals for visual QC & file management","title":"Description"},{"location":"Structural_Module/#xasl_wrp_flair_biasfieldcorrectionm","text":"","title":"xASL_wrp_FLAIR_BiasfieldCorrection.m"},{"location":"Structural_Module/#format_1","text":"xASL_wrp_FLAIR_BiasfieldCorrection(x)","title":"Format"},{"location":"Structural_Module/#description_1","text":"This submodule performs a biasfield correction on T1w and applies it on FLAIR. This can be useful, when there are large lesions on the FLAIR that hamper capturing the biasfield nicely on the FLAIR itself. In such cases, the biasfield of the T1w might be easier to obtain and should be the same as the FLAIR, provided they are scanned in the same scan session (i.e.g same scanner, same coil). BE CAREFUL: this submodule assumes that the biasfields of the T1w and FLAIR are comparable, which is not the case when one of the two (or both) are already biasfield corrected.","title":"Description"},{"location":"Structural_Module/#xasl_wrp_getvolumetricsm","text":"","title":"xASL_wrp_GetVolumetrics.m"},{"location":"Structural_Module/#format_2","text":"xASL_wrp_GetVolumetrics(x)","title":"Format"},{"location":"Structural_Module/#description_2","text":"This submodule computes the total volume for each of the tissue classes & stores them in a TSV file (per BIDS). This is computed from the native space segmentation derivatives (GM, WM & CSF), from which the ICV & relative volumes can be calculated. This is performed for CAT12 or SPM12 (whichever was used), and optionally for a WMH_SEGM.","title":"Description"},{"location":"Structural_Module/#xasl_wrp_lst_segment_flair_wmhm","text":"","title":"xASL_wrp_LST_Segment_FLAIR_WMH.m"},{"location":"Structural_Module/#format_3","text":"xASL_wrp_LST_Segment_FLAIR_WMH(x, rWMHPath[, WMHsegmAlg])","title":"Format"},{"location":"Structural_Module/#description_3","text":"This submodule runs the LST WMH segmentation, either with LGA or LPA. LPA is the default choice, it outperforms LGA a bit, depending on the image quality. These algorithms perform optimally with 3T images, with good contrast. Generally, LPA oversegments whereas LGA undersegments. The LPA oversegmentation is corrected in a later submodule. If a WMH_SEGM already existed, the LST is run quickly as dummy only, to be replaced by the original WMH_SEGM image. This function has the following parts: Resample FLAIR (& WMH_SEGM, if exists) to T1w space where we assume WMH_SEGM_ORI == FLAIR space (if externally provided) WMH_SEGM == T1w space Define parameters for segmentation Run the segmentation Replace by already existing WMH_SEGM File management Remove NaNs from segmentations & fix image edges Remove lesion masks from WMH_SEGM","title":"Description"},{"location":"Structural_Module/#xasl_wrp_lst_t1w_lesionfilling_wmhm","text":"","title":"xASL_wrp_LST_T1w_LesionFilling_WMH.m"},{"location":"Structural_Module/#format_4","text":"xASL_wrp_LST_T1w_LesionFilling_WMH(x)","title":"Format"},{"location":"Structural_Module/#description_4","text":"This submodule runs the LST WMH-based T1w lesion filling, which should improve the registration & segmentation of the T1w by e.g. CAT12/SPM12. The WMH can be either segmented in the previous submodule by LST LGA/LPGA or provided externally. Before lesion filling, we clean up the WMH segmentation, to make the lesion filling a bit more conservative. Sometimes the WMH segmentation oversegments inside the GM (as there can be hyperintensities on the FLAIR) & we don't want to lesion-fill these on the T1w (which would turn their intensities in intensities similar to WM, leading to misclassifications by the T1w segmentation). Note that this is submodule only performs the lesion filling, and the clean up is also performed for the lesion filling only. A more thorough WMH clean up (for e.g. WMH volumetrics) is performed later in the Structural module, using also the results from the T1w segmentation. Note when changing the lesion filling here, LST lesion filling expects a probability map, doesnt work nicely with binary mask This function runs the following steps: File management Clean up the WMH segmentation used for lesion filling Run lesion filling Correction of too much/erronous lesion filling File management","title":"Description"},{"location":"Structural_Module/#xasl_wrp_linearreg_flair2t1wm","text":"","title":"xASL_wrp_LinearReg_FLAIR2T1w.m"},{"location":"Structural_Module/#format_5","text":"xASL_wrp_LinearReg_FLAIR2T1w(x[, bAutoACPC])","title":"Format"},{"location":"Structural_Module/#description_5","text":"This submodule registers FLAIR linearly to the T1w The same transformation is applied to all other related scans (FLAIR-segmented lesions, WMH specifically or other lesions) This is required to enable the application of T1w derivatives (e.g. transformations to standard space, tissue segmentation) for FLAIR and vice versa (e.g. WMH lesion-filling).","title":"Description"},{"location":"Structural_Module/#xasl_wrp_linearreg_t1w2mnim","text":"","title":"xASL_wrp_LinearReg_T1w2MNI.m"},{"location":"Structural_Module/#format_6","text":"xASL_wrp_LinearReg_T1w2MNI(x[, bAutoACPC])","title":"Format"},{"location":"Structural_Module/#description_6","text":"This submodule registers T1w linearly to the center of MNI space, a.k.a. ACPC alignment The same transformation is applied to all other related scans (ASL4D, M0, FLAIR, etc.) This facilitates MNI-based algorithms (e.g. SPM-based segmentation), and allows for visual QC with all images roughly in the same space. This submodule first clips high values that can bias the registration algorithm, then performs a center of mass-based ACPC alignment, and then several iterations of SPM coregistration. Assuming that this submodule is run at the start of ExploreASL, all NIfTI orientation matrices are restored before running the registration.","title":"Description"},{"location":"Structural_Module/#xasl_wrp_resample2standardspacem","text":"","title":"xASL_wrp_Resample2StandardSpace.m"},{"location":"Structural_Module/#format_7","text":"xASL_wrp_Resample2StandardSpace(x)","title":"Format"},{"location":"Structural_Module/#description_7","text":"This submodule resamples all structural images & their derivatives to standard space. It uses the transformation fields that were obtained previously in the Structural module, concatenates all transformations into a single transformation (if not already done) & applies the transformation with a single interpolation (either trilinear for low quality or probability maps, or 2nd order B-spline). Finally, it computes the Jacobian determinants (i.e. the derivative of the transformation field) to obtain a map of the volumetric effects of the transformation. This Jacobian map is multiplied with the standard space resampled images, to restore their (local & global) total volume. The sum of volumes in native & standard space are compared as QC. This submodule is not only part of the structural module, but can be repeated when the transformation map is edited, e.g. after longitudinal registration or after creation of a group-wise template.","title":"Description"},{"location":"Structural_Module/#xasl_wrp_segmentt1wm","text":"","title":"xASL_wrp_SegmentT1w.m"},{"location":"Structural_Module/#format_8","text":"[x] = xASL_wrp_SegmentT1w(x, SegmentSPM12)","title":"Format"},{"location":"Structural_Module/#description_8","text":"This submodule segments high resolution structural/anatomical scans into GM/WM/CSF/soft tissue/bone/air tissue classes. It will save GM/WM/CSF in native space, and the transformation from native to standard space. This transformation includes Geodesic Shooting/DARTEL for CAT12. This submodule contains the following steps: Administration Extra segmentation options by Jan Petr Segmentation using CAT12 -> If CAT12 fails, it will be repeated with higher contrast, higher strength affine preprocessing & less biasfield regularization -> If CAT12 fails twice, it will be skipped & SPM12 will be run Segmentation using SPM12 File management CAT12 File management lesions Resample lesions to standard space -> for the lesion masking. MORE EXPLANATION NEEDED BY JAN Manage flowfields -> smooth combination non-linear flowfield outside the lesion & uniform flowfield within the lesion File management","title":"Description"},{"location":"Structural_Module/#xasl_wrp_visualqc_structuralm","text":"","title":"xASL_wrp_VisualQC_Structural.m"},{"location":"Structural_Module/#format_9","text":"xASL_wrp_VisualQC_Structural(x)","title":"Format"},{"location":"Structural_Module/#description_9","text":"This submodule performs several visualizations for visual & quantitative QC. After initial admin It starts with the SPM UP parameters (courtesy of Cyril Pernet, his SPM UP scripts were made more robust & accurate by Jan & Henk, & are implemented here for T1w (& optionally FLAIR). Then it performs a collection of visualizations Also repeated specifically for lesions & manually provided ROIs Finally, this contains a report of all missing raw & derivative files, in native & standard space, printing the NIfTI orientation matrix content before (hdr.mat0) & after registrations (hdr.mat) The determinant of these matrices should be the same, otherwise LeftRight has flipped. This should also be the same across a group scanned at the same scanner Then various other QC functions are called & all are summarized in a PDF report.","title":"Description"},{"location":"Tutorials-ASL-BIDS/","text":"Tutorials (ASL-BIDS) ExploreASL & ASL-BIDS Starting with version v1.6.0 , ExploreASL will support an import workflow which allows the user to convert DICOM and NIFTI data to the ASL-BIDS format. Since ExploreASL does not fully utilize the BIDS format internally, there will also be an automated workflow to convert from ASL-BIDS to the ExploreASL legacy format . In the following subsections we will explain how you can use the automated ExploreASL import workflow to convert your data structure to ASL-BIDS and how you can process it. The ExploreASL_Master script will have the following format: [x] = ExploreASL([DataParPath, ImportModules, ProcessModules, bPause, iWorker, nWorkers]) Parameter descriptions: DataParPath : Path to data parameter file ( OPTIONAL ) DataParPath Type CHAR ARRAY Default Prompting user input ImportModules : Multi-step import workflow ( OPTIONAL ) DCM2NII : Run the DICOM to NIFTI conversion NII2BIDS : Run the NIFTI to BIDS conversion ANONYMIZE : Run the defacing and full anonymization BIDS2LEGACY : Run the BIDS to LEGACY conversion ImportModules DCM2NII NII2BIDS ANONYMIZE BIDS2LEGACY Type BOOLEAN BOOLEAN BOOLEAN BOOLEAN Default false false false false ProcessModules : Multi-step processing pipeline ( OPTIONAL ) STRUCTURAL : Run the Structural Module ASL : Run the ASL Module POPULATION : Run the Population Module ProcessModules STRUCTURAL ASL POPULATION Type BOOLEAN BOOLEAN BOOLEAN Default false false false bPause : Pause workflow before ExploreASL pipeline ( OPTIONAL ) bPause Type BOOLEAN Default false iWorker : Allows parallelization when called externally ( OPTIONAL ) iWorker Type INTEGER Default 1 nWorkers : Allows parallelization when called externally ( OPTIONAL ) nWorkers Type INTEGER Default 1 In the following examples, we want to show how you can use the revised import workflow and how the conventional processing is done now. DICOM source data Converting DICOM source data according to the ASL BIDS standard can be done using the new import workflow. For the upcoming release v1.6.0 we're preparing an exemplary DICOM source dataset based on the ASL DRO . To run this workflow, you have to use the path to your sourceStructure.json file instead of the path to your DataPar.json file for the DataParPath input argument. Do not forget to set up the source dataset correctly. You'll be required to define a studyPar.json file as well. We're working on a flavor library, to enable the import and processing of a wide variety of different sequence, vendor, and scanner combinations. The first step to convert your DICOM source data to NIFTI source data is to run the following command: [x] = ExploreASL('sourceStructure.json', [1 0 0 0], 0, 0, 1, 1); Here we tell ExploreASL to run the DCM2NII import module by setting the first boolean variable of the ImportModules to 1 . NIFTI source data Let's assume we have NIFTI source data according to the ASL BIDS standard now. To convert this ASL BIDS source data to ASL BIDS raw data, we have to run the second part of the import workflow. To run the second step, we set the second variable of the ImportModules to 1 . Similar to the previous step, we pass the path to the sourceStructure.json file to ExploreASL . [x] = ExploreASL('sourceStructure.json', [0 1 0 0], 0, 0, 1, 1); Data anonymization There's also a new option to anonymize your data. To do this, you can run the third step of the import workflow. This is done by setting the third variable of the ImportModules to 1 . Similar to the previous steps, we pass the path to the sourceStructure.json file to ExploreASL . [x] = ExploreASL('sourceStructure.json', [0 0 1 0], 0, 0, 1, 1); Data in ExploreASL legacy format Right now, ExploreASL still uses the conventional data structure. To convert our ASL BIDS rawdata to the ExploreASL legacy format, we run the last step of the import workflow. This is done by setting the fourth variable of the ImportModules to 1 . Similar to the previous steps, we pass the path to the sourceStructure.json file to ExploreASL . [x] = ExploreASL('sourceStructure.json', [0 0 0 1], 0, 0, 1, 1); The import workflow will also generate a DataPar.json file. To adapt your pipeline, you can still use the same settings as before, by changing the JSON fields. ExploreASL processing pipeline If you just want to use the conventional ExploreASL processing pipeline, you can simply turn off the import workflow by setting all ImportModules variables to 0 individually or by using a single 0 for the ImportModules . This results in the following notation: [x] = ExploreASL('sourceStructure.json', 0, 1, 0, 1, 1); To run individual modules, you can set the ProcessModules individually. If you only want to the Structural Module for example, you can use a [1 0 0] vector. To run all modules, you can use a single 1 or a vector of ones, which should look like this [1 1 1] . Running the full processing pipeline can therefore be done like this as well: [x] = ExploreASL('sourceStructure.json', 0, [1 1 1], 0, 1, 1); Full pipeline Running the full pipeline including both import workflow and processing pipeline, can be done by setting both ImportModules and ProcessModules to 1 . [x] = ExploreASL('sourceStructure.json', 1, 1, 0, 1, 1); Other tips and tricks Note that we changed both name and behavior of the SkipPause variable. The variable is called bPause now. Setting it to true or 1 , will result in the pipeline being paused before the processing. We removed the iModules , but the functionality of ProcessModules is basically the same. We use boolean notation now, so instead of [1 2 3] you have to use [1 1 1] now. The overall import functionality is a work in progress right now. We expect stable behavior in release v1.6.0 though. If you plan on using the develop branch until then, you have to live with more or less unstable import behavior. The examples shown below are related to versions v1.5.1 and older. They will be updated soon. If you want to work with the current develop version, these examples obviously do not apply anymore. How to run ExploreASL using Matlab The first thing you have to do, to use ExploreASL , is to clone the ExploreASL repository. If you want to run ExploreASL from Matlab, we recommend to clone the main repository directly from the official GitHub website . You also have the option to download the zipped version or to download an older release . If you are new to Matlab, we recommend checking out a Matlab tutorial . It can be helpful to add the ExploreASL directory to your Matlab paths. Open Matlab, select the Home tab, and add the ExploreASL directory including its subfolders using the Set Path option. Now change your working directory, using the Current Folder tab or the cd command, to the ExploreASL directory. To run ExploreASL you have to type in the following command in the Command Window : ExploreASL . If you already created an ASL-BIDS dataset in sourcedata format, you can run the full default ExploreASL pipeline like this: DataParPath = 'C:\\...\\MY-BIDS-DATASET\\DataParFile.json'; ImportModules = true; ProcessModules = true; bPause = false; [x] = ExploreASL_Master(DataParPath, ImportModules, ProcessModules, bPause); How to run a compiled ExploreASL Version To compile ExploreASL you have to run the xASL_adm_MakeStandalone.m script. If necessary, you can also ask the developer team for a specific compiled version. Providing a compiled version for every operating system and corresponding Matlab version is currently not feasible for us. Please feel free to ask us for help though! A compiled version of ExploreASL always requires the corresponding Matlab Runtime. Please checkout the official Matlab Documentation . Download the Matlab Runtime of the Matlab Version which was used for the compilation. Make sure to install the Matlab Runtime correctly. If you're using Windows, it is important that the path to the Matlab Runtime is added to Windows PATH during the installation. Windows Let's assume you want to run the compiled version of ExploreASL latest . Check the contents of the folder created by xASL_adm_MakeStandalone.m , which contains the compiled version. There should be a file called xASL_latest.exe . We recommend using the command line interface now. For this you can go to the address bar of your file explorer. Type in cmd to open the command prompt in the current folder. The following command will start ExploreASL , import the ASL-BIDS dataset in sourcedata format, and process the dataset of your sourceStructure.json file: xASL_latest.exe \"c:\\MY-BIDS-DATASET\\sourceStructure.json\" \"1\" \"1\" The executable will extract all necessary data from the CTF archive within the folder. This is totally normal. Within the command window you should see that ExploreASL is starting to process the given dataset: xASL_latest.exe \"c:\\MY-BIDS-DATASET\\sourceStructure.json\" \"1\" \"1\" (insert example here) To test if it is possible to initialize ExploreASL without the processing of a dataset, you could run the following command: xASL_latest.exe \"\" \"0\" \"0\" The usual ExploreASL parameters ( DataParPath , ImportModules , ProcessModules , bPause , iWorker , nWorkers ) have to be given to the compiled ExploreASL version as strings. The resulting output could look like this: xASL_latest.exe \"\" \"0\" \"0\" (insert example here) Linux On Linux you can basically do the same as above. We can run the ExploreASL shell script with a specified Matlab MCR (here we use version 96 e.g.) using the following command: ./run_xASL_latest.sh /usr/local/MATLAB/MATLAB_Runtime/v96/ \"\" \"0\" \"0\" Using the options \"\" \"0\" \"0\" we initialize ExploreASL , but do not process a dataset. To run a dataset, we have to switch the ImportModules and/or the ProcessModules parameter from 0 to 1 and pass a path for the DataParPath. This could look something like this: ./run_xASL_latest.sh /usr/local/MATLAB/MATLAB_Runtime/v96/ \"/home/TestDataSet/analysis/DataParFile.json\" \"1\" \"1\" (insert example here) How to run ExploreASL using the docker image First you have to pull an official docker image from the ExploreASL repository: docker pull exploreasl/xasl:latest Check out your local images using docker images . If you want to rename the docker image, tag your image using the docker tag command: docker tag exploreasl/xasl:latest xasl:my-version To start a docker container of ExploreASL v1.6.0 e.g., you can use the following command: docker run -e DATAPARFILE=TestDataSet/sourceStructure.json -e IMPORTMODULES=1 -e PROCESSMODULES=1 -v /home/.../incoming:/data/incoming -v /home/.../outgoing:/data/outgoing xasl:1.6.0 Here DATAPARFILE is an environment variable which is a relative path to the data parameter file of your dataset. The IMPORTMODULES and PROCESSMODULES are the parameters of ExploreASL_Master /home/.../incoming:/data/incoming is used to mount your dataset folder ( /home/.../incoming ) to its corresponding docker dataset folder ( /data/incoming ). The same notation is used to mount the docker dataset output folder ( /data/outgoing ) to its corresponding real output folder on your drive ( /home/.../outgoing ). Basic Image Processing Basic NIFTI Input & Output Let's assume you want to read in a NIFTI image and apply a mask on it. As a good first step we always recommend to initialize ExploreASL first by running the following command. [x] = ExploreASL_Initialize; Now let's read in the image by defining the image path and using the xASL_io_Nifti2Im function. pathNIFTI = fullfile(x.MyPath,'External','TestDataSet','analysis','Sub-001','T1.nii'); image = xASL_io_Nifti2Im(pathNIFTI); Maybe we want to mask the image. The image and the mask do not have the same resolution though, which means we need to resample either the mask or the image. The following commands will resample the mask to the image size. pathMask = fullfile(x.MyPath,'External','SPMmodified','MapsAdded','brainmask.nii'); mask = xASL_io_Nifti2Im(pathMask); maskResampled = xASL_im_ResampleLinearFair(mask, size(image)); To mask the image we multiply the image matrix with the mask matrix. This way all voxels outside of the mask are set to 0. image = image.*maskResampled; Then we can save the image as a NIFTI again and open it with our favorite NIFTI viewer. xASL_io_CreateNifti(fullfile(x.MyPath,'export.nii'), image); xASL_io_Nifti2Im does unzip your image, so make sure to revert those changes within the ExploreASL directory later using git reset or git revert . Basic File Operations Matlab offers two functions to copy or move files and folders from a source to a destination within your file system. These functions are copyfile and movefile . To improve speed and multi OS compatibility, we wrote two similar functions, called xASL_Copy and xASL_Move . In the following example we copy a file called fileA from the folder C:\\Users\\Test_One to C:\\Users\\Test_Two . We then move the file back to C:\\Users\\Test_One and overwrite the original fileA . Finally, we rename fileA to fileB . % Copy fileA from Test_One to Test_Two xASL_Copy('C:\\Users\\Test_One\\fileA.txt', 'C:\\Users\\Test_Two\\fileA.txt'); % Move fileA back to Test_One and overwrite the original fileA xASL_Move('C:\\Users\\Test_Two\\fileA.txt', 'C:\\Users\\Test_One\\fileA.txt', 1); % Rename fileA to fileB xASL_Move('C:\\Users\\Test_One\\fileA.txt', 'C:\\Users\\Test_One\\fileB.txt', 1); Often we need to find a list of files in a certain directory. To do this, we can use xASL_adm_GetFileList . Let's assume there are five files called fileA , fileB , fileC , fileD and fileE in C:\\Users\\Test_One . We know that all names start with file , so we can use this for our regular expression. Check out the example below on how you can get a cell array containing the paths of all these files. strDirectory = 'C:\\Users\\Test_One'; strRegEx = '^file.+$'; filepaths = xASL_adm_GetFileList(strDirectory, strRegEx);","title":"Tutorials (ASL-BIDS)"},{"location":"Tutorials-ASL-BIDS/#tutorials-asl-bids","text":"","title":"Tutorials (ASL-BIDS)"},{"location":"Tutorials-ASL-BIDS/#exploreasl-asl-bids","text":"Starting with version v1.6.0 , ExploreASL will support an import workflow which allows the user to convert DICOM and NIFTI data to the ASL-BIDS format. Since ExploreASL does not fully utilize the BIDS format internally, there will also be an automated workflow to convert from ASL-BIDS to the ExploreASL legacy format . In the following subsections we will explain how you can use the automated ExploreASL import workflow to convert your data structure to ASL-BIDS and how you can process it. The ExploreASL_Master script will have the following format: [x] = ExploreASL([DataParPath, ImportModules, ProcessModules, bPause, iWorker, nWorkers]) Parameter descriptions: DataParPath : Path to data parameter file ( OPTIONAL ) DataParPath Type CHAR ARRAY Default Prompting user input ImportModules : Multi-step import workflow ( OPTIONAL ) DCM2NII : Run the DICOM to NIFTI conversion NII2BIDS : Run the NIFTI to BIDS conversion ANONYMIZE : Run the defacing and full anonymization BIDS2LEGACY : Run the BIDS to LEGACY conversion ImportModules DCM2NII NII2BIDS ANONYMIZE BIDS2LEGACY Type BOOLEAN BOOLEAN BOOLEAN BOOLEAN Default false false false false ProcessModules : Multi-step processing pipeline ( OPTIONAL ) STRUCTURAL : Run the Structural Module ASL : Run the ASL Module POPULATION : Run the Population Module ProcessModules STRUCTURAL ASL POPULATION Type BOOLEAN BOOLEAN BOOLEAN Default false false false bPause : Pause workflow before ExploreASL pipeline ( OPTIONAL ) bPause Type BOOLEAN Default false iWorker : Allows parallelization when called externally ( OPTIONAL ) iWorker Type INTEGER Default 1 nWorkers : Allows parallelization when called externally ( OPTIONAL ) nWorkers Type INTEGER Default 1 In the following examples, we want to show how you can use the revised import workflow and how the conventional processing is done now.","title":"ExploreASL &amp; ASL-BIDS"},{"location":"Tutorials-ASL-BIDS/#dicom-source-data","text":"Converting DICOM source data according to the ASL BIDS standard can be done using the new import workflow. For the upcoming release v1.6.0 we're preparing an exemplary DICOM source dataset based on the ASL DRO . To run this workflow, you have to use the path to your sourceStructure.json file instead of the path to your DataPar.json file for the DataParPath input argument. Do not forget to set up the source dataset correctly. You'll be required to define a studyPar.json file as well. We're working on a flavor library, to enable the import and processing of a wide variety of different sequence, vendor, and scanner combinations. The first step to convert your DICOM source data to NIFTI source data is to run the following command: [x] = ExploreASL('sourceStructure.json', [1 0 0 0], 0, 0, 1, 1); Here we tell ExploreASL to run the DCM2NII import module by setting the first boolean variable of the ImportModules to 1 .","title":"DICOM source data"},{"location":"Tutorials-ASL-BIDS/#nifti-source-data","text":"Let's assume we have NIFTI source data according to the ASL BIDS standard now. To convert this ASL BIDS source data to ASL BIDS raw data, we have to run the second part of the import workflow. To run the second step, we set the second variable of the ImportModules to 1 . Similar to the previous step, we pass the path to the sourceStructure.json file to ExploreASL . [x] = ExploreASL('sourceStructure.json', [0 1 0 0], 0, 0, 1, 1);","title":"NIFTI source data"},{"location":"Tutorials-ASL-BIDS/#data-anonymization","text":"There's also a new option to anonymize your data. To do this, you can run the third step of the import workflow. This is done by setting the third variable of the ImportModules to 1 . Similar to the previous steps, we pass the path to the sourceStructure.json file to ExploreASL . [x] = ExploreASL('sourceStructure.json', [0 0 1 0], 0, 0, 1, 1);","title":"Data anonymization"},{"location":"Tutorials-ASL-BIDS/#data-in-exploreasl-legacy-format","text":"Right now, ExploreASL still uses the conventional data structure. To convert our ASL BIDS rawdata to the ExploreASL legacy format, we run the last step of the import workflow. This is done by setting the fourth variable of the ImportModules to 1 . Similar to the previous steps, we pass the path to the sourceStructure.json file to ExploreASL . [x] = ExploreASL('sourceStructure.json', [0 0 0 1], 0, 0, 1, 1); The import workflow will also generate a DataPar.json file. To adapt your pipeline, you can still use the same settings as before, by changing the JSON fields.","title":"Data in ExploreASL legacy format"},{"location":"Tutorials-ASL-BIDS/#exploreasl-processing-pipeline","text":"If you just want to use the conventional ExploreASL processing pipeline, you can simply turn off the import workflow by setting all ImportModules variables to 0 individually or by using a single 0 for the ImportModules . This results in the following notation: [x] = ExploreASL('sourceStructure.json', 0, 1, 0, 1, 1); To run individual modules, you can set the ProcessModules individually. If you only want to the Structural Module for example, you can use a [1 0 0] vector. To run all modules, you can use a single 1 or a vector of ones, which should look like this [1 1 1] . Running the full processing pipeline can therefore be done like this as well: [x] = ExploreASL('sourceStructure.json', 0, [1 1 1], 0, 1, 1);","title":"ExploreASL processing pipeline"},{"location":"Tutorials-ASL-BIDS/#full-pipeline","text":"Running the full pipeline including both import workflow and processing pipeline, can be done by setting both ImportModules and ProcessModules to 1 . [x] = ExploreASL('sourceStructure.json', 1, 1, 0, 1, 1);","title":"Full pipeline"},{"location":"Tutorials-ASL-BIDS/#other-tips-and-tricks","text":"Note that we changed both name and behavior of the SkipPause variable. The variable is called bPause now. Setting it to true or 1 , will result in the pipeline being paused before the processing. We removed the iModules , but the functionality of ProcessModules is basically the same. We use boolean notation now, so instead of [1 2 3] you have to use [1 1 1] now. The overall import functionality is a work in progress right now. We expect stable behavior in release v1.6.0 though. If you plan on using the develop branch until then, you have to live with more or less unstable import behavior. The examples shown below are related to versions v1.5.1 and older. They will be updated soon. If you want to work with the current develop version, these examples obviously do not apply anymore.","title":"Other tips and tricks"},{"location":"Tutorials-ASL-BIDS/#how-to-run-exploreasl-using-matlab","text":"The first thing you have to do, to use ExploreASL , is to clone the ExploreASL repository. If you want to run ExploreASL from Matlab, we recommend to clone the main repository directly from the official GitHub website . You also have the option to download the zipped version or to download an older release . If you are new to Matlab, we recommend checking out a Matlab tutorial . It can be helpful to add the ExploreASL directory to your Matlab paths. Open Matlab, select the Home tab, and add the ExploreASL directory including its subfolders using the Set Path option. Now change your working directory, using the Current Folder tab or the cd command, to the ExploreASL directory. To run ExploreASL you have to type in the following command in the Command Window : ExploreASL . If you already created an ASL-BIDS dataset in sourcedata format, you can run the full default ExploreASL pipeline like this: DataParPath = 'C:\\...\\MY-BIDS-DATASET\\DataParFile.json'; ImportModules = true; ProcessModules = true; bPause = false; [x] = ExploreASL_Master(DataParPath, ImportModules, ProcessModules, bPause);","title":"How to run ExploreASL using Matlab"},{"location":"Tutorials-ASL-BIDS/#how-to-run-a-compiled-exploreasl-version","text":"To compile ExploreASL you have to run the xASL_adm_MakeStandalone.m script. If necessary, you can also ask the developer team for a specific compiled version. Providing a compiled version for every operating system and corresponding Matlab version is currently not feasible for us. Please feel free to ask us for help though! A compiled version of ExploreASL always requires the corresponding Matlab Runtime. Please checkout the official Matlab Documentation . Download the Matlab Runtime of the Matlab Version which was used for the compilation. Make sure to install the Matlab Runtime correctly. If you're using Windows, it is important that the path to the Matlab Runtime is added to Windows PATH during the installation.","title":"How to run a compiled ExploreASL Version"},{"location":"Tutorials-ASL-BIDS/#windows","text":"Let's assume you want to run the compiled version of ExploreASL latest . Check the contents of the folder created by xASL_adm_MakeStandalone.m , which contains the compiled version. There should be a file called xASL_latest.exe . We recommend using the command line interface now. For this you can go to the address bar of your file explorer. Type in cmd to open the command prompt in the current folder. The following command will start ExploreASL , import the ASL-BIDS dataset in sourcedata format, and process the dataset of your sourceStructure.json file: xASL_latest.exe \"c:\\MY-BIDS-DATASET\\sourceStructure.json\" \"1\" \"1\" The executable will extract all necessary data from the CTF archive within the folder. This is totally normal. Within the command window you should see that ExploreASL is starting to process the given dataset: xASL_latest.exe \"c:\\MY-BIDS-DATASET\\sourceStructure.json\" \"1\" \"1\" (insert example here) To test if it is possible to initialize ExploreASL without the processing of a dataset, you could run the following command: xASL_latest.exe \"\" \"0\" \"0\" The usual ExploreASL parameters ( DataParPath , ImportModules , ProcessModules , bPause , iWorker , nWorkers ) have to be given to the compiled ExploreASL version as strings. The resulting output could look like this: xASL_latest.exe \"\" \"0\" \"0\" (insert example here)","title":"Windows"},{"location":"Tutorials-ASL-BIDS/#linux","text":"On Linux you can basically do the same as above. We can run the ExploreASL shell script with a specified Matlab MCR (here we use version 96 e.g.) using the following command: ./run_xASL_latest.sh /usr/local/MATLAB/MATLAB_Runtime/v96/ \"\" \"0\" \"0\" Using the options \"\" \"0\" \"0\" we initialize ExploreASL , but do not process a dataset. To run a dataset, we have to switch the ImportModules and/or the ProcessModules parameter from 0 to 1 and pass a path for the DataParPath. This could look something like this: ./run_xASL_latest.sh /usr/local/MATLAB/MATLAB_Runtime/v96/ \"/home/TestDataSet/analysis/DataParFile.json\" \"1\" \"1\" (insert example here)","title":"Linux"},{"location":"Tutorials-ASL-BIDS/#how-to-run-exploreasl-using-the-docker-image","text":"First you have to pull an official docker image from the ExploreASL repository: docker pull exploreasl/xasl:latest Check out your local images using docker images . If you want to rename the docker image, tag your image using the docker tag command: docker tag exploreasl/xasl:latest xasl:my-version To start a docker container of ExploreASL v1.6.0 e.g., you can use the following command: docker run -e DATAPARFILE=TestDataSet/sourceStructure.json -e IMPORTMODULES=1 -e PROCESSMODULES=1 -v /home/.../incoming:/data/incoming -v /home/.../outgoing:/data/outgoing xasl:1.6.0 Here DATAPARFILE is an environment variable which is a relative path to the data parameter file of your dataset. The IMPORTMODULES and PROCESSMODULES are the parameters of ExploreASL_Master /home/.../incoming:/data/incoming is used to mount your dataset folder ( /home/.../incoming ) to its corresponding docker dataset folder ( /data/incoming ). The same notation is used to mount the docker dataset output folder ( /data/outgoing ) to its corresponding real output folder on your drive ( /home/.../outgoing ).","title":"How to run ExploreASL using the docker image"},{"location":"Tutorials-ASL-BIDS/#basic-image-processing","text":"","title":"Basic Image Processing"},{"location":"Tutorials-ASL-BIDS/#basic-nifti-input-output","text":"Let's assume you want to read in a NIFTI image and apply a mask on it. As a good first step we always recommend to initialize ExploreASL first by running the following command. [x] = ExploreASL_Initialize; Now let's read in the image by defining the image path and using the xASL_io_Nifti2Im function. pathNIFTI = fullfile(x.MyPath,'External','TestDataSet','analysis','Sub-001','T1.nii'); image = xASL_io_Nifti2Im(pathNIFTI); Maybe we want to mask the image. The image and the mask do not have the same resolution though, which means we need to resample either the mask or the image. The following commands will resample the mask to the image size. pathMask = fullfile(x.MyPath,'External','SPMmodified','MapsAdded','brainmask.nii'); mask = xASL_io_Nifti2Im(pathMask); maskResampled = xASL_im_ResampleLinearFair(mask, size(image)); To mask the image we multiply the image matrix with the mask matrix. This way all voxels outside of the mask are set to 0. image = image.*maskResampled; Then we can save the image as a NIFTI again and open it with our favorite NIFTI viewer. xASL_io_CreateNifti(fullfile(x.MyPath,'export.nii'), image); xASL_io_Nifti2Im does unzip your image, so make sure to revert those changes within the ExploreASL directory later using git reset or git revert .","title":"Basic NIFTI Input &amp; Output"},{"location":"Tutorials-ASL-BIDS/#basic-file-operations","text":"Matlab offers two functions to copy or move files and folders from a source to a destination within your file system. These functions are copyfile and movefile . To improve speed and multi OS compatibility, we wrote two similar functions, called xASL_Copy and xASL_Move . In the following example we copy a file called fileA from the folder C:\\Users\\Test_One to C:\\Users\\Test_Two . We then move the file back to C:\\Users\\Test_One and overwrite the original fileA . Finally, we rename fileA to fileB . % Copy fileA from Test_One to Test_Two xASL_Copy('C:\\Users\\Test_One\\fileA.txt', 'C:\\Users\\Test_Two\\fileA.txt'); % Move fileA back to Test_One and overwrite the original fileA xASL_Move('C:\\Users\\Test_Two\\fileA.txt', 'C:\\Users\\Test_One\\fileA.txt', 1); % Rename fileA to fileB xASL_Move('C:\\Users\\Test_One\\fileA.txt', 'C:\\Users\\Test_One\\fileB.txt', 1); Often we need to find a list of files in a certain directory. To do this, we can use xASL_adm_GetFileList . Let's assume there are five files called fileA , fileB , fileC , fileD and fileE in C:\\Users\\Test_One . We know that all names start with file , so we can use this for our regular expression. Check out the example below on how you can get a cell array containing the paths of all these files. strDirectory = 'C:\\Users\\Test_One'; strRegEx = '^file.+$'; filepaths = xASL_adm_GetFileList(strDirectory, strRegEx);","title":"Basic File Operations"},{"location":"Tutorials-Advanced/","text":"Tutorials (Advanced) Basic Image Processing Basic NIFTI Input & Output Let's assume you want to read in a NIFTI image and apply a mask on it. As a good first step we always recommend to initialize ExploreASL first by running the following command. [x] = ExploreASL_Initialize; Now let's read in the image by defining the image path and using the xASL_io_Nifti2Im function. pathNIFTI = fullfile(x.MyPath,'External','TestDataSet','analysis','Sub-001','T1.nii'); image = xASL_io_Nifti2Im(pathNIFTI); Maybe we want to mask the image. The image and the mask do not have the same resolution though, which means we need to resample either the mask or the image. The following commands will resample the mask to the image size. pathMask = fullfile(x.MyPath,'External','SPMmodified','MapsAdded','brainmask.nii'); mask = xASL_io_Nifti2Im(pathMask); maskResampled = xASL_im_ResampleLinearFair(mask, size(image)); To mask the image we multiply the image matrix with the mask matrix. This way all voxels outside of the mask are set to 0. image = image.*maskResampled; Then we can save the image as a NIFTI again and open it with our favorite NIFTI viewer. xASL_io_CreateNifti(fullfile(x.MyPath,'export.nii'), image); xASL_io_Nifti2Im does unzip your image, so make sure to revert those changes within the ExploreASL directory later using git reset or git revert . Basic File Operations Matlab offers two functions to copy or move files and folders from a source to a destination within your file system. These functions are copyfile and movefile . To improve speed and multi OS compatibility, we wrote two similar functions, called xASL_Copy and xASL_Move . In the following example we copy a file called fileA from the folder C:\\Users\\Test_One to C:\\Users\\Test_Two . We then move the file back to C:\\Users\\Test_One and overwrite the original fileA . Finally, we rename fileA to fileB . % Copy fileA from Test_One to Test_Two xASL_Copy('C:\\Users\\Test_One\\fileA.txt', 'C:\\Users\\Test_Two\\fileA.txt'); % Move fileA back to Test_One and overwrite the original fileA xASL_Move('C:\\Users\\Test_Two\\fileA.txt', 'C:\\Users\\Test_One\\fileA.txt', 1); % Rename fileA to fileB xASL_Move('C:\\Users\\Test_One\\fileA.txt', 'C:\\Users\\Test_One\\fileB.txt', 1); Often we need to find a list of files in a certain directory. To do this, we can use xASL_adm_GetFileList . Let's assume there are five files called fileA , fileB , fileC , fileD and fileE in C:\\Users\\Test_One . We know that all names start with file , so we can use this for our regular expression. Check out the example below on how you can get a cell array containing the paths of all these files. strDirectory = 'C:\\Users\\Test_One'; strRegEx = '^file.+$'; filepaths = xASL_adm_GetFileList(strDirectory, strRegEx);","title":"Tutorials (Advanced)"},{"location":"Tutorials-Advanced/#tutorials-advanced","text":"","title":"Tutorials (Advanced)"},{"location":"Tutorials-Advanced/#basic-image-processing","text":"","title":"Basic Image Processing"},{"location":"Tutorials-Advanced/#basic-nifti-input-output","text":"Let's assume you want to read in a NIFTI image and apply a mask on it. As a good first step we always recommend to initialize ExploreASL first by running the following command. [x] = ExploreASL_Initialize; Now let's read in the image by defining the image path and using the xASL_io_Nifti2Im function. pathNIFTI = fullfile(x.MyPath,'External','TestDataSet','analysis','Sub-001','T1.nii'); image = xASL_io_Nifti2Im(pathNIFTI); Maybe we want to mask the image. The image and the mask do not have the same resolution though, which means we need to resample either the mask or the image. The following commands will resample the mask to the image size. pathMask = fullfile(x.MyPath,'External','SPMmodified','MapsAdded','brainmask.nii'); mask = xASL_io_Nifti2Im(pathMask); maskResampled = xASL_im_ResampleLinearFair(mask, size(image)); To mask the image we multiply the image matrix with the mask matrix. This way all voxels outside of the mask are set to 0. image = image.*maskResampled; Then we can save the image as a NIFTI again and open it with our favorite NIFTI viewer. xASL_io_CreateNifti(fullfile(x.MyPath,'export.nii'), image); xASL_io_Nifti2Im does unzip your image, so make sure to revert those changes within the ExploreASL directory later using git reset or git revert .","title":"Basic NIFTI Input &amp; Output"},{"location":"Tutorials-Advanced/#basic-file-operations","text":"Matlab offers two functions to copy or move files and folders from a source to a destination within your file system. These functions are copyfile and movefile . To improve speed and multi OS compatibility, we wrote two similar functions, called xASL_Copy and xASL_Move . In the following example we copy a file called fileA from the folder C:\\Users\\Test_One to C:\\Users\\Test_Two . We then move the file back to C:\\Users\\Test_One and overwrite the original fileA . Finally, we rename fileA to fileB . % Copy fileA from Test_One to Test_Two xASL_Copy('C:\\Users\\Test_One\\fileA.txt', 'C:\\Users\\Test_Two\\fileA.txt'); % Move fileA back to Test_One and overwrite the original fileA xASL_Move('C:\\Users\\Test_Two\\fileA.txt', 'C:\\Users\\Test_One\\fileA.txt', 1); % Rename fileA to fileB xASL_Move('C:\\Users\\Test_One\\fileA.txt', 'C:\\Users\\Test_One\\fileB.txt', 1); Often we need to find a list of files in a certain directory. To do this, we can use xASL_adm_GetFileList . Let's assume there are five files called fileA , fileB , fileC , fileD and fileE in C:\\Users\\Test_One . We know that all names start with file , so we can use this for our regular expression. Check out the example below on how you can get a cell array containing the paths of all these files. strDirectory = 'C:\\Users\\Test_One'; strRegEx = '^file.+$'; filepaths = xASL_adm_GetFileList(strDirectory, strRegEx);","title":"Basic File Operations"},{"location":"Tutorials-Basics/","text":"Tutorials (Basics) How to run ExploreASL using Matlab The first thing you have to do, to use ExploreASL , is to clone the ExploreASL repository. If you want to run ExploreASL from Matlab, we recommend to clone the main repository directly from the official GitHub website . You also have the option to download the zipped version or to download an older release . If you are new to Matlab, we recommend checking out a Matlab tutorial . It can be helpful to add the ExploreASL directory to your Matlab paths. Open Matlab, select the Home tab, and add the ExploreASL directory including its subfolders using the Set Path option. Now change your working directory, using the Current Folder tab or the cd command, to the ExploreASL directory. To run ExploreASL you have to type in the following command in the Command Window : ExploreASL . If you already created an ASL-BIDS dataset in sourcedata format, you can run the full default ExploreASL pipeline like this: DataParPath = 'C:\\...\\MY-BIDS-DATASET\\DataParFile.json'; ImportModules = true; ProcessModules = true; bPause = false; [x] = ExploreASL_Master(DataParPath, ImportModules, ProcessModules, bPause); How to run a compiled ExploreASL Version To compile ExploreASL you have to run the xASL_adm_MakeStandalone.m script. If necessary, you can also ask the developer team for a specific compiled version. Providing a compiled version for every operating system and corresponding Matlab version is currently not feasible for us. Please feel free to ask us for help though! A compiled version of ExploreASL always requires the corresponding Matlab Runtime. Please checkout the official Matlab Documentation . Download the Matlab Runtime of the Matlab Version which was used for the compilation. Make sure to install the Matlab Runtime correctly. If you're using Windows, it is important that the path to the Matlab Runtime is added to Windows PATH during the installation. Windows Let's assume you want to run the compiled version of ExploreASL latest . Check the contents of the folder created by xASL_adm_MakeStandalone.m , which contains the compiled version. There should be a file called xASL_latest.exe . We recommend using the command line interface now. For this you can go to the address bar of your file explorer. Type in cmd to open the command prompt in the current folder. The following command will start ExploreASL , import the ASL-BIDS dataset in sourcedata format, and process the dataset of your sourceStructure.json file: xASL_latest.exe \"c:\\MY-BIDS-DATASET\\sourceStructure.json\" \"1\" \"1\" The executable will extract all necessary data from the CTF archive within the folder. This is totally normal. Within the command window you should see that ExploreASL is starting to process the given dataset: xASL_latest.exe \"c:\\MY-BIDS-DATASET\\sourceStructure.json\" \"1\" \"1\" (insert example here) To test if it is possible to initialize ExploreASL without the processing of a dataset, you could run the following command: xASL_latest.exe \"\" \"0\" \"0\" The usual ExploreASL parameters ( DataParPath , ImportModules , ProcessModules , bPause , iWorker , nWorkers ) have to be given to the compiled ExploreASL version as strings. The resulting output could look like this: xASL_latest.exe \"\" \"0\" \"0\" (insert example here) Linux On Linux you can basically do the same as above. We can run the ExploreASL shell script with a specified Matlab MCR (here we use version 96 e.g.) using the following command: ./run_xASL_latest.sh /usr/local/MATLAB/MATLAB_Runtime/v96/ \"\" \"0\" \"0\" Using the options \"\" \"0\" \"0\" we initialize ExploreASL , but do not process a dataset. To run a dataset, we have to switch the ImportModules and/or the ProcessModules parameter from 0 to 1 and pass a path for the DataParPath. This could look something like this: ./run_xASL_latest.sh /usr/local/MATLAB/MATLAB_Runtime/v96/ \"/home/TestDataSet/analysis/DataParFile.json\" \"1\" \"1\" (insert example here) How to run ExploreASL using the docker image First you have to pull an official docker image from the ExploreASL repository: docker pull docker.pkg.github.com/exploreasl/docker/xasl:1.x.x If you want to rename the docker image, you can use the docker tag command: docker tag docker.pkg.github.com/exploreasl/docker/xasl:1.x.x xasl:1.x.x To start a docker container of ExploreASL v1.6.0 e.g., you can use the following command: docker run -e DATAPARFILE=\"TestDataSet/sourceStructure.json\" -e IMPORTMODULES=\"1\" -e PROCESSMODULES=\"1\" -v /home/.../incoming:/data/incoming -v /home/.../outgoing:/data/outgoing xasl:1.6.0 Here DATAPARFILE is an environment variable which is a relative path to the data parameter file of your dataset. /home/.../incoming:/data/incoming is used to mount your dataset folder ( /home/.../incoming ) to its corresponding docker dataset folder ( /data/incoming ). The same notation is used to mount the docker dataset output folder ( /data/outgoing ) to its corresponding real output folder on your drive ( /home/.../outgoing ).","title":"Tutorials (Basics)"},{"location":"Tutorials-Basics/#tutorials-basics","text":"","title":"Tutorials (Basics)"},{"location":"Tutorials-Basics/#how-to-run-exploreasl-using-matlab","text":"The first thing you have to do, to use ExploreASL , is to clone the ExploreASL repository. If you want to run ExploreASL from Matlab, we recommend to clone the main repository directly from the official GitHub website . You also have the option to download the zipped version or to download an older release . If you are new to Matlab, we recommend checking out a Matlab tutorial . It can be helpful to add the ExploreASL directory to your Matlab paths. Open Matlab, select the Home tab, and add the ExploreASL directory including its subfolders using the Set Path option. Now change your working directory, using the Current Folder tab or the cd command, to the ExploreASL directory. To run ExploreASL you have to type in the following command in the Command Window : ExploreASL . If you already created an ASL-BIDS dataset in sourcedata format, you can run the full default ExploreASL pipeline like this: DataParPath = 'C:\\...\\MY-BIDS-DATASET\\DataParFile.json'; ImportModules = true; ProcessModules = true; bPause = false; [x] = ExploreASL_Master(DataParPath, ImportModules, ProcessModules, bPause);","title":"How to run ExploreASL using Matlab"},{"location":"Tutorials-Basics/#how-to-run-a-compiled-exploreasl-version","text":"To compile ExploreASL you have to run the xASL_adm_MakeStandalone.m script. If necessary, you can also ask the developer team for a specific compiled version. Providing a compiled version for every operating system and corresponding Matlab version is currently not feasible for us. Please feel free to ask us for help though! A compiled version of ExploreASL always requires the corresponding Matlab Runtime. Please checkout the official Matlab Documentation . Download the Matlab Runtime of the Matlab Version which was used for the compilation. Make sure to install the Matlab Runtime correctly. If you're using Windows, it is important that the path to the Matlab Runtime is added to Windows PATH during the installation.","title":"How to run a compiled ExploreASL Version"},{"location":"Tutorials-Basics/#windows","text":"Let's assume you want to run the compiled version of ExploreASL latest . Check the contents of the folder created by xASL_adm_MakeStandalone.m , which contains the compiled version. There should be a file called xASL_latest.exe . We recommend using the command line interface now. For this you can go to the address bar of your file explorer. Type in cmd to open the command prompt in the current folder. The following command will start ExploreASL , import the ASL-BIDS dataset in sourcedata format, and process the dataset of your sourceStructure.json file: xASL_latest.exe \"c:\\MY-BIDS-DATASET\\sourceStructure.json\" \"1\" \"1\" The executable will extract all necessary data from the CTF archive within the folder. This is totally normal. Within the command window you should see that ExploreASL is starting to process the given dataset: xASL_latest.exe \"c:\\MY-BIDS-DATASET\\sourceStructure.json\" \"1\" \"1\" (insert example here) To test if it is possible to initialize ExploreASL without the processing of a dataset, you could run the following command: xASL_latest.exe \"\" \"0\" \"0\" The usual ExploreASL parameters ( DataParPath , ImportModules , ProcessModules , bPause , iWorker , nWorkers ) have to be given to the compiled ExploreASL version as strings. The resulting output could look like this: xASL_latest.exe \"\" \"0\" \"0\" (insert example here)","title":"Windows"},{"location":"Tutorials-Basics/#linux","text":"On Linux you can basically do the same as above. We can run the ExploreASL shell script with a specified Matlab MCR (here we use version 96 e.g.) using the following command: ./run_xASL_latest.sh /usr/local/MATLAB/MATLAB_Runtime/v96/ \"\" \"0\" \"0\" Using the options \"\" \"0\" \"0\" we initialize ExploreASL , but do not process a dataset. To run a dataset, we have to switch the ImportModules and/or the ProcessModules parameter from 0 to 1 and pass a path for the DataParPath. This could look something like this: ./run_xASL_latest.sh /usr/local/MATLAB/MATLAB_Runtime/v96/ \"/home/TestDataSet/analysis/DataParFile.json\" \"1\" \"1\" (insert example here)","title":"Linux"},{"location":"Tutorials-Basics/#how-to-run-exploreasl-using-the-docker-image","text":"First you have to pull an official docker image from the ExploreASL repository: docker pull docker.pkg.github.com/exploreasl/docker/xasl:1.x.x If you want to rename the docker image, you can use the docker tag command: docker tag docker.pkg.github.com/exploreasl/docker/xasl:1.x.x xasl:1.x.x To start a docker container of ExploreASL v1.6.0 e.g., you can use the following command: docker run -e DATAPARFILE=\"TestDataSet/sourceStructure.json\" -e IMPORTMODULES=\"1\" -e PROCESSMODULES=\"1\" -v /home/.../incoming:/data/incoming -v /home/.../outgoing:/data/outgoing xasl:1.6.0 Here DATAPARFILE is an environment variable which is a relative path to the data parameter file of your dataset. /home/.../incoming:/data/incoming is used to mount your dataset folder ( /home/.../incoming ) to its corresponding docker dataset folder ( /data/incoming ). The same notation is used to mount the docker dataset output folder ( /data/outgoing ) to its corresponding real output folder on your drive ( /home/.../outgoing ).","title":"How to run ExploreASL using the docker image"}]}