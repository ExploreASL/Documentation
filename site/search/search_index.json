{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Description ExploreASL is a pipeline and toolbox for image processing and statistics of arterial spin labeling perfusion MR images. It is designed as a multi-OS , open source, collaborative framework that facilitates cross-pollination between image processing method developers and clinical investigators. The software provides a complete head-to-tail approach that runs fully automatically, encompassing all necessary tasks from data import and structural segmentation, registration and normalization, up to CBF quantification. In addition, the software package includes and quality control ( QC ) procedures and region-of-interest ( ROI ) as well as voxel-wise analysis on the extracted data. To-date, ExploreASL has been used for processing ~10000 ASL datasets from all major MRI vendors and ASL sequences, and a variety of patient populations, representing ~30 studies. The ultimate goal of ExploreASL is to combine data from multiple studies to identify disease related perfusion patterns that may prove crucial in using ASL as a diagnostic took and enhance our understanding of the interplay of perfusion and structural changes in neurodegenerative pathophysiology. Additionally, this (semi-)automatic pipeline allows us to minimize manual intervention, which increases the reproducibility of studies. Highlighted Features Features Installation To use ExploreASL within Matlab, you can download a stable release version from the GitHub releases section. Navigate within Matlab to the ExporeASL directory, to make ExploreASL the current working directory. It is recommended to use the Matlab set paths option to add the ExploreASL folder and all subfolders to the known paths. Execute the master script to start the interactive ExploreASL workflow: ExploreASL_Master Workflow Developers Please contact the co-creators for more information: Henk-Jan Mutsaerts HenkJanMutsaerts@Gmail.com Jan Petr j.petr@hzdr.de Other Contributors Acknowledgement","title":"Home"},{"location":"#description","text":"ExploreASL is a pipeline and toolbox for image processing and statistics of arterial spin labeling perfusion MR images. It is designed as a multi-OS , open source, collaborative framework that facilitates cross-pollination between image processing method developers and clinical investigators. The software provides a complete head-to-tail approach that runs fully automatically, encompassing all necessary tasks from data import and structural segmentation, registration and normalization, up to CBF quantification. In addition, the software package includes and quality control ( QC ) procedures and region-of-interest ( ROI ) as well as voxel-wise analysis on the extracted data. To-date, ExploreASL has been used for processing ~10000 ASL datasets from all major MRI vendors and ASL sequences, and a variety of patient populations, representing ~30 studies. The ultimate goal of ExploreASL is to combine data from multiple studies to identify disease related perfusion patterns that may prove crucial in using ASL as a diagnostic took and enhance our understanding of the interplay of perfusion and structural changes in neurodegenerative pathophysiology. Additionally, this (semi-)automatic pipeline allows us to minimize manual intervention, which increases the reproducibility of studies.","title":"Description"},{"location":"#highlighted-features","text":"","title":"Highlighted Features"},{"location":"#features","text":"","title":"Features"},{"location":"#installation","text":"To use ExploreASL within Matlab, you can download a stable release version from the GitHub releases section. Navigate within Matlab to the ExporeASL directory, to make ExploreASL the current working directory. It is recommended to use the Matlab set paths option to add the ExploreASL folder and all subfolders to the known paths. Execute the master script to start the interactive ExploreASL workflow: ExploreASL_Master","title":"Installation"},{"location":"#workflow","text":"","title":"Workflow"},{"location":"#developers","text":"Please contact the co-creators for more information: Henk-Jan Mutsaerts HenkJanMutsaerts@Gmail.com Jan Petr j.petr@hzdr.de","title":"Developers"},{"location":"#other-contributors","text":"","title":"Other Contributors"},{"location":"#acknowledgement","text":"","title":"Acknowledgement"},{"location":"ASL_Module/","text":"Submodules of the ASL Module Create Analysis Mask Function function xASL_wrp_CreateAnalysisMask(x) Description Create analysis mask from a combination of FoV & removal of high and negative intravascular ASL voxels. Workflow Create FoV mask (native & MNI spaces) Detect negative vascular signal (native & MNI spaces, within pGM >0.5) Detect peak vascular signal (native & MNI spaces, within pGM ==80% percentile on ASL image) Brainmasking & FoV -masking (A) native & B) MNI spaces): Add WM vascular parts back to the mask (defined as pWM>0.8) & remove extracranial signal. In the WM , negative or peak signal is more expected from noise rather than from intra-vascular signal, not many big vessels exist in the WM . Save vascular masks Create susceptibility mask (standard space only): Here, we combine manually segmented susceptibility artifact regions in which a population-based susceptibility probability map is created. This map is combined (i.e. taking the product) with the mean control & PWI intensity distribution in these regions. This product is thresholded with the average of the 75th percentile & 15% of the intensity (for a bit more robustness against individual variability in sinus sizes). Create standard space CBF_masked image to visualize masking effect Recommended usage Interface definition Prepare PV Function function x = xASL_wrp_PreparePV(x, bStandardSpace) Description Submodule of ExploreASL ASL Module, to prepare PV maps on ASL resolution. Workflow This submodule prepares partial volume correction ( PVC ) by creating correct PV maps in ASL resolution, in native space, as well as in standard space if requested (to perform PVC in standard space). If bStandardSpace: 1. Create dummy upsampled ASL scan, for registration 2. Reslice pGM & pWM to hi-res ASL 3. Estimate effective spatial resolution of ASL 4. Smooth pGM & pWM to this spatial resolution 5. Move smoothed tissue posteriors to MNI space Else: Run step 3 only, which will use the effective spatial resolution that is default for the respective sequence: 2D EPI : [1 1 1] * VoxelSize 3D GRASE : [1.1 1.1 1.38] * VoxelSize 3D spiral : [4.3 4.4 10.1] * VoxelSize (assuming GE uses the upsampled 2x2x4 mm ...& run steps 1&2, but in native space these entail presmoothing & downsampling.) Recommended usage Interface definition Process M0 Function function xASL_wrp_ProcessM0(x) Description Submodule of ExploreASL ASL Module, for M0 image processing. Workflow This submodule performs the image processing and quantification of M0 maps (if they exist), with the following steps: Register M0 to mean control if it exists: Before registration, contrast is equalized between the images & biasfields are removed. Quantify M0 (correction scale slope & incomplete T1 recovery) Masking & smoothing of M0 image, either using: A) traditional technique (very sharp masking & little smoothing) B) new ExploreASL-specific technique: extrapolating outside mask (avoiding artifacts from too much or too little masking) smooth very extensively, to create a biasfield (increases robustness & comparison of M0 between sequences/patients) Any M0 will be processed here. Even if part of the subjects does not have an M0 , since this can be later imputed, or an average population M0 image could be used. Also, without background suppression and without an M0 , the MeanControl image is before saved as M0 , and will be processed here as well. Note that any voxel-size differences between M0 and ASL are allowed here: step 0B below rescales the PD inside an M0 voxel to the same as the ASL resolution (assuming a voxel with half volume contains half the amount of protons). The M0 is further processed in standard space, and reduced to a biasfield. For the quantification in standard space, the PWI and M0 are now by definition in the same space. Also, the standard space M0 biasfield is resampled to the native PWI space (at the end of step 3B) , ensuring that both are also in the same native space. Recommended usage Interface definition Quantify Function function xASL_wrp_Quantify(x, PWI_Path, OutputPath, M0Path, SliceGradientPath) Description Submodule of ExploreASL ASL Module, that performs quantfication. Workflow This submodule converts PWIs to quantified CBF maps (or related derivatives): Load PWI Prepare M0 Hematocrit & blood T1 correction ASL & M0 parameters comparisons Load SliceGradient Initialize & define quantification parameters Define labeling efficiency Perform quantification Save files Perform FEAST quantification (if exist) Recommended usage Interface definition Realign ASL Function function xASL_wrp_RealignASL(x,bSubtraction) Description Submodule of ExploreASL ASL Module, that realigns. Workflow This submodule estimates motion by spm_realign, which uses a rigid-body registration (3 translations, 3 rotations). It runs ENABLE to reject outliers and provides a visualization. ENABLE , QC and visualizations are based on the Net Displacement Vector ( NDV ) (in mm): according to Pythagorean/Euclydian RMS . Link: jiscmail View this link for image of rotation roll, pitch and yaw: grcnasa This submodule performs the following steps: 1. Estimate motion 2. Calculate and plot position and motion parameters 3. Threshold-free spike definition (based on ENABLE , but with t-stats rather than the threshold p<0.05) 4. Remove spike frames from Nifti Recommended usage Interface definition Register ASL Function function xASL_wrp_RegisterASL(x) Description Submodule of ExploreASL ASL Module, that registers ASL to T1w (or potentially other structural images). Workflow This submodule registers ASL images to T1w space, by using a combination of the registration techniques below. Note that in the absence of raw structural files (i.e. T1 .nii[.gz] or T1_ORI .nii[.gz], it will recreate dummy files from standard space to do this registration. M0-T1w rigid-body -> this works well in 2D EPI sequences PWI-pGM rigid-body -> this is robust across sequences with different readouts and consequently different effective spatial resolutions. With low spatial resolution (e.g. GE 3D spiral product sequence), M0-T1w registration may not work, but PWI-pGM will work. PWI-pGM registration fails with large (vascular) artifacts, therefore this is performed only with relatively low spatial CoV . PWI-pGM affine -> If the spatial CoV is sufficiently low, this can improve the registration These images are registered to ASL templates that were inversely transformed from MNI to the T1w space (& resampled to the ASL space) As this would have an ever higher similarity with the M0 & PWI . This submodule performs the following steps: Administration: ASL4D is dealth with, if motion peaks were removed this is called despiked_ASL4D a default \"OtherList\" is specified. This is used every registration instance, except for removing the ref and src NIfTIs used in the registration instance. Also, inside the registration function the unexisting OtherList NIfTIs are skipped Define paths to the ASL templates Previous registration output files are removed Allow registration without structural data native -> MNI transformation flow field y_T1.nii is smoothed to the effective ASL resolution y_ASL.nii Registration contrasts are dealth with: x.bRegistrationContrast - specifies the image contrast used for registration (OPTIONAL, DEFAULT = 2): 0 = Control -> T1w 1 = CBF -> pseudoCBF from template/ pGM + pWM (skip if sCoV >0.667) 2 = automatic (mix of both) 3 = option 2 & force CBF -> pseudoCBF irrespective of sCoV or Tanimoto coefficient Dummy src NIfTIs are created: mean_control.nii to register with T1w mean_PWI_Clipped.nii to register with pseudoCBF Create reference images, downsampled pseudoTissue Registration Center of Mass Registration ASL -> anat (Control -> T1w ) (this step is only applied if it improves the Tanimoto coefficient) Registration CBF->pseudoCBF (this step is only applied if it improves the Tanimoto coefficient). Also, this step is only applied if the spatial CoV < 0.67. Note that this is usually the case for 3D scans because of their lower effective spatial resolution. x.bAffineRegistration - specifies the ASL-T1w rigid-body registration is followed up by an affine registration (OPTIONAL, DEFAULT = 2) 0 = affine registration disabled 1 = affine registration enabled 2 = affine registration automatically chosen based on spatial CoV of PWI Recommended usage Interface definition Resample ASL Function function xASL_wrp_ResampleASL(x) Description Submodule of ExploreASL ASL Module, that reslices native space images to standard space. Workflow This submodule resamples native space NIfTIs to standard space, using the deformation fields computed in the structural module after smoothing these transformation fields to the ASL resolution. The applied interpolation is a combination of all transformations (e.g. motion correction, registration to T1w , and transformation of T1w to standard space. This submodule performs the following steps: Create slice gradient image for quantification reference, in case of 2D ASL Reslice ASL time series to MNI space (currently 1.5 mm^3) Create mean control image, if available: This also applies a bilateral filter, if requested. If x.M0 is set as UseControlAsM0, this mean control NIfTI will be copied to an M0 NIfTI (and processed in the M0 submodule). Perform pair-wise subtraction (to create PWI.nii ), in native space Same in standard space Save PWI NIfTI & time-series-related maps ( SD, SNR ) Recommended usage Interface definition Visual QC ASL Function function xASL_wrp_VisualQC_ASL(x) Description Submodule of ExploreASL ASL Module, that performs several visualizations for QC . Workflow This submodule performs several visualizations for visual & quantitative QC . 1. After initial admin 2. It starts with making ASL NIfTIs ready for visualization & conversion to DICOM (though skipped by default) 3. Then it performs a collection of visualizations 4. Visualizes results of the TopUp geometric distortion correction 5. Visualization of slice gradient 6. Visualization & calculation of temporal QC parameters 7. Compute DICE overlap/intersection of ASL brain in FoV & T1w , to calculate coverage 8. Summarize orientation & check left-right flips 9. Collect several other parameters & store in PDF overview Recommended usage Interface definition","title":"Module ASL"},{"location":"ASL_Module/#submodules-of-the-asl-module","text":"","title":"Submodules of the ASL Module"},{"location":"ASL_Module/#create-analysis-mask","text":"","title":"Create Analysis Mask"},{"location":"ASL_Module/#function","text":"function xASL_wrp_CreateAnalysisMask(x)","title":"Function"},{"location":"ASL_Module/#description","text":"Create analysis mask from a combination of FoV & removal of high and negative intravascular ASL voxels.","title":"Description"},{"location":"ASL_Module/#workflow","text":"Create FoV mask (native & MNI spaces) Detect negative vascular signal (native & MNI spaces, within pGM >0.5) Detect peak vascular signal (native & MNI spaces, within pGM ==80% percentile on ASL image) Brainmasking & FoV -masking (A) native & B) MNI spaces): Add WM vascular parts back to the mask (defined as pWM>0.8) & remove extracranial signal. In the WM , negative or peak signal is more expected from noise rather than from intra-vascular signal, not many big vessels exist in the WM . Save vascular masks Create susceptibility mask (standard space only): Here, we combine manually segmented susceptibility artifact regions in which a population-based susceptibility probability map is created. This map is combined (i.e. taking the product) with the mean control & PWI intensity distribution in these regions. This product is thresholded with the average of the 75th percentile & 15% of the intensity (for a bit more robustness against individual variability in sinus sizes). Create standard space CBF_masked image to visualize masking effect","title":"Workflow"},{"location":"ASL_Module/#recommended-usage","text":"","title":"Recommended usage"},{"location":"ASL_Module/#interface-definition","text":"","title":"Interface definition"},{"location":"ASL_Module/#prepare-pv","text":"","title":"Prepare PV"},{"location":"ASL_Module/#function_1","text":"function x = xASL_wrp_PreparePV(x, bStandardSpace)","title":"Function"},{"location":"ASL_Module/#description_1","text":"Submodule of ExploreASL ASL Module, to prepare PV maps on ASL resolution.","title":"Description"},{"location":"ASL_Module/#workflow_1","text":"This submodule prepares partial volume correction ( PVC ) by creating correct PV maps in ASL resolution, in native space, as well as in standard space if requested (to perform PVC in standard space). If bStandardSpace: 1. Create dummy upsampled ASL scan, for registration 2. Reslice pGM & pWM to hi-res ASL 3. Estimate effective spatial resolution of ASL 4. Smooth pGM & pWM to this spatial resolution 5. Move smoothed tissue posteriors to MNI space Else: Run step 3 only, which will use the effective spatial resolution that is default for the respective sequence: 2D EPI : [1 1 1] * VoxelSize 3D GRASE : [1.1 1.1 1.38] * VoxelSize 3D spiral : [4.3 4.4 10.1] * VoxelSize (assuming GE uses the upsampled 2x2x4 mm ...& run steps 1&2, but in native space these entail presmoothing & downsampling.)","title":"Workflow"},{"location":"ASL_Module/#recommended-usage_1","text":"","title":"Recommended usage"},{"location":"ASL_Module/#interface-definition_1","text":"","title":"Interface definition"},{"location":"ASL_Module/#process-m0","text":"","title":"Process M0"},{"location":"ASL_Module/#function_2","text":"function xASL_wrp_ProcessM0(x)","title":"Function"},{"location":"ASL_Module/#description_2","text":"Submodule of ExploreASL ASL Module, for M0 image processing.","title":"Description"},{"location":"ASL_Module/#workflow_2","text":"This submodule performs the image processing and quantification of M0 maps (if they exist), with the following steps: Register M0 to mean control if it exists: Before registration, contrast is equalized between the images & biasfields are removed. Quantify M0 (correction scale slope & incomplete T1 recovery) Masking & smoothing of M0 image, either using: A) traditional technique (very sharp masking & little smoothing) B) new ExploreASL-specific technique: extrapolating outside mask (avoiding artifacts from too much or too little masking) smooth very extensively, to create a biasfield (increases robustness & comparison of M0 between sequences/patients) Any M0 will be processed here. Even if part of the subjects does not have an M0 , since this can be later imputed, or an average population M0 image could be used. Also, without background suppression and without an M0 , the MeanControl image is before saved as M0 , and will be processed here as well. Note that any voxel-size differences between M0 and ASL are allowed here: step 0B below rescales the PD inside an M0 voxel to the same as the ASL resolution (assuming a voxel with half volume contains half the amount of protons). The M0 is further processed in standard space, and reduced to a biasfield. For the quantification in standard space, the PWI and M0 are now by definition in the same space. Also, the standard space M0 biasfield is resampled to the native PWI space (at the end of step 3B) , ensuring that both are also in the same native space.","title":"Workflow"},{"location":"ASL_Module/#recommended-usage_2","text":"","title":"Recommended usage"},{"location":"ASL_Module/#interface-definition_2","text":"","title":"Interface definition"},{"location":"ASL_Module/#quantify","text":"","title":"Quantify"},{"location":"ASL_Module/#function_3","text":"function xASL_wrp_Quantify(x, PWI_Path, OutputPath, M0Path, SliceGradientPath)","title":"Function"},{"location":"ASL_Module/#description_3","text":"Submodule of ExploreASL ASL Module, that performs quantfication.","title":"Description"},{"location":"ASL_Module/#workflow_3","text":"This submodule converts PWIs to quantified CBF maps (or related derivatives): Load PWI Prepare M0 Hematocrit & blood T1 correction ASL & M0 parameters comparisons Load SliceGradient Initialize & define quantification parameters Define labeling efficiency Perform quantification Save files Perform FEAST quantification (if exist)","title":"Workflow"},{"location":"ASL_Module/#recommended-usage_3","text":"","title":"Recommended usage"},{"location":"ASL_Module/#interface-definition_3","text":"","title":"Interface definition"},{"location":"ASL_Module/#realign-asl","text":"","title":"Realign ASL"},{"location":"ASL_Module/#function_4","text":"function xASL_wrp_RealignASL(x,bSubtraction)","title":"Function"},{"location":"ASL_Module/#description_4","text":"Submodule of ExploreASL ASL Module, that realigns.","title":"Description"},{"location":"ASL_Module/#workflow_4","text":"This submodule estimates motion by spm_realign, which uses a rigid-body registration (3 translations, 3 rotations). It runs ENABLE to reject outliers and provides a visualization. ENABLE , QC and visualizations are based on the Net Displacement Vector ( NDV ) (in mm): according to Pythagorean/Euclydian RMS . Link: jiscmail View this link for image of rotation roll, pitch and yaw: grcnasa This submodule performs the following steps: 1. Estimate motion 2. Calculate and plot position and motion parameters 3. Threshold-free spike definition (based on ENABLE , but with t-stats rather than the threshold p<0.05) 4. Remove spike frames from Nifti","title":"Workflow"},{"location":"ASL_Module/#recommended-usage_4","text":"","title":"Recommended usage"},{"location":"ASL_Module/#interface-definition_4","text":"","title":"Interface definition"},{"location":"ASL_Module/#register-asl","text":"","title":"Register ASL"},{"location":"ASL_Module/#function_5","text":"function xASL_wrp_RegisterASL(x)","title":"Function"},{"location":"ASL_Module/#description_5","text":"Submodule of ExploreASL ASL Module, that registers ASL to T1w (or potentially other structural images).","title":"Description"},{"location":"ASL_Module/#workflow_5","text":"This submodule registers ASL images to T1w space, by using a combination of the registration techniques below. Note that in the absence of raw structural files (i.e. T1 .nii[.gz] or T1_ORI .nii[.gz], it will recreate dummy files from standard space to do this registration. M0-T1w rigid-body -> this works well in 2D EPI sequences PWI-pGM rigid-body -> this is robust across sequences with different readouts and consequently different effective spatial resolutions. With low spatial resolution (e.g. GE 3D spiral product sequence), M0-T1w registration may not work, but PWI-pGM will work. PWI-pGM registration fails with large (vascular) artifacts, therefore this is performed only with relatively low spatial CoV . PWI-pGM affine -> If the spatial CoV is sufficiently low, this can improve the registration These images are registered to ASL templates that were inversely transformed from MNI to the T1w space (& resampled to the ASL space) As this would have an ever higher similarity with the M0 & PWI . This submodule performs the following steps: Administration: ASL4D is dealth with, if motion peaks were removed this is called despiked_ASL4D a default \"OtherList\" is specified. This is used every registration instance, except for removing the ref and src NIfTIs used in the registration instance. Also, inside the registration function the unexisting OtherList NIfTIs are skipped Define paths to the ASL templates Previous registration output files are removed Allow registration without structural data native -> MNI transformation flow field y_T1.nii is smoothed to the effective ASL resolution y_ASL.nii Registration contrasts are dealth with: x.bRegistrationContrast - specifies the image contrast used for registration (OPTIONAL, DEFAULT = 2): 0 = Control -> T1w 1 = CBF -> pseudoCBF from template/ pGM + pWM (skip if sCoV >0.667) 2 = automatic (mix of both) 3 = option 2 & force CBF -> pseudoCBF irrespective of sCoV or Tanimoto coefficient Dummy src NIfTIs are created: mean_control.nii to register with T1w mean_PWI_Clipped.nii to register with pseudoCBF Create reference images, downsampled pseudoTissue Registration Center of Mass Registration ASL -> anat (Control -> T1w ) (this step is only applied if it improves the Tanimoto coefficient) Registration CBF->pseudoCBF (this step is only applied if it improves the Tanimoto coefficient). Also, this step is only applied if the spatial CoV < 0.67. Note that this is usually the case for 3D scans because of their lower effective spatial resolution. x.bAffineRegistration - specifies the ASL-T1w rigid-body registration is followed up by an affine registration (OPTIONAL, DEFAULT = 2) 0 = affine registration disabled 1 = affine registration enabled 2 = affine registration automatically chosen based on spatial CoV of PWI","title":"Workflow"},{"location":"ASL_Module/#recommended-usage_5","text":"","title":"Recommended usage"},{"location":"ASL_Module/#interface-definition_5","text":"","title":"Interface definition"},{"location":"ASL_Module/#resample-asl","text":"","title":"Resample ASL"},{"location":"ASL_Module/#function_6","text":"function xASL_wrp_ResampleASL(x)","title":"Function"},{"location":"ASL_Module/#description_6","text":"Submodule of ExploreASL ASL Module, that reslices native space images to standard space.","title":"Description"},{"location":"ASL_Module/#workflow_6","text":"This submodule resamples native space NIfTIs to standard space, using the deformation fields computed in the structural module after smoothing these transformation fields to the ASL resolution. The applied interpolation is a combination of all transformations (e.g. motion correction, registration to T1w , and transformation of T1w to standard space. This submodule performs the following steps: Create slice gradient image for quantification reference, in case of 2D ASL Reslice ASL time series to MNI space (currently 1.5 mm^3) Create mean control image, if available: This also applies a bilateral filter, if requested. If x.M0 is set as UseControlAsM0, this mean control NIfTI will be copied to an M0 NIfTI (and processed in the M0 submodule). Perform pair-wise subtraction (to create PWI.nii ), in native space Same in standard space Save PWI NIfTI & time-series-related maps ( SD, SNR )","title":"Workflow"},{"location":"ASL_Module/#recommended-usage_6","text":"","title":"Recommended usage"},{"location":"ASL_Module/#interface-definition_6","text":"","title":"Interface definition"},{"location":"ASL_Module/#visual-qc-asl","text":"","title":"Visual QC ASL"},{"location":"ASL_Module/#function_7","text":"function xASL_wrp_VisualQC_ASL(x)","title":"Function"},{"location":"ASL_Module/#description_7","text":"Submodule of ExploreASL ASL Module, that performs several visualizations for QC .","title":"Description"},{"location":"ASL_Module/#workflow_7","text":"This submodule performs several visualizations for visual & quantitative QC . 1. After initial admin 2. It starts with making ASL NIfTIs ready for visualization & conversion to DICOM (though skipped by default) 3. Then it performs a collection of visualizations 4. Visualizes results of the TopUp geometric distortion correction 5. Visualization of slice gradient 6. Visualization & calculation of temporal QC parameters 7. Compute DICE overlap/intersection of ASL brain in FoV & T1w , to calculate coverage 8. Summarize orientation & check left-right flips 9. Collect several other parameters & store in PDF overview","title":"Workflow"},{"location":"ASL_Module/#recommended-usage_7","text":"","title":"Recommended usage"},{"location":"ASL_Module/#interface-definition_7","text":"","title":"Interface definition"},{"location":"About/","text":"About Test","title":"About"},{"location":"About/#about","text":"","title":"About"},{"location":"About/#test","text":"","title":"Test"},{"location":"Functions/","text":"Functions General Functions xASL_Iteration.m Format [bAborted, xOut] = xASL_Iteration(x, moduleName[, dryRun, stopAfterErrors]) Description Parses the settings and runs the DatabaseLoop sub-function. Administration xASL_adm_CatchNumbersFromString.m Format [OutputNumber] = xASL_adm_CatchNumbersFromString(InputString) Description ... xASL_adm_CheckFileCount.m Format [result, files] = xASL_adm_CheckFileCount(path, expr[, mincount, failifmissing]) [result] = xASL_adm_CheckFileCount(...) Description Checks the given PATH for files corresponding to the SPM_SELECT regular expression EXPR . Returns if the number of files is equal to or higher than MINCOUNT . If FAILIFMISSING is true and not enough files, then throw and error. If everything goes ok and second output argument is specified then return also the list of files. xASL_adm_CheckPermissions.m Format [FilesList, FilesExeList, FoldersList] = xASL_adm_CheckPermissions(InputPath[, FilesExecutable]) Description This function does a recursive search through the root folder & makes a list of the attributes of all files and folders. It tries to reset the attributes to what we desire, which is by default: 664 for files (meaning only reading & writing for users & group, & read-only for others) 775 for folders (meaning reading, writing & opening for current user & current group, & for others only reading & opening) For executable files we also want 775. Note that the permission to 'execute a folder' means opening them. DataOK checks data permissions. ExeOK checks executable permissions. DataOK also includes executable permissions for folders. This runs recursively (but currently skips the contents of the root-folder) . xASL_adm_CheckSPM.m Format [spm_path, spm_version] = xASL_adm_CheckSPM([modality, proposed_spm_path, check_mode]) [spm_path] = xASL_adm_CheckSPM(...) xASL_adm_CheckSPM(...) Description Checks if the spm function exists and if the reported version matches our development version ( SPM8 or SPM12 ). If the spm toolbox is not available yet, it will try the PROPOSED_SPM_PATH (if specified) or the user selected directory and add it to PATH . The function will fail if SPM cannot be found or if detecting an unsupported version. xASL_adm_CleanUpBeforeRerun.m Format xASL_adm_CleanupBeforeCompleteRerun(AnalysisDir, iModule, bRemoveWMH, bAllSubjects, SubjectID) Description This function (partly) reverts previous ExploreASL runs, deleting derivatives, while keeping raw data intact. if bAllSubjects==true, then all subjects and all module derivatives will be removed. This function performs the following steps: If a Population folder doesn't exist yet but dartel does, rename it Remove whole-study data files in AnalysisDir if bAllSubjects Remove lock files/folders for reprocessing Restore backupped _ORI (original) files Delete native space CAT12 temporary folders (always, independent of iModule) Remove native space files for iModule Remove standard space files for iModule Remove population module files Remove or clean up stored x-struct & QC file -> THIS HAS NO SESSION SUPPORT YET NB: still need to add xASL_module_func & xASL_module_dwi for EPAD xASL_adm_CompareDataSets.m Format [RMS] = xASL_adm_CompareDataSets(RefAnalysisRoot,SourceAnalysisRoot,x,type,mutexState) Description Compare data sets is used to ... type 0: Only save type 1: Save and evaluate type 2: Only evaluate xASL_adm_CompareLists.m Format [NewList] = xASL_adm_CompareLists(list1, list2) Description ... xASL_adm_ConvertDate2Nr.m Format [Nr DayInYear] = xASL_adm_ConvertDate2Nr(TempDate) Description Converts date to number input mmdd -> output mm (with days in fractions/floating point). Inverse from ConvertNrDate. xASL_adm_ConvertNr2Time.m Format Time = xASL_adm_ConvertNr2Time(Nr) Description Converts number to time input hh (with minutes in fractions/floating point) -> output hhmm. Inverse from xASL_adm_ConvertTime2Nr. xASL_adm_ConvertSubjSess2Subj_Sess.m Format [iSubj iSess] = xASL_adm_ConvertSubjSess2Subj_Sess(nSessions, iSubjSess) Description Converts combined SubjectSession index to subject & session indices. Useful for data lists in ExploreASL. xASL_adm_ConvertTime2Nr.m Format Nr = xASL_adm_ConvertTime2Nr(Time) Description Converts time to number input hhmm -> output hh (with minutes in fractions/floating point). Inverse from xASL_adm_ConvertNr2Time. xASL_adm_CopyMoveFileList.m Format [List] = xASL_adm_CopyMoveFileList(OriDir, DstDir, StrRegExp, bMove[, bDir, bRecursive, bOverwrite, bVerbose]) Description Moves a file to a file, a file to a directory, or a directory to a directory. It keeps the initial extensions, no unzipping or zipping after the move. But it makes sure that only one of .nii and .nii.gz exists in the destination directory. Useful to split a large database. xASL_adm_CorrectName.m Format strOut = xASL_adm_CorrectName(strIn[, bOption, strExclude]) Description Finds and replaces all non-word characters either by empty space or by an underscore. Optionally leaves in few selected special characters. Note that if '_' is excluded from replacement, but option 2 is on, then underscores are replaced anyway. xASL_adm_CreateCSVfile.m Format xASL_adm_CreateCSVfile(CSVfilename,CSVdata) Description Creates a CSV file that can be opened with excel from your data. xASL_adm_CreateFileReport.m Format x = xASL_adm_CreateFileReport(x, bHasFLAIR, bHasMoCo, bHasM0, bHasLongitudinal) Description Prints a summary of created files or the individual modules (i.e. Structural, Longiutudinal & ASL modules). Provides a quick check to see what has been skipped, an whether all files are present. This script iterates across: Native space 1) subject and 2) session files, Resampled 3) subject and 4) session files, 5) Lock files and 6) QC Figure files. For all we perform a: A) Count of the files present, summarized in FileReportSummary.csv B) List of the missing files in \"Missing*.csv\" files PM: Simplify/optimize this code, to make filename variable changing, search within subject-directories, etc. Combine the parts searching for missing & summarizing count. xASL_adm_DefineASLResolution.m Format x = xASL_adm_DefineASLResolution(x) Description ... xASL_adm_DefineASLSequence.m Format [x] = xASL_adm_DefineASLSequence(x) Description This ExploreASL function tries to check what ASL sequence is being processed, if this was not already defined in x.Sequence. It does so by checking known combinations of readout dimensionality (x.readout_dim) and vendor, knowing the product sequences of the vendors. xASL_adm_DeleteFilePair.m Format filepaths = xASL_adm_DeleteFilePair(path, ext1[, ext2 [, ext3 ...]]) xASL_adm_DeleteFilePair(path, ext1[, ext2 [, ext3 ...]]) Description Delete the file given in PATH, and also deletes files with the same name, but with extension given in EXT1, and potentially also EXT2, EXT3... xASL_adm_Dicom2Parms.m Format [parms pathDcmDictOut] = xASL_adm_Dicom2Parms(inp[, parmsfile, dcmExtFilter, bUseDCMTK, pathDcmDictIn]) Description The function goes through the INP files, reads the DICOM or PAR/REC files and parses their headers. It extracts the DICOM parameters important for ASL, makes sure they are in the correct format, if missing then replaces with default value, it also checks if the parameters are consistent across DICOM files for a single sequence. xASL_adm_FindByRegExp.m Format xasl_adm_FindByRegExp(root, dirSpecs[, varargin]) Description Recursively find files in the root directory according to the dirSpecs. xASL_adm_FindStrIndex.m Format INDEX = xASL_adm_FindStrIndex(ARRAY, STRING) Description Similar to find, but then for a cell array filled with strings. Only takes 4 dimensions. xASL_adm_GetFsList.m Format RES = xASL_adm_GetFsList([strDirectory, strRegEx, bGetDirNames, bExcludeHidden, bIgnoreCase, nRequired]) Description List files or directories from a given path. And optionally uses regular expressions to filter the result with options to exclude hidden files, ignore case, and set a minimal requirement on the number of results. Sorts the results at the end. xASL_adm_GetNumFromStr.m Format num = xASL_adm_GetNumFromStr(str) Description Obtains single number from string. CAVE there should only be one number! xASL_adm_GetPhilipsScaling.m Format scaleFactor = xASL_adm_GetPhilipsScaling(pathParmsMat,pathNifti) Description This script provides the correct scaling factors for a NIfTI file. It checks the header of the NIfTI that normally has the same scaling as RescaleSlope in DICOM, it checks if dcm2nii (by the info in JSON) has already converted the scale slopes to floating point. And if not, the derive the correct scaling factor to be applied. xASL_adm_GetUserName.m Format UserName = xASL_adm_GetUserName() Description ... xASL_adm_Hex2Num.m Format outNum = xASL_adm_hex2num(inStr) Description Takes a hexadecimal string and converts it to number. Works also when the string contains escape characters, and for single-floats and for a little and big endian. If containing 8 and less characters than treat as float, if more than as double. xASL_adm_LesionResliceList.m Format [INname, OUTname] = xASL_wrp_LesionResliceList(x,bLesion_T1,bLesion_FLAIR,bROI_T1,bROI_FLAIR) Description Creates list of structural image paths to reslice. xASL_adm_Load4DMemMapping.m Format LoadFile = xASL_adm_Load4DMemMapping(x, WhichModality) Description Part of ExploreASL analysis module. Loads data & maps it to memory mapping file on disc, if not done before. xASL_adm_LoadParms.m Format [Parms, x, Oldx] = xASL_adm_LoadParms(ParmsPath[, x, bVerbose]) Description This function loads the internal memory x struct, any legacy *_parms.mat sidecar, any *.json BIDS sidecar, to use scan-specific parameters for image processing/quantification. Also, per BIDS inheritance, any x.S.SetsID parameters (from participants.tsv) are loaded as well. This function performs the following steps: Load .mat parameter file Load JSON file Deal with warnings Find fields with scan-specific data in x.S.Sets, and use this if possible (per BIDS inheritance) Sync Parms.* with x.(Q.)* (overwrite x/x.Q) Fix M0 parameter if not set xASL_adm_LoadX.m Format [x[, IsLoaded]] = xASL_adm_LoadX(x, Path_xASL[, bOverwrite]) Description This function loads x.Output & x.Output_im struct fields from the x.mat on the hard drive & adds them to the current x struct located in memory. If it didnt exist in the x.mat, it will set IsLoaded to false, which can be catched externally & a warning issued if managed so in the calling function. If it didnt exist in the memory x struct, or bOverwrite was requested, the contents of x.mat will be loaded to the memory x struct xASL_adm_OrderFields.m Format outStruct = xASL_adm_OrderFields(inStruct,orderStruct) Description Order fields in the structure inStruct to match {{orderStruct}}, unmatching fields in inStruct are copied as they are at the end, unmatching fields in orderStruct are ignored. This is just a cosmetic change and no values are edited. xASL_adm_OtherListSPM.m Format [OtherListSPM, OtherListOut] = xASL_adm_OtherListSPM(OtherList, bList4D) Description bPadComma1 is to add the ,1 to the end of the pathstring, which SPM uses to assign the first image of a 4D image array (OPTIONAL, DEFAULT = true) bList4D: boolean, true for listing multiple 4D volumes separately in the list (OPTIONAL, DEFAULT=true). xASL_adm_Par2Parms.m Format parms = xASL_adm_Par2Parms(pathPar, pathParms[, bRecreate]) Description Opens the Philips type PAR file. Reads the relevant DICOM headers and saves them to .MAT file. Only recreates an existing file if bRecreate option is set to TRUE. xASL_adm_ParReadHeader.m Format info =xASL_adm_ParReadHeader(filename) Description Function for reading the header of a Philips Par / Rec MR V4.* file. xASL_adm_Remove_1_SPM.m Format [OtherList] = xASL_adm_Remove_1_SPM(OtherList) Description Remove ,1 at end of OtherLists, if exists. These are appended in CoregInit, OldNormalizeWrapper etc, since this should allow 4rd dim (e.g. as in ASL4D). xASL_adm_ReplaceSymbols.m Format strOut = xASL_adm_ReplaceSymbols(strIn, symbolTable[, bracketLeft, bracketRight]) Description It takes the STRIN on input, then looks for symbols between BRACKETLEFT and BRACKETRIGHT and replaces these symbols in in the string by the values provided in the SYMBOLTABLE as SYMBOLTABLE.SYMBOL, SYMBOLTABLE.D.SYMBOL, or SYMBOLTABLE.P.SYMBOL xASL_adm_ResetVisualizationSlices.m Format [x] = xASL_adm_ResetVisualizationSlices(x) Description Removes any predefined slices that should be visualized, allowing to show the default slices. Comes in handy when different pipeline visualization parts are repeated. xASL_adm_SaveJSON.m Format xASL_adm_SaveJSON(data, jsonFileName) Description Saves the values in the structure 'data' to a file in JSON format. xASL_adm_UnzipOrCopy.m Format unpackedFiles = xASL_adm_UnzipOrCopy(srcDir, wildCard, destDir [, bOverwrite]) Description This is a simple wrapper function to (g)unzip one or more files to the specified destination directory. Existing files or directories will not be overwritten, unless forced with bOverwrite. A regular file-copy will be used if the source files don't have gz or zip filename extensions. xASL_adm_Voxel2RealWorldCoordinates.m Format [X Y Z] = xASL_adm_Voxel2RealWorldCoordinates(X,Y,Z,VoxelSize) Description Converts MNI coordinates from voxel coordinates/indices. Assumes X Y Z = LR LeftRight AP AnteriorPosterior IS InferiorSuperior. VoxelSize should be [1 3]-sized input. xASL_adm_ZipFileList.m Format filepaths = xASL_adm_ZipFileList(strDirectory, strRegExp[, bRecurse, bUseGzip, nRequired]) xASL_adm_ZipFileList(strDirectory, strRegExp[, bRecurse, bUseGzip, nRequired]) Description Zip the files that match regular expression STRREGEXP in the given directory STRDIRECTORY. Zips recursively if specified in BRECURSE. Zips all files unless the number is specified by NREQUIRED, if the number is not met, then does not zip anything and throws an error. xASL_adm_uiGetInput.m Format [Parms] = xASL_adm_uiGetInput(Parms) Description Checks whether input fields are present, or requests them. BIDS xASL_bids_Add2ParticipantsTSV.m Format xASL_bids_Add2ParticipantsTSV(DataIn, DataName, x, bOverwrite) Description This function adds metadata/statistical variables to the participants.tsv in the root/analysis folder, by the following steps. This function will iterate over Data provided at DataIn and fill them in the participants.tsv, overwriting if allowed. Empty data is filled in as 'n/a', and the first column \"participants_id\" is sorted for participants. This function runs the following steps: Admin - Validate that there are not too many columns Admin - Detect nSubjectsSessions Admin - Load pre-existing participants.tsv or create one Admin - Get column number of data Add data to CellArray Sort rows on subjects Fill empty cells Write data to participants.tsv xASL_bids_Dicom2JSON.m Format [parms pathDcmDictOut] = xASL_bids_Dicom2Parms(inp[, parmsfile, dcmExtFilter, bUseDCMTK, pathDcmDictIn]) Description The function goes through the INP files, reads the DICOM or PAR/REC files and parses their headers. It extracts the DICOM parameters important for ASL, makes sure they are in the correct format, if missing then replaces with default value, it also checks if the parameters are consistent across DICOM files for a single sequence. xASL_bids_InsertJSONFields.m Format [ChildJSON] = xASL_bids_InsertJSONFields(ParentJSON, ChildJSON[, Fields2Skip]) Description This function takes all parameters from the \"parent\" JSON & moves them into the \"child\" JSON. In case of co-existence of a field with different values, then the value in the child JSON will prevail, per BIDS inheritance. This function runs the following steps: Load JSON or parms.mat (legacy), if the inputs were paths Insert the fields Save a new JSON file (if ChildJSON was a path) xASL_bids_PARREC2JSON.m Format parms = xASL_adm_Par2Parms(pathPar, PathJSON) Description Opens the Philips type PAR file. Reads the relevant DICOM header fields and adds them to the .json sidecar file. xASL_bids_parms2BIDS.m Format outBids = xASL_bids_parms2BIDS(inParms[, inBids, bOutBids, priorityBids]) Description This functions takes two parameter structures and merges them. At the same time, renames all fields according to the output type (note that only some fields have two standardised names different between the two formats. In case of duplicities, takes the field value from the preferred format. Also takes into account that the units in BIDS are s, but in xASL ms. This function performs the following steps: Define field names that need to be convert/renamed/merged Convert XASL fields to the output format (BIDS or XASL) Convert BIDS fields to the output format (BIDS or XASL) Merge the BIDS and XASL fields, convert field values FSL xASL_fsl_RunFSL.m Format [x] = xASL_adm_RunFSL(FSLCommand, x[, OutputZipping]) Description This function runs an FSL command from ExploreASL: Checking the FSL dir Manage CUDA/CPU parallelization (currently disabled, WIP) Setting up FSL environment Running the command Supports .nii & .nii.gz, Linux, MacOS & Windows (WSL) xASL_fsl_SetFSLdir.m Format [FSLdir[, x, RootWSLdir]] = xASL_adm_SetFSLdir(x, bUseLatestVersion) Description This function finds the FSLdir & puts it out, also in x.FSLdir to allow repeating this function without having to repeat searching. If the FSLdir & RootFSLDir are already defined in x.FSLdir & x.RootFSLDir, this function is skipped. Supports Linux, MacOS & Windows (WSL), & several different default installation folders for different Linux distributions xASL_fsl_TopUp.m Format xASL_fsl_TopUp(InDir[, ScanType], x) Description This function runs FSL TopUp. It assumes that there are 2 TopUp images, i.e. 1 blip up & 1 blip down. Admin: manage ScanType, NIfTI paths, create TopUp parameter file for image to apply TopUp to & for the TopUp NIfTIs, delete files from previous run, define the image with the same acquisition parameters as TopUp (does the image we apply TopUp to, have the Blip up or down?) Register images to image that we apply TopUp to (registration between blip up/down images is performed by TopUp) Run TopUp estimate (i.e. estimate the geometric distortion field from B0 NIfTI & parameters file), this takes quite long. Also has a x.Quality=0 option that is very fast but inaccurate, to try out this pipeline part. Before TopUp, NaNs (e.g. from resampling) are removed from the images TopUp is run with default settings Apply TopUp Imaging xASL_im_BilateralFilter.m Format [ovol] = xASL_im_BilateralFilter(volIM, mask, VoxelSize, x) Description This function runs a spatial lowpass temporally highpass filter, and removes outliers within this signal, and adapts the time-series accordingly. xASL_im_CenterOfMass.m Format xASL_im_CenterOfMass(PathNIfTI, OtherList, AllowedDistance) Description This function estimates the center of mass of the image matrix, and if this is too far off the current orientation matrix center, the center will be reset. This fixes any incorrect orientation outputted by the scanner. The realignment is only applied when any of the X/Y/Z dimensions have a higher offset than AllowedDistance. xASL_im_CleanupWMHnoise.m Format xASL_im_CleanupWMHnoise(InputPath, OutputPath, MinLesionVolume, pThresh) Description Threshold white matter lesions, acknowledging the fact that they may be confluent with subresolution connection through a dilation. This part is executed conservatively, as FLAIR hyperintensities inside the GM can be erroneously segmented as WMH, and should not be lesion-filled (otherwise these cannot be fixed later in the Structural module). Note that LST lesion filling expects a probability map, doesnt work nicely with binary mask xASL_im_ClipExtremes.m Format [NewIM] = xASL_im_ClipExtremes(InputIm, ThreshHigh, ThreshLow, bVerbose) Description Clips image to given percentile. The percentile is found using non-zeros sorted intensities, so both isfinite & non-zeros. xASL_im_Column2IM.m Format [ImageOut] = xASL_im_Column2IM(ColumnIn, BrainMask) Description This function \"decompresses\" an image matrix (or multiple matrices) from a single-dimensional column, by reconstructing the image matrix from the voxel positions within the BrainMask. NB: Important to use the same BrainMask as used for converting the image matrix to the column! See also: xASL_im_IM2Column.m The mask mostly used for xASL_im_IM2Column is x.WBmask, which completely engulfes pGM, pWM & pCSF. xASL_im_CompareNIfTIResolutionXYZ.m Format [IsEqualResolution] = xASL_im_CompareNIfTIResolutionXYZ(PathNIfTI1, PathNIfTI2) Description This function checks whether the X, Y and Z resolution of a NIfTI with any number of dimensions is equal. It rounds for 2 floating points, for both NIfTIs, to ensure that the same precision is compared. xASL_im_ComputeDice.m Format DiceCoeff = xASL_im_ComputeDice(imA, imB) Description Calculate Dice coefficient of image overlap. xASL_im_CreateASLDeformationField.m Format xASL_im_CreateASLDeformationField(x, bOverwrite, EstimatedResolution) Description This function smooths a transformation flow field to a lower resolution. Usually, we use a high resolution anatomical image (e.g. 3D T1w ) to obtain the flowfields from native space to standard space, and apply these to the lower resolution ASL images. Because of the resolution differences, the flowfields need to be downsampled/smoothed, to avoid deformation effects that are crispier than the functional image that is investigated. This function performs the following steps: Obtain resolutions Fill NaNs at edges y_T1.nii flowfield to prevent interpolation artifact Smooth flowfield Fill NaNs at edges y_ASL.nii Note that if the resolution of ASL is not significantly (i.e. >0.5 mm in any dimension) lower than T1w, the y_T1.nii is copied to y_ASL.nii xASL_im_CreatePseudoCBF.m Format xASL_im_CreatePseudoCBF(x, spatialCoV) Description This function creates a pseudo-CBF image from mean CBF template, arterial transit time (ATT) bias field & vascular artifacts, weighted through spatial CoV The first part of this code puts templates in the native space and creates a pseudoCBF image from a downsampled pGM & pWM tissue (PseudoTissue). The latter is used for registration but also as reference for the template registration, to speed this up. The second part of this code computes a pseudoCBF image based on the pseudoTissue & the CBF templates of CBF, ATT biasfield and vascular peaks, based on spatial CoV. This submodule performs the following steps: Create the pseudoTissue CBF reference image, if it doesnt exist already Create the native space copies of ASL templates, if they dont exist already Spatial CoV input argument check Load native space copies of templates Create pseudoTissue from segmentations, mix this with the mean CBF template depending on spatial CoV Create pseudoCBF reference image used for CBF-based registration Scale mean_PWI_Clipped source image to the same range as PseudoCBF xASL_im_CreateSliceGradient.m Format xASL_im_CreateSliceGradient(x) Description Create slice gradient in same space as input file Reslice slice gradient to MNI (using existing ASL matrix changes from e.g. registration to MNI, motion correction, registration to GM) Creating average slice gradient xASL_im_DecomposeAffineTransformation.m Format [M, P] = xASL_im_DecomposeAffineTransformation(Mtransformation) Description This function splits a transformation matrix into individual components, which can be useful to guide the SPM reslicing. The components are the same as in spm_(i)matrix.m, except for the shearing: these are included in the rotations, and the 90 degree rotations, these are separated. Reason for the separation of the 90 degree rotations, is that these indicate if orientations (transversal, coronal & sagittal) have been switched in the NIfTI. This can be useful to correct for any erroneous 90degree rotations from registration, or to put two images in the same orientation order or voxelsize without applying their subtle realignment (e.g. for manipulating registration references) THEORY 90 degree rotations: Any rotation will always swap the other dims (X rotation swaps Y/Z, Y rotation swaps X/Z etc.) because they are perpendicular (haaks) Dims X Y Z care for LR, AP and IS translation. - X-rotation will rotate the transverse slice (LR <-> AP) swapping Y (coronal) & Z (saggital) - Y-rotation will rotate the coronal slice (IS <-> LR) slice, swapping X (transversal) and Z (sagittal) - Z-rotation will rotate the sagittal slice (AP <-> IS) swapping X (transversal) and Y (sagittal) E.g., MPRAGE is acquired in sagittal slices, and ASL/fMRI/BOLD in transversal slices. This is an Y rotation (you look into the coronal plane, rotate this, which will swap the sagittal slices into transversal) This function performs the following steps: Start with an output P and M struct Obtain translations Obtain zoom Obtain 90degree rotations Obtain subtle rotations & shearing Check the rounding errors of the decomposition xASL_im_DetermineFlip.m Format [QCstruct] = xASL_im_DetermineFlip(x,iS,PathOrientationResults,QCstruct) Description Check determinants, should be the same before & after registration, otherwise a left-right flip is applied This is not visible, but detrimental for image analysis/stats. xASL_im_DilateErodeFull.m Format new_mask = xASL_im_DilateErodeFull(mask,type,kernel) Description Runs dilation or erosion on a binary mask in full three dimensions It uses its own dilate_erode function and crops the image so that it contains only the mask. Works only with odd sized kernels. xASL_im_DilateErodeSeparable.m Format new_mask = xASL_im_DilateErodeSeparable(mask,type,kernel_x,kernel_y,kernel_z) Description Runs dilation or erosion on a binary mask separably in three dimensions It uses its own dilate_erode function and crops the image so that it contains only the mask. Works only with odd sized kernels xASL_im_DilateErodeSphere.m Format el = xASL_im_DilateErodeSphere(R) Description 3D structuring element (binary) sphere. xASL_im_DummyOrientationNIfTI.m Format xASL_im_DummyOrientationNIfTI(PathSrc, PathRef, PathDummyOut[, bApplyRotationMinor, bApplyRotation90, bApplyZoom, bApplyTranslation]) Description This function creates a dummy image as reference for xASL_spm_reslice, allowing to only apply specific parts of the transformation between the two images. E.g. only the rotation, or only the zooming. This can be useful to correct for any erroneous rotations from registration, or to put two images in the same space without applying their realignment. This function performs the following steps: Load orientations & calculate transformation Calculate the desired transformation Calculate new orientation matrix Calculate the new image size Save the dummy NIfTI xASL_im_EstimateResolution.m Format [resFWHM, resSigma,resErr,imSmo,imMask] = xASL_im_EstimateResolution(imCBF,imGM,imWM,imMaskOrig,PSFtype,maxIter) Description NB: everything in this code is in voxels, not in mm xASL_im_Flip.m Format [MatrixOut] = xASL_im_Flip(MatrixIn, varargin) Description Backwards compatibility for flipping left-right in standard space (NB: this can be different than in native space!). xASL_im_IM2Column.m Format [ColumnOut] = xASL_im_IM2Column(ImageIn, BrainMask[, ApplyShiftDim]) Description This function \"compresses\" an image matrix (or multiple matrices) for optimization of memory and CPU resources. The output column only includes voxels that lie within the BrainMask. This excludes extracranial zero-information voxels from computations and memory use. NB: Important to use the same BrainMask for converting the column back to an image matrix! See also: xASL_im_Column2IM.m The mask mostly used for xASL_im_IM2Column is x.WBmask, which completely engulfes pGM, pWM & pCSF xASL_im_JointHist.m Format imHist = xASL_im_JointHist(imA,imB[,imMask,minA,maxA,minB,maxB,nBins]) Description It calculates a joint histogram of two images of any dimensions over a mask of the same size. The boundaries and number of bins can either be given or min and max values are used. Values outside of the bins are counted to the first/last bin. xASL_im_Lesion2CAT.m Format LesionPathOut = xASL_im_Lesion2CAT(PathIn) Description For all lesion masks in the anatomical directory, load them, merge them and save them for the CAT segmentation. If there are no lesions found, the images are untouched. xASL_im_Lesion2Mask.m Format LesionIM = xASL_im_Lesion2Mask(LesionPath, T1path, pGMpath, pWMpath, x) Description For a standard space lesion mask (or map), this stores the lesion mask, and in additional its perimask (15 mm) and contralateral mask, as 2nd and 3rd volumes. It plots the masks on a T1 image, and masks the new masks with the subjects' brainmask (pGM+pWM). xASL_im_M0ErodeSmoothExtrapolate.m Format [ImOut] = xASL_im_M0ErodeSmoothExtrapolate(ImIn, x) Description This function erodes, smooths & extrapolates M0 in standard space. It assumes that the M0 image is in standard space & that the GM & WM probability maps are aligned. Here, we mask the M0, to remove high CSF signal and low extracranial signal, enabling us to smooth the image without inserting wrong signal. See also the ExploreASL manuscript for a more extensive explanation. This function performs the following steps: Mask: Load segmentations, create structural mask Mask: Create intensity-based mask to remove extracranial signal Mask: Erode the combined masks Mask: Determine any odd borders Smoothing Extrapolating only Scale back to the GM M0 Print visual QC figure A visual QC figure is created, showing the M0 image processing steps for a single transversal slice (slice 53 in 1.5 mm MNI standard space) OutputFile = fullfile(x.D.M0regASLdir,['M0_im_proc_' x.P.SubjectID '.jpg']); The original M0 image (a) is masked with a (pGM+pWM)>50% mask (b) eroded with a two-voxel sphere to limit the influence of the ventricular and extracranial signal (c) and thresholded to exclude significantly high (i.e. median + 3*mean absolute deviation (MAD)) border region values (d) This masked M0 image is smoothed with a 16x16x16 mm full- width-half-maximum Gaussian filter (Mutsaerts et al., 2018) (e) after which the signal at the border is smoothly extrapolated until the full image is filled (f). Whereas the masking avoids mixing with cerebrospinal fluid or extracranial signal, the extrapolation avoids M0 division artifacts xASL_im_MaskNegativeVascularSignal.m Format [NegativeMask, TreatedCBF] = xASL_quant_DetectNegativeVascularSignal(x) Description This function segments clusters with significant negative ASL signal. This can be tricky as there is also the negative tail of Gaussian noise from the ASL subtraction. The image feature we use here, is that negative vascular signal will be a relatively large region with significant median negative value, whereas noise will be regions with relatively small negative signal. Negative signal from wrong background suppression timing (e.g. in the first slice with 2D EPI) can be masked out with this as well. The procedure works as follows: 1) Obtain mask of negative voxels within pGM>0.5 mask 2) Obtain distribution of subzero clusters 3) Define the negative threshold 4) Create mask by thresholding whole image Note that the definition of the threshold is obtained within the GM only, but that this threshold is applied to the full image xASL_im_MaskPeakVascularSignal.m Format [MaskIM, CBF] = xASL_quant_VascularContrast(PathCBF, Path_M0, CompressionRate, ClipThresholdValue, bClip) Description This function searches for an acceptable high threshold as definition of high intra-vascular ASL signal. It also allows to compress the values here (when bClip==true). Compression retains some variability, but limits their outlying influence on statistics. The procedure works as follows: Segment GM on ASL image at 80th percentile of CBF image distribution For PWI & CBF images, select voxels higher than median + ClipThresholdValue MAD Vascular artifacts will have a high intensity in both images, whereas errors by division by M0 will only have a high intensity on the M0 image, and high values due to a biasfield will only be noticeable on the PWI image Combine the two created masks Obtain average clipping value from selected voxels from the combined masks Apply compression if requested. If not, output image will have NaNs for intra-vascular voxels. Note that the definition of the threshold is obtained within the GM only, but that this threshold is applied to the full image to also remove extracranial extreme values. xASL_im_Modulation.m Format xASL_im_Modulation(x) Description Combines the transformations to create Jacobians, & multiplies the standard space segmentations with these to create volumetric images for volumetric analyses. xASL_im_NormalizeLabelingTerritories.m Format image_out = xASL_im_NormalizeLabelingTerritories( imageIN, GMmask, x) Description Normalizes per perfusion territory mask should be GM mask. xASL_im_PCA.m Format [pc, score, eigenvalues, tsquare, loadings, Xmean] = xASL_im_PCA(dataIn) Description ... xASL_im_PVCbspline.m Format [imPVEC,imCBFrec,imResidual,FWHM] = xASL_im_PVCbspline(imCBF,imPV,bsplineNum) Description PVEc correction of ASL data using prior GM-,WM-partial volume maps. Follows the principles of the PVEc algorithm by I. Asllani (MRM, 2008). The PV-corrected CBF_GM and CBF_WM maps are approximated using an uniformly sampled cubic B-splines. Free for research use without guarantee. Created by Jan Petr, j.petr@hzdr.de xASL_im_PVCkernel.m Format [imPVEC,imCBFrec,imResidual] = xASL_im_PVCkernel(imCBF, imPV,kernel,mode) Description PVEc correction of ASL data using prior GM-,WM-partial volume maps. Follows the principles of the PVEc algorithm by I. Asllani (MRM, 2008). Free for research use without guarantee. If used in a study or publication. Please, acknowledge the author. Created by Jan Petr, j.petr@hzdr.de xASL_im_PreSmooth.m Format pathOut = xASL_im_PreSmooth(pathRef,pathSrc[,pathSmo,resRef,resSrc,srcAffinePath, bInvAffine]) Description It assumes that the FWHM is equal to voxel size, unless the real resolution is given. Then takes into account the voxel sizes and orientation difference between the volumes, but performs the smoothing according to the given real resolution (it is possible to supply the resolution for just one image) - this should be helpful primarily when the It creates a Gaussian covariance matrix for the reference, transforms it according to the difference between the two images a produces the Gaussian covariance matrix of the pre-smoothing in the source space. Then it performs the smoothing. The following steps are performed: 1) Obtain the voxel size 2) Skip this function if reference resolution is equal to, or lower than source resolution 3) Deal with affine transformation 4) Obtain the transformation matrix from the Reference to the Source space 5) Apply the smoothing filter on the source image(s) 6) Save the smoothed image xASL_im_ProcessM0Conventional.m Format [Corr_M0] = xASL_im_ProcessM0Conventional(ImIn, x) Description This function uses the conventional M0 masking, and only a little smoothing, following what Philips uses for its 3D {{GRASE}}. Advantages of the newer M0 processing in ExploreASL are the lack of use of M0 threshold-based masking, the removal of high CSF values and higher SNR for ASL division. xASL_im_ProjectLabelsOverData.m Format OutputIM = xASL_im_ProjectLabelsOverData(DataIM,LabelIM,x,ScaleFactorData,ScaleFactorLabel) Description This script projects labels over an image, but works only in 2D. Make sure to make a 2D image from a 3D or 4D image using xASL_vis_TransformData2View.m can be used in combination with xASL_vis_Imwrite.m xASL_im_ResampleLinearFair.m Format [output_res]=xASL_im_ResampleLinearFair(im_input,newsize) Description Downsample (or upsample, works similarly) old_res image to low_res image, trilinear. NB: new_res should fit exactly integer fold in old_res NB: all dimensions of new_res should have equal size xASL_im_RestoreOrientation.m Format xASL_im_RestoreOrientation(PathNIfTI) Description This function reverts the NIfTI header orientation matrix to the original orientation from the scanner/dcm2nii conversion. xASL_im_SkullStrip.m Format xASL_im_SkullStrip(InPath, PathMNIMask, x, OutPath) Description Creates skull-stripped T1w image based on MNI -> native space registration from segmentation. xASL_im_Smooth3D.m Format [imSmo,imGaussX,imGaussY,imGaussZ] = xASL_im_Smooth3D(sigma,imIn,PSFtype) Description ... xASL_im_Upsample.m Format xASL_im_Upsample(PathOrig, PathDest, NewVoxelSize, LeaveEmpty, PaddingDim, Kernel) Description Upsamples an ASL image, without changing the orientation matrix, which can be used e.g. for PVEc in higher resolution but same space. xASL_im_ZeroEdges.m Format [IM] = xASL_im_ZeroEdges(IM[, EdgeThicknessPerc]) Description Resampling can sometimes give some strange errors near image edges. These should be NaNs, but sometimes can be zeros or ones, or even weird numbers. For resampling, NaNs should be set to 0 (this is done in another function) as they can influence the resampling (depending on the transformation matrix). To be sure that the edges are nicely fixed, this function sets a border at the image matrix edges to zero. xASL_im_dilateROI.m Format xASL_im_dilateROI(PathIn, PathTemp) Description ... xASL_im_rotate.m Format rotated = xASL_im_rotate(im, angle) Description Simple rotation of the first two dimension of a ND image by 0, 90, 180, 270 degrees. xASL_import_json.m Format [x] = xASL_import_json(DataParFile) Description This function reads in a DATA_PAR file and creates the x structure. The name of the DATA_PAR file is given as a string or character array. The output is the x structure. If the DATA_PAR file is the dataset_description.json file of the BIDS standard, the x structure is created according to BIDS. Initialization xASL_init_ConvertM2JSON.m Format [PathJSON] = xASL_init_ConvertM2JSON(PathM) Description This function converts and replaces the legacy data parameter m-format by a JSON file. A DataPar.m was the settings/parameter file, specific to a dataset to be processed by ExploreASL, now replaced to JSON by BIDS. Note that the deployed/compiled version of ExploreASL requires the JSON file, this function should not be compiled along. This function performs the following steps: 1) Run the m-file to load parameters 2) Escape characters that are illegal in JSON 3) Write the JSON xASL_init_DefaultEffectiveResolution.m Format [EffectiveResolution] = xASL_init_DefaultEffectiveResolution(PathASL, x) Description This ExploreASL module provides an educated guess on the effective spatial resolution of ASL. This may depend on the combination of acquisition PSF, reconstruction filter, head motion. Note that the derived/processed images may have a lower effective resolution because of smoothing effects from interpolation. Note that this remains an educated-guess, the actual FWHM may still differ, especially for 3D GRASE sequences, where e.g. the choice of number of segments can affect the smoothness. This function conducts the following steps: 1) Educated-guess FWHM 2) Attempt accounting for in-plane interpolation in reconstruction 3) Calculate and report effective spatial resolution xASL_init_DefineStudyData.m Format [x] = xASL_init_DefineStudyData(x) Description This initialization wrapper initializes the parameters for this pipeline run, i.e. subjects, sessions (runs), timepoints (visits), exclusions, sites, cohorts etc. Note that ASL sessions are defined here as what BIDS calls \"runs\". The \"longitudinal_Registration functions here manage different TimePoints, which is what BIDS calls \"visits\". With different structural scans, from the same participant. This is managed by subject name suffixes _1 _2 _n, and can be used for comparing visits in the population module, or running SPM's longitudinal within-subject registration. Parallelization is allowed here by calling ExploreASL different times, where it divides the subjects/images for processing across the nWorkers, using iWorker as the reference for the part that the current ExploreASL call will process. This requires having a Matlab license that can be started multiple times on a server, or alternatively running the ExploreASL compilation, and doesn't require the Matlab parallel toolbox. This function exists from the following parts: Manage included & excluded subjects Create dummy defaults (exclusion list, ASL sessions) Create list of total baseline & follow-up subjects, before exclusions Create TimePoint data-lists Manage exclusions Add sessions as statistical variable, if they exist Parallelization: If running parallel, select cases for this worker Add Longitudinal TimePoints (different T1 volumes) as covariate/set, after excluding Load & add statistical variables Make x.S.SetsOptions horizontal if vertical by transposing Create single site dummy, if there were no sites specified Check for time points sets Create list of baseline & follow-up subjects (i.e. after exclusion) Check what excluded from which TimePoints xASL_init_FileSystem.m Format [x] = xASL_init_FileSystem(x) Description This function initializes the file system used throughout ExploreASL, for processing a single dataset/scan. It is repeated for each scan, and runs the following parts: 1) Create folders 2) Subject/session definitions 3) Add prefixes & suffixes 4) Add Subject-specific prefixes 5) Add sidecars xASL_init_InitializeMutex.m Format [x] = xASL_init_InitializeMutex(x, ModuleName) Description This function initializes the mutex/lock system of ExploreASL for a module. Mutex (for mutual exclusion) is a synchronization mechanism for enforcing limits of access to data (here a module for a single scan) to allow parallelization. It also allows stopping and continuing of ExploreASL. This function runs the following steps: 1) Lock folder management 2) Initialize mutex object xASL_init_LoadMetadata.m Format [x] = xASL_init_LoadMetadata(x) Description This function loads all metadata used in the study, either statistical covariates (age, MMSE) or groups to compare between (site, sequence, cohort), or parameters to be used in quantification/image processing These parameters should be provided in .mat files in the root analysis folder. Each .mat file should contain a single type of metadata, and the filename should equal the variable name. Metadata content should be a cell array with subjects as first column and metadata as last column. Sessions (runs) can be included as second column. Metadata can be in any string or numerical format. participants.tsv is now added per BIDS. It looks for metadata in participants.tsv first, before going through the mat-files This function iterates through the following steps for each variable: 1) Admin (what nOptions do we call ordinal, convert subject numeric to string, remove white spaces from data) 2) Get unique list of data options & check for missing data 3) Deal with data format (correct NaNs, deal with numeric vs strings) 4) Distinguish continous data (e.g. age) or ordinal data (groups to compare, e.g. cohort) 5) Check if data is complete for all subjects 6) Include complete data in x.S.SETS xASL_init_LongitudinalRegistration.m Format [SubjectNlist, TimePoint, IsSubject, SubjectID_FirstVolume] = xASL_init_LongitudinalRegistration(x) Description This function initializes the longitudinal registration for ExploreASL, which implements the SPM longitudinal registration. This function recognizes and defines visits (i.e. multiple scans per subject) in the initialization of ExploreASL, based on the suffixes _1 _2 _n in the subject names (identified as foldernames). Specifically, this function is called in the registration modules LongReg and DARTEL, the first carrying out within-subject registration and the second between-subject registration, based on the first time point only. For the first function, we specify here a list of visits/timepoints that should be registered longitudinally, for the second function we specify a list of first visits only, as the between-subject registration in ExploreASL is based on the first scan (as opposed to the average subject's scan). This function runs the following steps: 1) Get TimePoint-list (list of visits) 2) Find subject IDs xASL_init_VisualizationSettings.m Format [x] = xASL_init_VisualizationSettings(x) Description This function defines several visualization settings are used throughout ExploreASL's pipeline and tools, assuming a [121 145 121] matrix with 1.5 mm isotropic resolution in MNI space. Input and Output xASL_io_CreateNifti.m Format xASL_io_CreateNifti(pathNewNifti, imNew, resMat, nBits, bGZip) Description This function creates a new NIfTI file, using the SPM \"nifti\" functionality, with the parameters specified as input arguments. This function performs the following steps: 1) Initialize NIfTI 2) Choose datatype (bit resolution) 3) Create scale slopes 4) Create orientation matrix 5) Write the new NIfTI, image matrix & scale slopes 6) Zip and deal with zipping (.nii vs. .nii.gz) xASL_io_DcmtkRead.m Format header = xASL_io_DcmtkRead(filepath, bPixel) Description SHORT Reads DICOM headers using DCMTK FORMAT: header = xASL_io_DcmtkRead(filepath, bPixel) INPUT: filepath (string) - full path to the DICOM file bPixel (bool) - read pixel data, default 0 OUTPUT: header (structure) - structure containing parsed DICOM header Calls the MEX function that uses DCMTK library to read the DICOM header. To change which parameters are read and their names - the MEX file needs to be edited. This function also corrects formating of certain parameters. xASL_io_MakeNifti4DICOM.m Format xASL_io_MakeNifti4DICOM(PathIn, x) Description This function converts a NIfTI file to one that is ready to convert to DICOM for PACS visualization purposes: For scaling/visualization: 1) Remove peak signal 2) Remove valley signal 3) Remove NaNs 4) Rescale to 12 bit integers 5) Save NIfTI. We also zip the NIfTI as this NIfTI won't be opened by ExploreASL 6) Manage scale slope/datatype 7) Apply original orientation 8) Zip NIfTI xASL_io_PairwiseSubtraction.m Format xASL_io_PairwiseSubtraction(InputFile,outputPath,do_mask,switch_sign) Description Subtracts controls from labels and takes mean. Creates new perfusion-weighted delta_M file, prefaced with 's'. Converts into single precision floating point values (32 bit), removes scale slope. Only runs if ['s' input_file_ASL] doesn't exist. Remember to consider motion correction/ SPM realign (isotropically). Alternative to this function is robust fit (Camille Maumet). xASL_io_ReadTheDicom.m Format [Info] = xASL_io_ReadTheDicom(bUseDCMTK, DicomPath) Description This function tries to read a DICOM and throws a warning if it fails to xASL_io_SplitASL_M0.m Format xASL_io_SplitASL_M0(InPath,iM0) Description This function splits ASL4D & M0 if they were in the same sequence. If dcm2niiX has already splitted the ASL4D NIfTI, this is reconstructed first. If no M0 exists, or only ASL splitting is desired, leave iM0 empty ([]) Vendor product sequence examples: GE 3D spiral sometimes puts the M0 at the last volume of the series -> iM0 = [2]; Philips 3D GRASE puts the M0 as control-label volume pair -> iM0 = [1 2]; Siemens 3D GRASE puts the M0 as the first volume -> iM0 = 1; xASL_io_dcm2nii.m Format [niifiles, ScanNameOut, usedinput, msg] = xASL_io_dcm2nii(inpath, destdir, series_name, varargin) Description Convert DICOM NIfTI/BIDS format using the dcm2nii command line utility. xASL_num2str.m Format [DataOut] = xASL_num2str(DataIn[, f]) Description when the provided data is numeric, this function will convert the number to string/characters, rewriting NaN into 'n/a' (BIDS convention) but otherwise preserving the Matlab builtin functionality, also for the second argument \"f\". If non-numeric data is provided, it is bypassed (avoiding any issues \"num2str\" will have with non-numeric data). See builtin num2str for more details QC xASL_qc_AsymmetryIndex.m Format [AI_perc] = xASL_qc_AsymmetryIndex(ImageIn) Description Extract voxel-wise asymmetry index for QC purposes. xASL_qc_CAT12_IQR.m Format [QA_Output] = xASL_qc_CAT12_IQR(InputImage, InputC1, InputC2, InputC3, bFLAIR) Description ... xASL_qc_CollectParameters.m Format x = xASL_qc_CollectParameters(x, iSubject, ScanType, CollectQCFunction) Description This function collects QC parameters for a module xASL_qc_CollectQC_ASL.m Format [x] = xASL_qc_CollectQC_ASL(x, iSubject) Description This functions collects QC parameters for the ASL module These are stored in x.Output.ASL: ID - SubjectName ASL_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 SPM realign (too much motion is suspicious) MotionMean_mm - mean motion MotionExcl_Perc - percentage of excluded outliers MotionMax_mm - max motion MotionSD_mm - SD motion ASL quantification (strange average CBF, or strange GM-WM contrast) ASL acquisition parameters (should be fairly consistent over subjects/scans): TE - echo time TR - repetition time RescaleSlope - Philips Scaleslope - Philips Matrix X Y Z - matrix size Matrix Z - number of slices VoxelSize X Y - in plane resolution VoxelSize Z - slice thickness RigidBody2Anat_mm - Net Displacement Vector (RMS) from ASL to T1w image (mm) from registration xASL_qc_CollectQC_Structural.m Format [x] = xASL_qc_CollectQC_Structural(x, iSubject) Description This functions collects QC parameters for the structural module These are stored in x.Output.Structural: ID - SubjectName T1w_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 LST output: WMH_vol_mL - WMH volume WMH_n - WMH number of lesions CAT12 output: T1w_IQR_Perc - CAT12 IQR quality parameter for T1w volumetric: GM_vol_mL, WM_vol_mL, CSF_vol_mL, ICV_vol_mL, GM_ICV_Ratio xASL_qc_CollectQC_func.m Format [x] = xASL_qc_CollectQC_func(x, iSubject) Description This functions collects QC parameters for the func module These are stored in x.Output.func: ID - SubjectName func_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 SPM realign (too much motion is suspicious) MotionMean_mm - mean motion MotionExcl_Perc - percentage of excluded outliers MotionMax_mm - max motion MotionSD_mm - SD motion func quantification (strange average CBF, or strange GM-WM contrast) CBF_GM_Median_mL100gmin - median GM CBF CBF_WM_Median_mL100gmin - median WM CBF SpatialCoV_GM_Perc - GM spatial CoV SpatialCoV_WM_Perc - WM spatial CoV CBF_GM_WM_Ratio - GM-WM CBF ratio func acquisition parameters (should be fairly consistent over subjects/scans): TE - echo time TR - repetition time RescaleSlope - Philips Scaleslope - Philips Matrix X Y Z - matrix size Matrix Z - number of slices VoxelSize X Y - in plane resolution VoxelSize Z - slice thickness RigidBody2Anat_mm - Net Displacement Vector (RMS) from func to T1w image (mm) from registration xASL_qc_CollectSoftwareVersions.m Format [x] = xASL_qc_CollectSoftwareVersions(x) Description This functions collects software versions for matlab, SPM, CAT, LST & ExploreASL These are stored in x.Output.Software xASL_qc_CompareTemplate.m Format [QC] = xASL_qc_CompareTemplate(x, ModPrefix, iSubjectSession) Description This function computes several advanced template-based QC parameters: RMSE_Perc - Root Mean Square Error between image and template (%) nRMSE_Perc - Same but then normalized AI_Perc - Asymmetry Index between image and template (%) Mean_SSIM_Perc - mean structural similarity index -> xASL_stat_MeanSSIM.m PeakSNR_Ratio - peak signal-to-noise ratio -> xASL_stat_PSNR.m xASL_qc_ComputeFoVCoverage.m Format [CoveragePerc] = xASL_qc_ComputeFoVCoverage(InputPath, x) Description This function computes the intersection/overlap between brainmask on field-of-view (FoV) of low resolution image (native space) & the same brainmask with expanded FoV. It uses the pGM+pWM+pCSF as brainmask This assumes that the structural reference image has full brain coverage, and was properly segmented into GM, WM and CSF Also, we assume that the InputPath contains a single 3D volume xASL_qc_ComputeNiftiOrientation.m Format [Struct] = xASL_qc_ComputeNiftiOrientation(x, PathNIfTI, Struct) Description ... xASL_qc_CreatePDF.m Format xASL_qc_CreatePDF(x[, DoSubject]) Description This function iterates over all values in x.Output and all images in x.Output_im, and prints them in a PDF file. x.Output & x.Output_im should contain the QC/result output of all ExploreASL pipeline steps. Further code explanation: Below, using the Matlab & SPM Figure tools we create an image, which is then printed to a PDF file fg = the main Figure handle ax = \"axes\" handles, these are objects containing either 1) text or 2) images, with fg as \"parent\" (1) & (2) images have ax as \"parent\" Positions are calculated in such a way that 4 categories can be printed, which will be the first 4 fields found in x.Output then allowing 8 single slice images, and 15 text lines (name & value columns) xASL_qc_FA_Outliers.m Format [FA_Outliers_mL] = xASL_qc_FA_Outliers(InputFA) Description Extract the number of FA outliers, i.e. values of FA above 1 or below 0, from a FA image. xASL_qc_ObtainQCCategoriesFromJPG.m Format xASL_qc_ObtainQCCategoriesFromJPG(x) Description This function obtains QC categories as covariant/set, based on the JPGs in //Population/ASLCheck. These are initially sorted by spatial CoV, and should be visually checked & put in the correct folder. xASL_qc_PCPStructural.m Format [anatQA] = xASL_qc_PCPStructural(PathT1, Pathc1T1, Pathc2T1, x, PopPathT1) Description This function computes several anatomical QC parameters as proposed in SPM Univariate Plus: WM_ref_vol_mL - volume of the WM reference region (mL) WMref_vol_Perc - same but as percentage of total WM volume SNR_GM - GM signal-to-Noise Ratio (SNR), ie the mean intensity within GM divided by SD of WM reference region. Higher = better. CNR_GM_WM - GM-WM Contrast-to-Noise Ratio (CNR), i.e. the mean of GM - mean of WM divided by the SD of the WM reference region. Higher = better. FBER_WMref_Ratio - Foreground to Background Energy Ratio (FBER), i.e. the variance of voxels within the brain (in pGM+pWM mask) divided by the variance of voxels in the WM reference region. Higher = better. EFC_bits - Shannon Entropy Focus Criterion (EFC), i.e. the entropy of voxel intensities proportional to the maximum possibly entropy for a similarly sized image. Indicates ghosting and head motion-induced blurring. Lower = better. Mean_AI_Perc - mean relative voxel-wise absolute Asymmetry Index (AI) within the brain (pGM+pWM mask) (%) SD - same but SD (%) REFERENCES: Preprocessed Connectome Project Quality Assurance Protocol (QAP): http://preprocessed-connectomes-project.org/quality-assessment-protocol/ http://ieeexplore.ieee.org/document/650886/ xASL_qc_PrintOrientation.m Format xASL_qc_PrintOrientation(DIR, reg_exp_INPUT,OUTPUT_DIR,Name); Description Check orientation of niftis, useful to detect accidental left-right flips (all other flips will be visible). translations, rotations or shears are not to be worried about, only negative zooms. This can be detected by negative determinants. So orientation parameters and determinants should be similar across all scans from single scanner/coil, and registration should not give negative determinant. xASL_qc_TanimotoCoeff.m Format TC = xASL_qc_TanimotoCoeff(Image1, Image2[, imMask, type]) Description Compares images Image1 and Image2 within the mask imMask. TYPE specifies the input data type. RATIONALE: Note that the Tanimoto Coefficient is a measure of image overlap/intersection, similar to the Dice coefficient. With the option type 3, this is a fuzzy coefficient, which doesn't require to convert the two images to a binary mask. The TC can be interpreted as a stringent Kappa, ranging from 0 (completely dissimilar) to 100% (identical images). Assuming that perfect registration should not lead to identical images but still retain physiological differences, TC>70% can be regarded as excellent image agreement. The TC will be overestimated when smoothing, but this may lead to more stable artifact detection. xASL_qc_WADQCDC.m Format xASL_qc_WADQCDC(x, iSubject[, ScanType]) Description This QC function runs WAD-QC specific Python script to zip QC information & incorporate this into a DICOM field for analysis on the WAD-QC server, by the following: Define QCDC script: this is the Python script written by Gaspare, edited by Joost Kuijer & copied to the EPAD CustomScripts folder of ExploreASL Python installation location is checked, with several known locations, for several servers. If we cannot find it, the QCDC is not ran Previous QCDC results are cleaned. QCDC stores all its results in a separate folder (Something like 2 layers up from the current folder, here referred to as QCDCDir = [x.D.ROOT 'qcdc_output']) from these result files, only the filled DICOM file is interesting, all the rest are copies of the QC results that we embedded into the DICOM Run QCDC (if Python installation detected) The following files need to be set as executable: ('QCDC', 'src', 'qc_data_collector.py') ('QCDC', 'src', 'bash', 'create_dcm_only_wadqc.sh') ('QCDC', 'src', 'bash', 'sendwadqc.sh') Clean up new QCDC results (as above) & move the filled DICOM to ['qcdc_' DummyFile] within the current ScanType folder Sending the DICOM to the WAD-QC server using storescu xASL_qc_WADQC_GenerateDescriptor.m Format xASL_qc_WADQC_GenerateDescriptor(x, iSubject) Description This QC function generates a JSON descriptor for Gaspare' QCDC script, by the following steps: a) include information about where to find the dummy DICOM (i.e. placeholder DICOM) b) For ExploreASL' QC fields (as passed through in x.Output), here we note all these QC fields for each ScanType, as the x.Output should have been collected equally in the QC file 'QC_collection_SubjectName.json' by function xASL_qc_CollectParameters c) Subfunction xASL_qc_WADQC_images - Includes visual standard space QC images, by searching them on prescribed paths within the Population folder (where currently all derivatives reside) d) Insert the PDF report; this PDF report is subject-specific, not scan-specific. For completeness it is added to each QCDC descriptor e) Add WAD-QC server details (i.e. IP address etc) f) Save the Descriptor JSON file. xASL_qc_temporalSNR.m Format tSNR = xASL_qc_temporalSNR(pathIm4D,pathImTissueProb) Description This function computes several temporal SNR QC parameters as proposed in SPM Univariate Plus: tSNR.tSNR_GM_Ratio : mean GM signal / std GM over time tSNR.tSNR.tSNR_WM_Ratio : mean WM signal / std WM over time tSNR.tSNR.tSNR_CSF_Ratio: mean CSF signal / std CSF over time tSNR.tSNR_WMref_Ratio : mean signal/std over time in eroded deep WM tSNR.tSNR_GMWM_Ratio : mean (GM+WM) signal / sqrt(std(GM+WM)^2+std(WMref)^2) tSNR.tSNR_GMWM_WMref_Ratio: mean (GM+WM) signal / std WMref over time tSNR.tSNR_Physio2Thermal_Ratio: sqrt((tSNR(GM+WM)/tSNR_GMWM_WMref_Ratio))^2-1) tSNR.tSNR_Slope_Corr: Differences to the SPM U+ suggestion: - eroded WM is used for estimating background noise - Brainmask is determined in the same way as the structural anatQC, - CSF is determined from the pGM&pWM maps; REFERENCES: 1) Thomas Liu (2016). Noise contributions to the fMRI signal: An overview NeuroImage, 343, 141-151 http://dx.doi.org/10.1016/j.neuroimage.2016.09.008 2) Cesar Caballero-Gaudes and Richard C. Reynolds (2016). Methods For Cleaning The BOLD fMRI Signal. NeuroImage, 154,128-149 3) Lawrence Wald and Jonathan R Polimeni (2016). Impacting the effect of fMRI noise through hardware and acquisition choices ??? Implications for controlling false positive rates. NeuroImage, 154,15-22 4) SPM Utility + toolbox. Cyril Pernet. https://osf.io/wn3h8/ Quantization xASL_quant_AgeSex2Hct.m Format [Hematocrit] = xASL_quant_AgeSex2Hct([age, sex]) Description This function estimates a participants hematocrit, based on literature-based values for age and sex. It performs the following steps: Warning unknown age/sex Imputing unknown age/sex Define hematocrit per age for unknown sex Define Hematocrit per age for males Define Hematocrit per age for females xASL_quant_FEAST.m Format xASL_quant_FEAST(x) Description This function quantifies ATT using the FEAST equations, using crushed and non-crushed sessions, of which the ratio is proportional to ATT. Note that the order of sessions should be 1) crushed 2) non-crushed This function runs the following steps: 1. Skip this function if no FEAST data available 2. Admin 3. Load data & correct for timing differences (PLD etc) 4. Smooth and clip CBF maps & FEAST ratio 5. Compute TT maps xASL_quant_GetControlLabelOrder.m Format [ControlIM, LabelIM, OrderContLabl] = xASL_quant_GetControlLabelOrder(FramesIn, x) Description This function automatically checks (and corrects if required) the control and label order of ASL timeseries based on the larger signal in control volumes. It supposes that data is acquired in pairs. xASL_quant_Hct2BloodT1.m Format BloodT1 = xASL_quant_Hct2BloodT1(Hematocrit, Y, B0, bVerbose) Description This function converts hematocrit to blood T1, according to calculations defined by Patrick Hales. With courtesy and thanks! Note that we assume a venous O2 saturation of 68% (Yv=0.68) This function performs the following steps: 1) Check fraction vs percentage hematocrit & Y, should be between 0 and 1 2) Specify defaults (Hb, Fe) 3) Perform calculation 4) Convert s to ms 5) Print what we did xASL_quant_M0.m Format [M0IM] = xASL_quant_M0(M0IM, x) Description This function quantifies the M0, except for the difference in voxel size between the M0 and ASL source data (which is scaled in xASL_wrp_ProcessM0.m). This function runs the following steps: Correct scale slopes, if Philips Skip M0 quantification if ~x.ApplyQuantification(4) Set TR specifically for GE Check for correct TR values Quantify the M0, either for single 3D volume or slice-wise Apply custom scalefactor if requested (x.M0_GMScaleFactor) xASL_quant_SinglePLD.m Format [ScaleImage[, CBF]] = xASL_quant_SinglePLD(PWI, M0_im, SliceGradient, x) Description This script performs a multi-step quantification, by initializing a ScaleImage that travels through this script & gets changed by the following quantification factors: 1) PLD scalefactor (gradient if 2D multi-slice) (if x.ApplyQuantification(3)) 2) Label decay scale factor for single (blood T1) - or dual-compartment (blood+tissue T1) model, CASL or PASL Single-compartment model: Alsop MRM 2014 Dual-compartment model: Wang MRM 2002: Gevers JMRI 2012 (if x.ApplyQuantification(3)) 3) Scaling to physiological units [ml/gr/ms =>ml/100gr/min =>(60,000 ms=>min)(1 gr=>100gr)] (if x.ApplyQuantification(3)) 4) Vendor-specific scalefactor (if x.ApplyQuantification(1) -> future move to dcm2niiX stage) Finally, we: 5) Divide PWI/M0 (if x.ApplyQuantification(5)) 6) Print parameters used Note that the output always goes to the CBF image (in the future this could go to different stages, e.g. dcm2niiX or PWI stage) SPM xASL_spm_BiasfieldCorrection.m Format xASL_spm_BiasfieldCorrection(PathIn, SPMdir, Quality, MaskName, PathOut) Description This function is a wrapper around the SPM \"old segment\" function, for biasfield removal. It is tested for M0 and mean control images. It conducts the following steps: 1) Create implicit mask 2) Define SPM 'old segmentation' settings 3) Run SPM 'old segmentation' 4) Delete temporary files 5) Rename temporary SPM file into output file xASL_spm_affine.m Format xASL_spm_affine(srcPath, refPath, fwhmSrc, fwhmRef[,otherList, bDCT]) Description This SPM wrapper runs SPM's old normalize-estimate function, which calculates the affine transformation (i.e. linear + zooming and shearing) that is required to align the source image with the reference image. By default it does not estimate the low-degree Discrete Cosine Transform (DCT) to have a simple affine transformation but this can be enabled in this wrapper. Also note that this affine transformation uses a correlation cost function, hence it requires the source and reference images to have similar contrasts and resolution - or provide the resolution estimates so the smoothing can be done. This function does not change the orientation header by default, but it allows to change those of others through the otherList. If bDCT is used or no otherList given, it stores its estimated affine transformation as orientation difference matrix in a file with the same path but _sn.mat extension. For the provided smoothing FWHM, note that smoothnesses combine with Pythagoras' rule (i.e. square summing). xASL_spm_coreg.m Format xASL_spm_coreg(refPath, srcPath[, OtherList, x, sep, FastReg]) Description This SPM wrapper runs SPMs coregister-estimate function, which calculates the 6 parameter rigid-body transformation (a.k.a. linear) that is required to align the source image with the reference image. This 6 parameter transformation (i.e. 3 XYZ translations and 3 rotations) is applied to the orientation header of the source NIfTI image, and also to the images provided in OtherList (optional). Note that this SPM registration function uses a normalized mutual information (NMI) by default, enabling registration between two images with different contrast. Note that this algorithm will use the first volume of a multi-volume NIfTI xASL_spm_deface.m Format xASL_spm_deface(PathIn, bReplace) Description This function removes the face from an anatomical NIfTI image, e.g. T1w or FLAIR, for disidentification/privacy purposes. When this script is run after the ExploreASL structural module, it does a pretty good job even for 2D images. However, note that this can always fail, strip part of the brain, or change the output of pipelines. So best not to compare results from defaced and non-defaced images. Also, note that defacing makes it difficult to ensure that the FLAIR and T1w are from the same subject. xASL_spm_deformations.m Format xASL_spm_deformations([x,] PathIn, PathOut[, Interpolation, InverseSpace, AffineTrans, DeformationPath]) Description This ExploreASL wrapper manages the SPM deformation tool. It takes multiple (ExploreASL pipeline) transformations and combines/concatenates them into a single transformation prior to applying it to the input images. This allows to apply multiple transformations with a single interpolation, avoiding propagation of undesired interpolation effects. Mainly used to get native space images into standard space, or vice versa. Best to combine as many files as possible within this function, since the deformation calculation (which is the most computation intensive part) needs to be performed once for multi-file resampling Statistics xASL_stat_AtlasForStats.m Format [x] = xASL_stat_AtlasForStats(x) Description This function loads atlases, checks them, and their ROI names, for later use as ROI definition in xASL_stat_GetROIstatistics Note that the atlases should be integer values, or different 4rd dimensions (i.e. multiple images), that are mutually exclusive. This function takes the following steps: 1) Load atlas ROI names There should be a TSV sidecar to the atlas NIfTI file, as explained above. 2) deal with memory mapping 3) Resample atlas 50 1.5 mm^3 MNI 4) Converted atlas with integers to 4D binary image 5) Convert/compress masks into Columns 6) Print atlas overview image xASL_stat_ComputeDifferCoV.m Format diffCoV = xASL_stat_ComputeDifferCoV(imCBF) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask,bPVC,imGM,imWM) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask,bPVC,imGM,imWM,b3D) Description It calculates the spatial DiffCoV value on finite part of imCBF. Optionally a mask IMMASK is provide, and PVC is done for bPVC==2 using imGM and imWM masks and constructing pseudoCoV from pseudoCBF image. For bPVC~=2, imGM and imWM are ignored. It is calculated in 2D or assuming also 3D edges based on B3D. Calculate derivate spatial CoV, by summing up differences in CBF between neighbors. The derivative uses Sobels filter. xASL_stat_ComputeMean.m Format [CBF_GM CBF_WM] = xASL_stat_ComputeMean(imCBF [,imMask,nMinSize,bPVC,imGM,imWM]) Description It behaves in a similar way as VAR. xASL_stat_ComputeSpatialCoV.m Format sCov = xASL_stat_ComputeSpatialCoV(imCBF) sCov = xASL_stat_ComputeSpatialCoV(imCBF,imMask) sCov = xASL_stat_ComputeSpatialCoV(imCBF,imMask,nMinSize) sCov = xASL_stat_ComputeSpatialCoV(imCBF,imMask,nMinSize,bPVC,imGM,imWM) Description It calculates the spatial CoV value on finite part of imCBF. Optionally a mask IMMASK is provide, ROIs of size < NMINSIZE are ignored, and PVC is done for bPVC==2 using imGM and imWM masks and constructing pseudoCoV from pseudoCBF image. For bPVC~=2, imGM and imWM are ignored xASL_stat_EqualVariancesTest.m Format [resTest, P] = xASL_stat_EqualVariancesTest(X[, alpha, type]) Description Brown-Forsythe or Levene's test for equality of variances. The response variable is transformed (yij = abs(xij - median(xj)) for Brown-Forsythe and yij = abs(xij - mean(xj)) for Levene's test). And then runs a one-way ANOVA F-test to check if the variances are equal. xASL_stat_GetROIstatistics.m Format [x] = xASL_stat_GetROIstatistics(x) Description This function computes mean and spatial CoV for each ROI, in a [1.5 1.5 1.5] mm MNI space, with several ASL-specific adaptions: Skip ROI masks that are smaller than 1 mL as this would be too noisy for ASL (skipped when x.S.IsASL==false) Expand each ROI mask such that it has sufficient WM content (skipped when IsASL==false) Create for each ROI mask a left, right and bilateral copy Iterate over all subjects: a) Load partial volume maps b) Correct for WMH SEGM -> IS THIS STILL REQUIRED??? c) Load data d) Show ROIs projected on ASL image e) Actual data computations Partial Volume Correction (PVC) options: PVC==0 -> perform masking only, no regression PVC==1 -> single compartment regression, for pGM PVC==2 -> dual compartment regression for pGM & pWM (i.e. normal PVC) Here we mask out susceptibility artifacts (including outside FoV) for all ASL computations, and also mask out vascular artifacts for computing the mean. While other artifacts/FoV can be masked out on population level (i.e. >0.95 subjects need to have a valid signal in a certain voxel), vascular artifacts differ too much in their location between subjects, so we mask this on subject-level. Note that the words \"mask\" and \"ROI\" are used interchangeably throughout this function, where they can have a different or the same meaning PM: WE COULD CHANGE THIS, INTO MASK BEING USED TO EXCLUDE VOXELS AND ROI FOR INCLUDING VOXELS xASL_stat_MadNan.m Format y = xASL_stat_MadNan(x[,flag, dim]) Description Calculates a Median/Mean Absolute deviation, but ignoring NaNs in the calculation. xASL_stat_MadNan(X) or xASL_stat_MadNan(X,0) computes xASL_stat_MeanNan(ABS(X-xASL_stat_MeanNan(X)) xASL_stat_MadNan(X,1) computes xASL_stat_MedianNan(ABS(X-xASL_st_MedianNan(X)). xASL_stat_MeanSSIM.m Format mssim=xASL_stat_MeanSSIM(imRef,imSrc[,dynRange]) Description Calculates the similarity index according to Want et al. xASL_stat_MultipleLinReg.m Format [b,CI,pval,stats] = xASL_stat_MultipleLinReg(X,Y[,bIntercept]) Description Performs a multiple linear regression Y=b*X+a and provides the intercept and regression coefficients beta including their significance and confidence intervals. It calculates additionally the goodness of the fit. xASL_stat_PSNR.m Format PSNR=xASL_stat_PSNR(imRef,imSrc) Description Calculates the PSNR, needs two input arguments - 3D images of the same size. Uses 95% percentile instead of MAX. xASL_stat_PrintStats.m Format [x] = xASL_stat_PrintStats(x) Description This function prints an overview of statistics from data that were acquired per ROI, in a TSV file. It starts by printing covariates (called \"Sets\"). Rows will be subjects/sessions, columns will be the sets and ROI-statistics: 1) First remove previous TSV-file, if already existed printing to a TSV file can be tricky if it is opened by Excel. Make sure to close previous versions first, otherwise this part will crash. 2) Print overview of sets to TSV as explained above. Uses subfunction xASL_stat_CreateLegend to put legends. Aim is to create a single TSV file that has a proper overview of the data, & is self-explanatory to those reading/using it. 3) Define number of ASL sessions, force to 1 in case of TT or volume metrics 4) Print the overview xASL_stat_QuantileNan.m Format y = xASL_stat_QuantileNan(x[,quant, dim]) Description Calculates a quantile, but ignoring NaNs in the calculation xASL_stat_RobustMean.m Format [NoOutliers, iOutliers, ThresholdDeviation] = xASL_stat_RobustMean(IM, ParameterFunction) Description This function detects outlier images, that can be used to create a robust average, e.g. for template or biasfield creation. This is based either on the sum-of-squares with the mean image (SoS), or on the average relative asymmetry index (AI). Images that are median+/-3 mad off are defined as outliers. MAD = median/mean absolute difference xASL_stat_ShapiroWilk.m Format [H, P, W] = xASL_stat_ShapiroWilk(x[, alpha]) Description Performs the statistical test of normality - null hypothesis is that the sample is from normal distribution with unspecified mean and variance. Based on the sample kurtosis it performs either Shapiro-Wilk (for platykurtic) or Shapiro-Francia test (for leptokurtic). xASL_stat_StdNan.m Format y = xASL_stat_StdNan(x[,w,dim]) Description It behaves in a similar way as VAR - it directly passes all arguments to xASL_stat_VarNan. xASL_stat_SumNan.m Format y = xASL_stat_SumNan(x[,dim]) Description It uses the function SUM, but it sets all the NaNs to zero before calling it. xASL_stat_VarNan.m Format y = xASL_stat_VarNan(x[,w,dim]) Description It behaves in a similar way as VAR. xASL_stat_fcdf.m Format F = xASL_stat_fcdf(F,M,N) Description Calculates the cumulative distribution function of the F-distribution for degrees of freedom M,N at value F. xASL_stat_tcdf.m Format F = xASL_stat_tcdf(T,nu) Description Calculates the cumulative distribution function of the Student's t-distribution for degrees of freedom nu at value T. xASL_stat_ticdf.m Format T = xASL_stat_ticdf(P,nu) Description Calculates the inverse of cumulative distribution function of the Student's t-distribution for degrees of freedom nu at value P. xASL_stat_ttest.m Format [H,P,CI,stats] = xASL_stat_ttest(X[,M,alpha,tail,dim]) Description Performs a t-test that the distribution of the input data X has a mean different from 0 (or from a given mean M, or that the distributions X and Y have different means). A normal distribution of the data with an unknown variance is assumed. xASL_stat_ttest2.m Format [H,P,CI,stats] = xASL_stat_ttest2(X,Y[,alpha,tail,vartype,dim]) Description Performs a unpaired t-test that the distribution of the input data X has a mean different from that of Y. A normal distribution of the data with an unknown variance is assumed. xASL_str2num.m Format [DataOut] = xASL_str2num(DataIn) Description str2num wrapper, replacing 'n/a' with NaN (BIDS convention) and converting only strings to numbers. Also allows inputting cells. Visualization xASL_vis_AddIM2QC.m Format [x] = xASL_vis_AddIM2QC(x,parms); Description Checks which images already are loaded, and adds new image. xASL_vis_CreateVisualFig.m Format [ImOut, FileName] = xASL_vis_CreateVisualFig(x, ImIn, DirOut, IntScale, NamePrefix, ColorMap, bClip) Description This function creates a visualization Figure by merging flexibly rearranging NIfTI slices, input matrix or path, managing colormaps for different merged image layers. Current use is for visual QC figures and overview in papers. Function is structured as: Admin, deal with input arguments Process image layers separately * xASL_im_TransformData2View: Reshapes image data into visualization figure * xASL_im_ClipExtremes: Clips image to given percentile also we scale for peak intensity, we make sure that there is no visible clipping/distortion * Convert to colors, using any input colormaps combine image layers, using input argument IntScale print figure This function assumes that the first image is a grayscale background image (e.g. for transparancy reasons), if there are multiple images xASL_vis_CropParmsAcquire.m Format [xmin xmax ymin ymax] = xASL_vis_CropParmsAcquire(temp_image) Description Goes from outside to inside to acquire crop settings. Works with grayscale images (2 dimensions per slice). Image position information (2D matrix) should be first 2 dimensions. Could include colordimension later on. xASL_vis_CropParmsApply.m Format ImageOut = xASL_vis_CropParmsApply(ImageIn,CropParameters) Description This function crops 2D image matrices. xASL_vis_Imwrite.m Format [ImOut] = xASL_vis_Imwrite(ImIn, PathOut[, ColorMap, bRescale]) Description This functions takes an input image matrix, interpolates it to HD resolution (1920x1080) for visibility, and saves the image as jpg. This function avoids the graphic interface of Matlab, for running from CLI Careful: this function overwrites any existing PathOut. xASL_vis_OverlapT1_ASL.m Format xASL_vis_OverlapT1_ASL( x, ASL) Description Part of ExploreASL. Shows spatial agreement ASL and probability maps. xASL_vis_TileImages.m Format ... Description Merges selected slices (3D) into one single 2D picture. Plots all slices in one figure with specified rows and columns, aiming for a square tile. PM: can be extended to multiple slices xASL_vis_TransformData2View.m Format FigureOut = xASL_vis_TransformData2View(ImagesIn, x) Description This function changes the dimensionality and reshapes the input images in such a way that they are nicely tiled in a mosaic for visualization purposes. Reshaping a series of images with this function can be useful for visualization of SPM/voxel-based analyses. xASL_vis_VisualQC_TopUp.m Format [MeanAI_PreTopUp_Perc, MeanAI_PostTopUp_Perc] = xASL_vis_VisualQC_TopUp(PathPopB0, PathPopUnwarped, x, iSubject, CheckDir) Description This function creates a Figure that showes the effect of TopUp with 6 images with axial slices: the NormPE, RevPE and their difference image in colorscale, and this before (upper row) & after (lower row) TopUp. xASL_vis_VisualizeROIs.m Format xASL_vis_VisualizeROIs(x, ROI_T1_list, ROI_FLAIR_list) Description Creates for each subject a JPEG image containing the original T1w, WMH_SEGM and T1w after lesion-filling.","title":"Functions"},{"location":"Functions/#functions","text":"","title":"Functions"},{"location":"Functions/#general-functions","text":"","title":"General Functions"},{"location":"Functions/#xasl_iterationm","text":"","title":"xASL_Iteration.m"},{"location":"Functions/#format","text":"[bAborted, xOut] = xASL_Iteration(x, moduleName[, dryRun, stopAfterErrors])","title":"Format"},{"location":"Functions/#description","text":"Parses the settings and runs the DatabaseLoop sub-function.","title":"Description"},{"location":"Functions/#administration","text":"","title":"Administration"},{"location":"Functions/#xasl_adm_catchnumbersfromstringm","text":"","title":"xASL_adm_CatchNumbersFromString.m"},{"location":"Functions/#format_1","text":"[OutputNumber] = xASL_adm_CatchNumbersFromString(InputString)","title":"Format"},{"location":"Functions/#description_1","text":"...","title":"Description"},{"location":"Functions/#xasl_adm_checkfilecountm","text":"","title":"xASL_adm_CheckFileCount.m"},{"location":"Functions/#format_2","text":"[result, files] = xASL_adm_CheckFileCount(path, expr[, mincount, failifmissing]) [result] = xASL_adm_CheckFileCount(...)","title":"Format"},{"location":"Functions/#description_2","text":"Checks the given PATH for files corresponding to the SPM_SELECT regular expression EXPR . Returns if the number of files is equal to or higher than MINCOUNT . If FAILIFMISSING is true and not enough files, then throw and error. If everything goes ok and second output argument is specified then return also the list of files.","title":"Description"},{"location":"Functions/#xasl_adm_checkpermissionsm","text":"","title":"xASL_adm_CheckPermissions.m"},{"location":"Functions/#format_3","text":"[FilesList, FilesExeList, FoldersList] = xASL_adm_CheckPermissions(InputPath[, FilesExecutable])","title":"Format"},{"location":"Functions/#description_3","text":"This function does a recursive search through the root folder & makes a list of the attributes of all files and folders. It tries to reset the attributes to what we desire, which is by default: 664 for files (meaning only reading & writing for users & group, & read-only for others) 775 for folders (meaning reading, writing & opening for current user & current group, & for others only reading & opening) For executable files we also want 775. Note that the permission to 'execute a folder' means opening them. DataOK checks data permissions. ExeOK checks executable permissions. DataOK also includes executable permissions for folders. This runs recursively (but currently skips the contents of the root-folder) .","title":"Description"},{"location":"Functions/#xasl_adm_checkspmm","text":"","title":"xASL_adm_CheckSPM.m"},{"location":"Functions/#format_4","text":"[spm_path, spm_version] = xASL_adm_CheckSPM([modality, proposed_spm_path, check_mode]) [spm_path] = xASL_adm_CheckSPM(...) xASL_adm_CheckSPM(...)","title":"Format"},{"location":"Functions/#description_4","text":"Checks if the spm function exists and if the reported version matches our development version ( SPM8 or SPM12 ). If the spm toolbox is not available yet, it will try the PROPOSED_SPM_PATH (if specified) or the user selected directory and add it to PATH . The function will fail if SPM cannot be found or if detecting an unsupported version.","title":"Description"},{"location":"Functions/#xasl_adm_cleanupbeforererunm","text":"","title":"xASL_adm_CleanUpBeforeRerun.m"},{"location":"Functions/#format_5","text":"xASL_adm_CleanupBeforeCompleteRerun(AnalysisDir, iModule, bRemoveWMH, bAllSubjects, SubjectID)","title":"Format"},{"location":"Functions/#description_5","text":"This function (partly) reverts previous ExploreASL runs, deleting derivatives, while keeping raw data intact. if bAllSubjects==true, then all subjects and all module derivatives will be removed. This function performs the following steps: If a Population folder doesn't exist yet but dartel does, rename it Remove whole-study data files in AnalysisDir if bAllSubjects Remove lock files/folders for reprocessing Restore backupped _ORI (original) files Delete native space CAT12 temporary folders (always, independent of iModule) Remove native space files for iModule Remove standard space files for iModule Remove population module files Remove or clean up stored x-struct & QC file -> THIS HAS NO SESSION SUPPORT YET NB: still need to add xASL_module_func & xASL_module_dwi for EPAD","title":"Description"},{"location":"Functions/#xasl_adm_comparedatasetsm","text":"","title":"xASL_adm_CompareDataSets.m"},{"location":"Functions/#format_6","text":"[RMS] = xASL_adm_CompareDataSets(RefAnalysisRoot,SourceAnalysisRoot,x,type,mutexState)","title":"Format"},{"location":"Functions/#description_6","text":"Compare data sets is used to ... type 0: Only save type 1: Save and evaluate type 2: Only evaluate","title":"Description"},{"location":"Functions/#xasl_adm_comparelistsm","text":"","title":"xASL_adm_CompareLists.m"},{"location":"Functions/#format_7","text":"[NewList] = xASL_adm_CompareLists(list1, list2)","title":"Format"},{"location":"Functions/#description_7","text":"...","title":"Description"},{"location":"Functions/#xasl_adm_convertdate2nrm","text":"","title":"xASL_adm_ConvertDate2Nr.m"},{"location":"Functions/#format_8","text":"[Nr DayInYear] = xASL_adm_ConvertDate2Nr(TempDate)","title":"Format"},{"location":"Functions/#description_8","text":"Converts date to number input mmdd -> output mm (with days in fractions/floating point). Inverse from ConvertNrDate.","title":"Description"},{"location":"Functions/#xasl_adm_convertnr2timem","text":"","title":"xASL_adm_ConvertNr2Time.m"},{"location":"Functions/#format_9","text":"Time = xASL_adm_ConvertNr2Time(Nr)","title":"Format"},{"location":"Functions/#description_9","text":"Converts number to time input hh (with minutes in fractions/floating point) -> output hhmm. Inverse from xASL_adm_ConvertTime2Nr.","title":"Description"},{"location":"Functions/#xasl_adm_convertsubjsess2subj_sessm","text":"","title":"xASL_adm_ConvertSubjSess2Subj_Sess.m"},{"location":"Functions/#format_10","text":"[iSubj iSess] = xASL_adm_ConvertSubjSess2Subj_Sess(nSessions, iSubjSess)","title":"Format"},{"location":"Functions/#description_10","text":"Converts combined SubjectSession index to subject & session indices. Useful for data lists in ExploreASL.","title":"Description"},{"location":"Functions/#xasl_adm_converttime2nrm","text":"","title":"xASL_adm_ConvertTime2Nr.m"},{"location":"Functions/#format_11","text":"Nr = xASL_adm_ConvertTime2Nr(Time)","title":"Format"},{"location":"Functions/#description_11","text":"Converts time to number input hhmm -> output hh (with minutes in fractions/floating point). Inverse from xASL_adm_ConvertNr2Time.","title":"Description"},{"location":"Functions/#xasl_adm_copymovefilelistm","text":"","title":"xASL_adm_CopyMoveFileList.m"},{"location":"Functions/#format_12","text":"[List] = xASL_adm_CopyMoveFileList(OriDir, DstDir, StrRegExp, bMove[, bDir, bRecursive, bOverwrite, bVerbose])","title":"Format"},{"location":"Functions/#description_12","text":"Moves a file to a file, a file to a directory, or a directory to a directory. It keeps the initial extensions, no unzipping or zipping after the move. But it makes sure that only one of .nii and .nii.gz exists in the destination directory. Useful to split a large database.","title":"Description"},{"location":"Functions/#xasl_adm_correctnamem","text":"","title":"xASL_adm_CorrectName.m"},{"location":"Functions/#format_13","text":"strOut = xASL_adm_CorrectName(strIn[, bOption, strExclude])","title":"Format"},{"location":"Functions/#description_13","text":"Finds and replaces all non-word characters either by empty space or by an underscore. Optionally leaves in few selected special characters. Note that if '_' is excluded from replacement, but option 2 is on, then underscores are replaced anyway.","title":"Description"},{"location":"Functions/#xasl_adm_createcsvfilem","text":"","title":"xASL_adm_CreateCSVfile.m"},{"location":"Functions/#format_14","text":"xASL_adm_CreateCSVfile(CSVfilename,CSVdata)","title":"Format"},{"location":"Functions/#description_14","text":"Creates a CSV file that can be opened with excel from your data.","title":"Description"},{"location":"Functions/#xasl_adm_createfilereportm","text":"","title":"xASL_adm_CreateFileReport.m"},{"location":"Functions/#format_15","text":"x = xASL_adm_CreateFileReport(x, bHasFLAIR, bHasMoCo, bHasM0, bHasLongitudinal)","title":"Format"},{"location":"Functions/#description_15","text":"Prints a summary of created files or the individual modules (i.e. Structural, Longiutudinal & ASL modules). Provides a quick check to see what has been skipped, an whether all files are present. This script iterates across: Native space 1) subject and 2) session files, Resampled 3) subject and 4) session files, 5) Lock files and 6) QC Figure files. For all we perform a: A) Count of the files present, summarized in FileReportSummary.csv B) List of the missing files in \"Missing*.csv\" files PM: Simplify/optimize this code, to make filename variable changing, search within subject-directories, etc. Combine the parts searching for missing & summarizing count.","title":"Description"},{"location":"Functions/#xasl_adm_defineaslresolutionm","text":"","title":"xASL_adm_DefineASLResolution.m"},{"location":"Functions/#format_16","text":"x = xASL_adm_DefineASLResolution(x)","title":"Format"},{"location":"Functions/#description_16","text":"...","title":"Description"},{"location":"Functions/#xasl_adm_defineaslsequencem","text":"","title":"xASL_adm_DefineASLSequence.m"},{"location":"Functions/#format_17","text":"[x] = xASL_adm_DefineASLSequence(x)","title":"Format"},{"location":"Functions/#description_17","text":"This ExploreASL function tries to check what ASL sequence is being processed, if this was not already defined in x.Sequence. It does so by checking known combinations of readout dimensionality (x.readout_dim) and vendor, knowing the product sequences of the vendors.","title":"Description"},{"location":"Functions/#xasl_adm_deletefilepairm","text":"","title":"xASL_adm_DeleteFilePair.m"},{"location":"Functions/#format_18","text":"filepaths = xASL_adm_DeleteFilePair(path, ext1[, ext2 [, ext3 ...]]) xASL_adm_DeleteFilePair(path, ext1[, ext2 [, ext3 ...]])","title":"Format"},{"location":"Functions/#description_18","text":"Delete the file given in PATH, and also deletes files with the same name, but with extension given in EXT1, and potentially also EXT2, EXT3...","title":"Description"},{"location":"Functions/#xasl_adm_dicom2parmsm","text":"","title":"xASL_adm_Dicom2Parms.m"},{"location":"Functions/#format_19","text":"[parms pathDcmDictOut] = xASL_adm_Dicom2Parms(inp[, parmsfile, dcmExtFilter, bUseDCMTK, pathDcmDictIn])","title":"Format"},{"location":"Functions/#description_19","text":"The function goes through the INP files, reads the DICOM or PAR/REC files and parses their headers. It extracts the DICOM parameters important for ASL, makes sure they are in the correct format, if missing then replaces with default value, it also checks if the parameters are consistent across DICOM files for a single sequence.","title":"Description"},{"location":"Functions/#xasl_adm_findbyregexpm","text":"","title":"xASL_adm_FindByRegExp.m"},{"location":"Functions/#format_20","text":"xasl_adm_FindByRegExp(root, dirSpecs[, varargin])","title":"Format"},{"location":"Functions/#description_20","text":"Recursively find files in the root directory according to the dirSpecs.","title":"Description"},{"location":"Functions/#xasl_adm_findstrindexm","text":"","title":"xASL_adm_FindStrIndex.m"},{"location":"Functions/#format_21","text":"INDEX = xASL_adm_FindStrIndex(ARRAY, STRING)","title":"Format"},{"location":"Functions/#description_21","text":"Similar to find, but then for a cell array filled with strings. Only takes 4 dimensions.","title":"Description"},{"location":"Functions/#xasl_adm_getfslistm","text":"","title":"xASL_adm_GetFsList.m"},{"location":"Functions/#format_22","text":"RES = xASL_adm_GetFsList([strDirectory, strRegEx, bGetDirNames, bExcludeHidden, bIgnoreCase, nRequired])","title":"Format"},{"location":"Functions/#description_22","text":"List files or directories from a given path. And optionally uses regular expressions to filter the result with options to exclude hidden files, ignore case, and set a minimal requirement on the number of results. Sorts the results at the end.","title":"Description"},{"location":"Functions/#xasl_adm_getnumfromstrm","text":"","title":"xASL_adm_GetNumFromStr.m"},{"location":"Functions/#format_23","text":"num = xASL_adm_GetNumFromStr(str)","title":"Format"},{"location":"Functions/#description_23","text":"Obtains single number from string. CAVE there should only be one number!","title":"Description"},{"location":"Functions/#xasl_adm_getphilipsscalingm","text":"","title":"xASL_adm_GetPhilipsScaling.m"},{"location":"Functions/#format_24","text":"scaleFactor = xASL_adm_GetPhilipsScaling(pathParmsMat,pathNifti)","title":"Format"},{"location":"Functions/#description_24","text":"This script provides the correct scaling factors for a NIfTI file. It checks the header of the NIfTI that normally has the same scaling as RescaleSlope in DICOM, it checks if dcm2nii (by the info in JSON) has already converted the scale slopes to floating point. And if not, the derive the correct scaling factor to be applied.","title":"Description"},{"location":"Functions/#xasl_adm_getusernamem","text":"","title":"xASL_adm_GetUserName.m"},{"location":"Functions/#format_25","text":"UserName = xASL_adm_GetUserName()","title":"Format"},{"location":"Functions/#description_25","text":"...","title":"Description"},{"location":"Functions/#xasl_adm_hex2numm","text":"","title":"xASL_adm_Hex2Num.m"},{"location":"Functions/#format_26","text":"outNum = xASL_adm_hex2num(inStr)","title":"Format"},{"location":"Functions/#description_26","text":"Takes a hexadecimal string and converts it to number. Works also when the string contains escape characters, and for single-floats and for a little and big endian. If containing 8 and less characters than treat as float, if more than as double.","title":"Description"},{"location":"Functions/#xasl_adm_lesionreslicelistm","text":"","title":"xASL_adm_LesionResliceList.m"},{"location":"Functions/#format_27","text":"[INname, OUTname] = xASL_wrp_LesionResliceList(x,bLesion_T1,bLesion_FLAIR,bROI_T1,bROI_FLAIR)","title":"Format"},{"location":"Functions/#description_27","text":"Creates list of structural image paths to reslice.","title":"Description"},{"location":"Functions/#xasl_adm_load4dmemmappingm","text":"","title":"xASL_adm_Load4DMemMapping.m"},{"location":"Functions/#format_28","text":"LoadFile = xASL_adm_Load4DMemMapping(x, WhichModality)","title":"Format"},{"location":"Functions/#description_28","text":"Part of ExploreASL analysis module. Loads data & maps it to memory mapping file on disc, if not done before.","title":"Description"},{"location":"Functions/#xasl_adm_loadparmsm","text":"","title":"xASL_adm_LoadParms.m"},{"location":"Functions/#format_29","text":"[Parms, x, Oldx] = xASL_adm_LoadParms(ParmsPath[, x, bVerbose])","title":"Format"},{"location":"Functions/#description_29","text":"This function loads the internal memory x struct, any legacy *_parms.mat sidecar, any *.json BIDS sidecar, to use scan-specific parameters for image processing/quantification. Also, per BIDS inheritance, any x.S.SetsID parameters (from participants.tsv) are loaded as well. This function performs the following steps: Load .mat parameter file Load JSON file Deal with warnings Find fields with scan-specific data in x.S.Sets, and use this if possible (per BIDS inheritance) Sync Parms.* with x.(Q.)* (overwrite x/x.Q) Fix M0 parameter if not set","title":"Description"},{"location":"Functions/#xasl_adm_loadxm","text":"","title":"xASL_adm_LoadX.m"},{"location":"Functions/#format_30","text":"[x[, IsLoaded]] = xASL_adm_LoadX(x, Path_xASL[, bOverwrite])","title":"Format"},{"location":"Functions/#description_30","text":"This function loads x.Output & x.Output_im struct fields from the x.mat on the hard drive & adds them to the current x struct located in memory. If it didnt exist in the x.mat, it will set IsLoaded to false, which can be catched externally & a warning issued if managed so in the calling function. If it didnt exist in the memory x struct, or bOverwrite was requested, the contents of x.mat will be loaded to the memory x struct","title":"Description"},{"location":"Functions/#xasl_adm_orderfieldsm","text":"","title":"xASL_adm_OrderFields.m"},{"location":"Functions/#format_31","text":"outStruct = xASL_adm_OrderFields(inStruct,orderStruct)","title":"Format"},{"location":"Functions/#description_31","text":"Order fields in the structure inStruct to match {{orderStruct}}, unmatching fields in inStruct are copied as they are at the end, unmatching fields in orderStruct are ignored. This is just a cosmetic change and no values are edited.","title":"Description"},{"location":"Functions/#xasl_adm_otherlistspmm","text":"","title":"xASL_adm_OtherListSPM.m"},{"location":"Functions/#format_32","text":"[OtherListSPM, OtherListOut] = xASL_adm_OtherListSPM(OtherList, bList4D)","title":"Format"},{"location":"Functions/#description_32","text":"bPadComma1 is to add the ,1 to the end of the pathstring, which SPM uses to assign the first image of a 4D image array (OPTIONAL, DEFAULT = true) bList4D: boolean, true for listing multiple 4D volumes separately in the list (OPTIONAL, DEFAULT=true).","title":"Description"},{"location":"Functions/#xasl_adm_par2parmsm","text":"","title":"xASL_adm_Par2Parms.m"},{"location":"Functions/#format_33","text":"parms = xASL_adm_Par2Parms(pathPar, pathParms[, bRecreate])","title":"Format"},{"location":"Functions/#description_33","text":"Opens the Philips type PAR file. Reads the relevant DICOM headers and saves them to .MAT file. Only recreates an existing file if bRecreate option is set to TRUE.","title":"Description"},{"location":"Functions/#xasl_adm_parreadheaderm","text":"","title":"xASL_adm_ParReadHeader.m"},{"location":"Functions/#format_34","text":"info =xASL_adm_ParReadHeader(filename)","title":"Format"},{"location":"Functions/#description_34","text":"Function for reading the header of a Philips Par / Rec MR V4.* file.","title":"Description"},{"location":"Functions/#xasl_adm_remove_1_spmm","text":"","title":"xASL_adm_Remove_1_SPM.m"},{"location":"Functions/#format_35","text":"[OtherList] = xASL_adm_Remove_1_SPM(OtherList)","title":"Format"},{"location":"Functions/#description_35","text":"Remove ,1 at end of OtherLists, if exists. These are appended in CoregInit, OldNormalizeWrapper etc, since this should allow 4rd dim (e.g. as in ASL4D).","title":"Description"},{"location":"Functions/#xasl_adm_replacesymbolsm","text":"","title":"xASL_adm_ReplaceSymbols.m"},{"location":"Functions/#format_36","text":"strOut = xASL_adm_ReplaceSymbols(strIn, symbolTable[, bracketLeft, bracketRight])","title":"Format"},{"location":"Functions/#description_36","text":"It takes the STRIN on input, then looks for symbols between BRACKETLEFT and BRACKETRIGHT and replaces these symbols in in the string by the values provided in the SYMBOLTABLE as SYMBOLTABLE.SYMBOL, SYMBOLTABLE.D.SYMBOL, or SYMBOLTABLE.P.SYMBOL","title":"Description"},{"location":"Functions/#xasl_adm_resetvisualizationslicesm","text":"","title":"xASL_adm_ResetVisualizationSlices.m"},{"location":"Functions/#format_37","text":"[x] = xASL_adm_ResetVisualizationSlices(x)","title":"Format"},{"location":"Functions/#description_37","text":"Removes any predefined slices that should be visualized, allowing to show the default slices. Comes in handy when different pipeline visualization parts are repeated.","title":"Description"},{"location":"Functions/#xasl_adm_savejsonm","text":"","title":"xASL_adm_SaveJSON.m"},{"location":"Functions/#format_38","text":"xASL_adm_SaveJSON(data, jsonFileName)","title":"Format"},{"location":"Functions/#description_38","text":"Saves the values in the structure 'data' to a file in JSON format.","title":"Description"},{"location":"Functions/#xasl_adm_unziporcopym","text":"","title":"xASL_adm_UnzipOrCopy.m"},{"location":"Functions/#format_39","text":"unpackedFiles = xASL_adm_UnzipOrCopy(srcDir, wildCard, destDir [, bOverwrite])","title":"Format"},{"location":"Functions/#description_39","text":"This is a simple wrapper function to (g)unzip one or more files to the specified destination directory. Existing files or directories will not be overwritten, unless forced with bOverwrite. A regular file-copy will be used if the source files don't have gz or zip filename extensions.","title":"Description"},{"location":"Functions/#xasl_adm_voxel2realworldcoordinatesm","text":"","title":"xASL_adm_Voxel2RealWorldCoordinates.m"},{"location":"Functions/#format_40","text":"[X Y Z] = xASL_adm_Voxel2RealWorldCoordinates(X,Y,Z,VoxelSize)","title":"Format"},{"location":"Functions/#description_40","text":"Converts MNI coordinates from voxel coordinates/indices. Assumes X Y Z = LR LeftRight AP AnteriorPosterior IS InferiorSuperior. VoxelSize should be [1 3]-sized input.","title":"Description"},{"location":"Functions/#xasl_adm_zipfilelistm","text":"","title":"xASL_adm_ZipFileList.m"},{"location":"Functions/#format_41","text":"filepaths = xASL_adm_ZipFileList(strDirectory, strRegExp[, bRecurse, bUseGzip, nRequired]) xASL_adm_ZipFileList(strDirectory, strRegExp[, bRecurse, bUseGzip, nRequired])","title":"Format"},{"location":"Functions/#description_41","text":"Zip the files that match regular expression STRREGEXP in the given directory STRDIRECTORY. Zips recursively if specified in BRECURSE. Zips all files unless the number is specified by NREQUIRED, if the number is not met, then does not zip anything and throws an error.","title":"Description"},{"location":"Functions/#xasl_adm_uigetinputm","text":"","title":"xASL_adm_uiGetInput.m"},{"location":"Functions/#format_42","text":"[Parms] = xASL_adm_uiGetInput(Parms)","title":"Format"},{"location":"Functions/#description_42","text":"Checks whether input fields are present, or requests them.","title":"Description"},{"location":"Functions/#bids","text":"","title":"BIDS"},{"location":"Functions/#xasl_bids_add2participantstsvm","text":"","title":"xASL_bids_Add2ParticipantsTSV.m"},{"location":"Functions/#format_43","text":"xASL_bids_Add2ParticipantsTSV(DataIn, DataName, x, bOverwrite)","title":"Format"},{"location":"Functions/#description_43","text":"This function adds metadata/statistical variables to the participants.tsv in the root/analysis folder, by the following steps. This function will iterate over Data provided at DataIn and fill them in the participants.tsv, overwriting if allowed. Empty data is filled in as 'n/a', and the first column \"participants_id\" is sorted for participants. This function runs the following steps: Admin - Validate that there are not too many columns Admin - Detect nSubjectsSessions Admin - Load pre-existing participants.tsv or create one Admin - Get column number of data Add data to CellArray Sort rows on subjects Fill empty cells Write data to participants.tsv","title":"Description"},{"location":"Functions/#xasl_bids_dicom2jsonm","text":"","title":"xASL_bids_Dicom2JSON.m"},{"location":"Functions/#format_44","text":"[parms pathDcmDictOut] = xASL_bids_Dicom2Parms(inp[, parmsfile, dcmExtFilter, bUseDCMTK, pathDcmDictIn])","title":"Format"},{"location":"Functions/#description_44","text":"The function goes through the INP files, reads the DICOM or PAR/REC files and parses their headers. It extracts the DICOM parameters important for ASL, makes sure they are in the correct format, if missing then replaces with default value, it also checks if the parameters are consistent across DICOM files for a single sequence.","title":"Description"},{"location":"Functions/#xasl_bids_insertjsonfieldsm","text":"","title":"xASL_bids_InsertJSONFields.m"},{"location":"Functions/#format_45","text":"[ChildJSON] = xASL_bids_InsertJSONFields(ParentJSON, ChildJSON[, Fields2Skip])","title":"Format"},{"location":"Functions/#description_45","text":"This function takes all parameters from the \"parent\" JSON & moves them into the \"child\" JSON. In case of co-existence of a field with different values, then the value in the child JSON will prevail, per BIDS inheritance. This function runs the following steps: Load JSON or parms.mat (legacy), if the inputs were paths Insert the fields Save a new JSON file (if ChildJSON was a path)","title":"Description"},{"location":"Functions/#xasl_bids_parrec2jsonm","text":"","title":"xASL_bids_PARREC2JSON.m"},{"location":"Functions/#format_46","text":"parms = xASL_adm_Par2Parms(pathPar, PathJSON)","title":"Format"},{"location":"Functions/#description_46","text":"Opens the Philips type PAR file. Reads the relevant DICOM header fields and adds them to the .json sidecar file.","title":"Description"},{"location":"Functions/#xasl_bids_parms2bidsm","text":"","title":"xASL_bids_parms2BIDS.m"},{"location":"Functions/#format_47","text":"outBids = xASL_bids_parms2BIDS(inParms[, inBids, bOutBids, priorityBids])","title":"Format"},{"location":"Functions/#description_47","text":"This functions takes two parameter structures and merges them. At the same time, renames all fields according to the output type (note that only some fields have two standardised names different between the two formats. In case of duplicities, takes the field value from the preferred format. Also takes into account that the units in BIDS are s, but in xASL ms. This function performs the following steps: Define field names that need to be convert/renamed/merged Convert XASL fields to the output format (BIDS or XASL) Convert BIDS fields to the output format (BIDS or XASL) Merge the BIDS and XASL fields, convert field values","title":"Description"},{"location":"Functions/#fsl","text":"","title":"FSL"},{"location":"Functions/#xasl_fsl_runfslm","text":"","title":"xASL_fsl_RunFSL.m"},{"location":"Functions/#format_48","text":"[x] = xASL_adm_RunFSL(FSLCommand, x[, OutputZipping])","title":"Format"},{"location":"Functions/#description_48","text":"This function runs an FSL command from ExploreASL: Checking the FSL dir Manage CUDA/CPU parallelization (currently disabled, WIP) Setting up FSL environment Running the command Supports .nii & .nii.gz, Linux, MacOS & Windows (WSL)","title":"Description"},{"location":"Functions/#xasl_fsl_setfsldirm","text":"","title":"xASL_fsl_SetFSLdir.m"},{"location":"Functions/#format_49","text":"[FSLdir[, x, RootWSLdir]] = xASL_adm_SetFSLdir(x, bUseLatestVersion)","title":"Format"},{"location":"Functions/#description_49","text":"This function finds the FSLdir & puts it out, also in x.FSLdir to allow repeating this function without having to repeat searching. If the FSLdir & RootFSLDir are already defined in x.FSLdir & x.RootFSLDir, this function is skipped. Supports Linux, MacOS & Windows (WSL), & several different default installation folders for different Linux distributions","title":"Description"},{"location":"Functions/#xasl_fsl_topupm","text":"","title":"xASL_fsl_TopUp.m"},{"location":"Functions/#format_50","text":"xASL_fsl_TopUp(InDir[, ScanType], x)","title":"Format"},{"location":"Functions/#description_50","text":"This function runs FSL TopUp. It assumes that there are 2 TopUp images, i.e. 1 blip up & 1 blip down. Admin: manage ScanType, NIfTI paths, create TopUp parameter file for image to apply TopUp to & for the TopUp NIfTIs, delete files from previous run, define the image with the same acquisition parameters as TopUp (does the image we apply TopUp to, have the Blip up or down?) Register images to image that we apply TopUp to (registration between blip up/down images is performed by TopUp) Run TopUp estimate (i.e. estimate the geometric distortion field from B0 NIfTI & parameters file), this takes quite long. Also has a x.Quality=0 option that is very fast but inaccurate, to try out this pipeline part. Before TopUp, NaNs (e.g. from resampling) are removed from the images TopUp is run with default settings Apply TopUp","title":"Description"},{"location":"Functions/#imaging","text":"","title":"Imaging"},{"location":"Functions/#xasl_im_bilateralfilterm","text":"","title":"xASL_im_BilateralFilter.m"},{"location":"Functions/#format_51","text":"[ovol] = xASL_im_BilateralFilter(volIM, mask, VoxelSize, x)","title":"Format"},{"location":"Functions/#description_51","text":"This function runs a spatial lowpass temporally highpass filter, and removes outliers within this signal, and adapts the time-series accordingly.","title":"Description"},{"location":"Functions/#xasl_im_centerofmassm","text":"","title":"xASL_im_CenterOfMass.m"},{"location":"Functions/#format_52","text":"xASL_im_CenterOfMass(PathNIfTI, OtherList, AllowedDistance)","title":"Format"},{"location":"Functions/#description_52","text":"This function estimates the center of mass of the image matrix, and if this is too far off the current orientation matrix center, the center will be reset. This fixes any incorrect orientation outputted by the scanner. The realignment is only applied when any of the X/Y/Z dimensions have a higher offset than AllowedDistance.","title":"Description"},{"location":"Functions/#xasl_im_cleanupwmhnoisem","text":"","title":"xASL_im_CleanupWMHnoise.m"},{"location":"Functions/#format_53","text":"xASL_im_CleanupWMHnoise(InputPath, OutputPath, MinLesionVolume, pThresh)","title":"Format"},{"location":"Functions/#description_53","text":"Threshold white matter lesions, acknowledging the fact that they may be confluent with subresolution connection through a dilation. This part is executed conservatively, as FLAIR hyperintensities inside the GM can be erroneously segmented as WMH, and should not be lesion-filled (otherwise these cannot be fixed later in the Structural module). Note that LST lesion filling expects a probability map, doesnt work nicely with binary mask","title":"Description"},{"location":"Functions/#xasl_im_clipextremesm","text":"","title":"xASL_im_ClipExtremes.m"},{"location":"Functions/#format_54","text":"[NewIM] = xASL_im_ClipExtremes(InputIm, ThreshHigh, ThreshLow, bVerbose)","title":"Format"},{"location":"Functions/#description_54","text":"Clips image to given percentile. The percentile is found using non-zeros sorted intensities, so both isfinite & non-zeros.","title":"Description"},{"location":"Functions/#xasl_im_column2imm","text":"","title":"xASL_im_Column2IM.m"},{"location":"Functions/#format_55","text":"[ImageOut] = xASL_im_Column2IM(ColumnIn, BrainMask)","title":"Format"},{"location":"Functions/#description_55","text":"This function \"decompresses\" an image matrix (or multiple matrices) from a single-dimensional column, by reconstructing the image matrix from the voxel positions within the BrainMask. NB: Important to use the same BrainMask as used for converting the image matrix to the column! See also: xASL_im_IM2Column.m The mask mostly used for xASL_im_IM2Column is x.WBmask, which completely engulfes pGM, pWM & pCSF.","title":"Description"},{"location":"Functions/#xasl_im_compareniftiresolutionxyzm","text":"","title":"xASL_im_CompareNIfTIResolutionXYZ.m"},{"location":"Functions/#format_56","text":"[IsEqualResolution] = xASL_im_CompareNIfTIResolutionXYZ(PathNIfTI1, PathNIfTI2)","title":"Format"},{"location":"Functions/#description_56","text":"This function checks whether the X, Y and Z resolution of a NIfTI with any number of dimensions is equal. It rounds for 2 floating points, for both NIfTIs, to ensure that the same precision is compared.","title":"Description"},{"location":"Functions/#xasl_im_computedicem","text":"","title":"xASL_im_ComputeDice.m"},{"location":"Functions/#format_57","text":"DiceCoeff = xASL_im_ComputeDice(imA, imB)","title":"Format"},{"location":"Functions/#description_57","text":"Calculate Dice coefficient of image overlap.","title":"Description"},{"location":"Functions/#xasl_im_createasldeformationfieldm","text":"","title":"xASL_im_CreateASLDeformationField.m"},{"location":"Functions/#format_58","text":"xASL_im_CreateASLDeformationField(x, bOverwrite, EstimatedResolution)","title":"Format"},{"location":"Functions/#description_58","text":"This function smooths a transformation flow field to a lower resolution. Usually, we use a high resolution anatomical image (e.g. 3D T1w ) to obtain the flowfields from native space to standard space, and apply these to the lower resolution ASL images. Because of the resolution differences, the flowfields need to be downsampled/smoothed, to avoid deformation effects that are crispier than the functional image that is investigated. This function performs the following steps: Obtain resolutions Fill NaNs at edges y_T1.nii flowfield to prevent interpolation artifact Smooth flowfield Fill NaNs at edges y_ASL.nii Note that if the resolution of ASL is not significantly (i.e. >0.5 mm in any dimension) lower than T1w, the y_T1.nii is copied to y_ASL.nii","title":"Description"},{"location":"Functions/#xasl_im_createpseudocbfm","text":"","title":"xASL_im_CreatePseudoCBF.m"},{"location":"Functions/#format_59","text":"xASL_im_CreatePseudoCBF(x, spatialCoV)","title":"Format"},{"location":"Functions/#description_59","text":"This function creates a pseudo-CBF image from mean CBF template, arterial transit time (ATT) bias field & vascular artifacts, weighted through spatial CoV The first part of this code puts templates in the native space and creates a pseudoCBF image from a downsampled pGM & pWM tissue (PseudoTissue). The latter is used for registration but also as reference for the template registration, to speed this up. The second part of this code computes a pseudoCBF image based on the pseudoTissue & the CBF templates of CBF, ATT biasfield and vascular peaks, based on spatial CoV. This submodule performs the following steps: Create the pseudoTissue CBF reference image, if it doesnt exist already Create the native space copies of ASL templates, if they dont exist already Spatial CoV input argument check Load native space copies of templates Create pseudoTissue from segmentations, mix this with the mean CBF template depending on spatial CoV Create pseudoCBF reference image used for CBF-based registration Scale mean_PWI_Clipped source image to the same range as PseudoCBF","title":"Description"},{"location":"Functions/#xasl_im_createslicegradientm","text":"","title":"xASL_im_CreateSliceGradient.m"},{"location":"Functions/#format_60","text":"xASL_im_CreateSliceGradient(x)","title":"Format"},{"location":"Functions/#description_60","text":"Create slice gradient in same space as input file Reslice slice gradient to MNI (using existing ASL matrix changes from e.g. registration to MNI, motion correction, registration to GM) Creating average slice gradient","title":"Description"},{"location":"Functions/#xasl_im_decomposeaffinetransformationm","text":"","title":"xASL_im_DecomposeAffineTransformation.m"},{"location":"Functions/#format_61","text":"[M, P] = xASL_im_DecomposeAffineTransformation(Mtransformation)","title":"Format"},{"location":"Functions/#description_61","text":"This function splits a transformation matrix into individual components, which can be useful to guide the SPM reslicing. The components are the same as in spm_(i)matrix.m, except for the shearing: these are included in the rotations, and the 90 degree rotations, these are separated. Reason for the separation of the 90 degree rotations, is that these indicate if orientations (transversal, coronal & sagittal) have been switched in the NIfTI. This can be useful to correct for any erroneous 90degree rotations from registration, or to put two images in the same orientation order or voxelsize without applying their subtle realignment (e.g. for manipulating registration references) THEORY 90 degree rotations: Any rotation will always swap the other dims (X rotation swaps Y/Z, Y rotation swaps X/Z etc.) because they are perpendicular (haaks) Dims X Y Z care for LR, AP and IS translation. - X-rotation will rotate the transverse slice (LR <-> AP) swapping Y (coronal) & Z (saggital) - Y-rotation will rotate the coronal slice (IS <-> LR) slice, swapping X (transversal) and Z (sagittal) - Z-rotation will rotate the sagittal slice (AP <-> IS) swapping X (transversal) and Y (sagittal) E.g., MPRAGE is acquired in sagittal slices, and ASL/fMRI/BOLD in transversal slices. This is an Y rotation (you look into the coronal plane, rotate this, which will swap the sagittal slices into transversal) This function performs the following steps: Start with an output P and M struct Obtain translations Obtain zoom Obtain 90degree rotations Obtain subtle rotations & shearing Check the rounding errors of the decomposition","title":"Description"},{"location":"Functions/#xasl_im_determineflipm","text":"","title":"xASL_im_DetermineFlip.m"},{"location":"Functions/#format_62","text":"[QCstruct] = xASL_im_DetermineFlip(x,iS,PathOrientationResults,QCstruct)","title":"Format"},{"location":"Functions/#description_62","text":"Check determinants, should be the same before & after registration, otherwise a left-right flip is applied This is not visible, but detrimental for image analysis/stats.","title":"Description"},{"location":"Functions/#xasl_im_dilateerodefullm","text":"","title":"xASL_im_DilateErodeFull.m"},{"location":"Functions/#format_63","text":"new_mask = xASL_im_DilateErodeFull(mask,type,kernel)","title":"Format"},{"location":"Functions/#description_63","text":"Runs dilation or erosion on a binary mask in full three dimensions It uses its own dilate_erode function and crops the image so that it contains only the mask. Works only with odd sized kernels.","title":"Description"},{"location":"Functions/#xasl_im_dilateerodeseparablem","text":"","title":"xASL_im_DilateErodeSeparable.m"},{"location":"Functions/#format_64","text":"new_mask = xASL_im_DilateErodeSeparable(mask,type,kernel_x,kernel_y,kernel_z)","title":"Format"},{"location":"Functions/#description_64","text":"Runs dilation or erosion on a binary mask separably in three dimensions It uses its own dilate_erode function and crops the image so that it contains only the mask. Works only with odd sized kernels","title":"Description"},{"location":"Functions/#xasl_im_dilateerodespherem","text":"","title":"xASL_im_DilateErodeSphere.m"},{"location":"Functions/#format_65","text":"el = xASL_im_DilateErodeSphere(R)","title":"Format"},{"location":"Functions/#description_65","text":"3D structuring element (binary) sphere.","title":"Description"},{"location":"Functions/#xasl_im_dummyorientationniftim","text":"","title":"xASL_im_DummyOrientationNIfTI.m"},{"location":"Functions/#format_66","text":"xASL_im_DummyOrientationNIfTI(PathSrc, PathRef, PathDummyOut[, bApplyRotationMinor, bApplyRotation90, bApplyZoom, bApplyTranslation])","title":"Format"},{"location":"Functions/#description_66","text":"This function creates a dummy image as reference for xASL_spm_reslice, allowing to only apply specific parts of the transformation between the two images. E.g. only the rotation, or only the zooming. This can be useful to correct for any erroneous rotations from registration, or to put two images in the same space without applying their realignment. This function performs the following steps: Load orientations & calculate transformation Calculate the desired transformation Calculate new orientation matrix Calculate the new image size Save the dummy NIfTI","title":"Description"},{"location":"Functions/#xasl_im_estimateresolutionm","text":"","title":"xASL_im_EstimateResolution.m"},{"location":"Functions/#format_67","text":"[resFWHM, resSigma,resErr,imSmo,imMask] = xASL_im_EstimateResolution(imCBF,imGM,imWM,imMaskOrig,PSFtype,maxIter)","title":"Format"},{"location":"Functions/#description_67","text":"NB: everything in this code is in voxels, not in mm","title":"Description"},{"location":"Functions/#xasl_im_flipm","text":"","title":"xASL_im_Flip.m"},{"location":"Functions/#format_68","text":"[MatrixOut] = xASL_im_Flip(MatrixIn, varargin)","title":"Format"},{"location":"Functions/#description_68","text":"Backwards compatibility for flipping left-right in standard space (NB: this can be different than in native space!).","title":"Description"},{"location":"Functions/#xasl_im_im2columnm","text":"","title":"xASL_im_IM2Column.m"},{"location":"Functions/#format_69","text":"[ColumnOut] = xASL_im_IM2Column(ImageIn, BrainMask[, ApplyShiftDim])","title":"Format"},{"location":"Functions/#description_69","text":"This function \"compresses\" an image matrix (or multiple matrices) for optimization of memory and CPU resources. The output column only includes voxels that lie within the BrainMask. This excludes extracranial zero-information voxels from computations and memory use. NB: Important to use the same BrainMask for converting the column back to an image matrix! See also: xASL_im_Column2IM.m The mask mostly used for xASL_im_IM2Column is x.WBmask, which completely engulfes pGM, pWM & pCSF","title":"Description"},{"location":"Functions/#xasl_im_jointhistm","text":"","title":"xASL_im_JointHist.m"},{"location":"Functions/#format_70","text":"imHist = xASL_im_JointHist(imA,imB[,imMask,minA,maxA,minB,maxB,nBins])","title":"Format"},{"location":"Functions/#description_70","text":"It calculates a joint histogram of two images of any dimensions over a mask of the same size. The boundaries and number of bins can either be given or min and max values are used. Values outside of the bins are counted to the first/last bin.","title":"Description"},{"location":"Functions/#xasl_im_lesion2catm","text":"","title":"xASL_im_Lesion2CAT.m"},{"location":"Functions/#format_71","text":"LesionPathOut = xASL_im_Lesion2CAT(PathIn)","title":"Format"},{"location":"Functions/#description_71","text":"For all lesion masks in the anatomical directory, load them, merge them and save them for the CAT segmentation. If there are no lesions found, the images are untouched.","title":"Description"},{"location":"Functions/#xasl_im_lesion2maskm","text":"","title":"xASL_im_Lesion2Mask.m"},{"location":"Functions/#format_72","text":"LesionIM = xASL_im_Lesion2Mask(LesionPath, T1path, pGMpath, pWMpath, x)","title":"Format"},{"location":"Functions/#description_72","text":"For a standard space lesion mask (or map), this stores the lesion mask, and in additional its perimask (15 mm) and contralateral mask, as 2nd and 3rd volumes. It plots the masks on a T1 image, and masks the new masks with the subjects' brainmask (pGM+pWM).","title":"Description"},{"location":"Functions/#xasl_im_m0erodesmoothextrapolatem","text":"","title":"xASL_im_M0ErodeSmoothExtrapolate.m"},{"location":"Functions/#format_73","text":"[ImOut] = xASL_im_M0ErodeSmoothExtrapolate(ImIn, x)","title":"Format"},{"location":"Functions/#description_73","text":"This function erodes, smooths & extrapolates M0 in standard space. It assumes that the M0 image is in standard space & that the GM & WM probability maps are aligned. Here, we mask the M0, to remove high CSF signal and low extracranial signal, enabling us to smooth the image without inserting wrong signal. See also the ExploreASL manuscript for a more extensive explanation. This function performs the following steps: Mask: Load segmentations, create structural mask Mask: Create intensity-based mask to remove extracranial signal Mask: Erode the combined masks Mask: Determine any odd borders Smoothing Extrapolating only Scale back to the GM M0 Print visual QC figure A visual QC figure is created, showing the M0 image processing steps for a single transversal slice (slice 53 in 1.5 mm MNI standard space) OutputFile = fullfile(x.D.M0regASLdir,['M0_im_proc_' x.P.SubjectID '.jpg']); The original M0 image (a) is masked with a (pGM+pWM)>50% mask (b) eroded with a two-voxel sphere to limit the influence of the ventricular and extracranial signal (c) and thresholded to exclude significantly high (i.e. median + 3*mean absolute deviation (MAD)) border region values (d) This masked M0 image is smoothed with a 16x16x16 mm full- width-half-maximum Gaussian filter (Mutsaerts et al., 2018) (e) after which the signal at the border is smoothly extrapolated until the full image is filled (f). Whereas the masking avoids mixing with cerebrospinal fluid or extracranial signal, the extrapolation avoids M0 division artifacts","title":"Description"},{"location":"Functions/#xasl_im_masknegativevascularsignalm","text":"","title":"xASL_im_MaskNegativeVascularSignal.m"},{"location":"Functions/#format_74","text":"[NegativeMask, TreatedCBF] = xASL_quant_DetectNegativeVascularSignal(x)","title":"Format"},{"location":"Functions/#description_74","text":"This function segments clusters with significant negative ASL signal. This can be tricky as there is also the negative tail of Gaussian noise from the ASL subtraction. The image feature we use here, is that negative vascular signal will be a relatively large region with significant median negative value, whereas noise will be regions with relatively small negative signal. Negative signal from wrong background suppression timing (e.g. in the first slice with 2D EPI) can be masked out with this as well. The procedure works as follows: 1) Obtain mask of negative voxels within pGM>0.5 mask 2) Obtain distribution of subzero clusters 3) Define the negative threshold 4) Create mask by thresholding whole image Note that the definition of the threshold is obtained within the GM only, but that this threshold is applied to the full image","title":"Description"},{"location":"Functions/#xasl_im_maskpeakvascularsignalm","text":"","title":"xASL_im_MaskPeakVascularSignal.m"},{"location":"Functions/#format_75","text":"[MaskIM, CBF] = xASL_quant_VascularContrast(PathCBF, Path_M0, CompressionRate, ClipThresholdValue, bClip)","title":"Format"},{"location":"Functions/#description_75","text":"This function searches for an acceptable high threshold as definition of high intra-vascular ASL signal. It also allows to compress the values here (when bClip==true). Compression retains some variability, but limits their outlying influence on statistics. The procedure works as follows: Segment GM on ASL image at 80th percentile of CBF image distribution For PWI & CBF images, select voxels higher than median + ClipThresholdValue MAD Vascular artifacts will have a high intensity in both images, whereas errors by division by M0 will only have a high intensity on the M0 image, and high values due to a biasfield will only be noticeable on the PWI image Combine the two created masks Obtain average clipping value from selected voxels from the combined masks Apply compression if requested. If not, output image will have NaNs for intra-vascular voxels. Note that the definition of the threshold is obtained within the GM only, but that this threshold is applied to the full image to also remove extracranial extreme values.","title":"Description"},{"location":"Functions/#xasl_im_modulationm","text":"","title":"xASL_im_Modulation.m"},{"location":"Functions/#format_76","text":"xASL_im_Modulation(x)","title":"Format"},{"location":"Functions/#description_76","text":"Combines the transformations to create Jacobians, & multiplies the standard space segmentations with these to create volumetric images for volumetric analyses.","title":"Description"},{"location":"Functions/#xasl_im_normalizelabelingterritoriesm","text":"","title":"xASL_im_NormalizeLabelingTerritories.m"},{"location":"Functions/#format_77","text":"image_out = xASL_im_NormalizeLabelingTerritories( imageIN, GMmask, x)","title":"Format"},{"location":"Functions/#description_77","text":"Normalizes per perfusion territory mask should be GM mask.","title":"Description"},{"location":"Functions/#xasl_im_pcam","text":"","title":"xASL_im_PCA.m"},{"location":"Functions/#format_78","text":"[pc, score, eigenvalues, tsquare, loadings, Xmean] = xASL_im_PCA(dataIn)","title":"Format"},{"location":"Functions/#description_78","text":"...","title":"Description"},{"location":"Functions/#xasl_im_pvcbsplinem","text":"","title":"xASL_im_PVCbspline.m"},{"location":"Functions/#format_79","text":"[imPVEC,imCBFrec,imResidual,FWHM] = xASL_im_PVCbspline(imCBF,imPV,bsplineNum)","title":"Format"},{"location":"Functions/#description_79","text":"PVEc correction of ASL data using prior GM-,WM-partial volume maps. Follows the principles of the PVEc algorithm by I. Asllani (MRM, 2008). The PV-corrected CBF_GM and CBF_WM maps are approximated using an uniformly sampled cubic B-splines. Free for research use without guarantee. Created by Jan Petr, j.petr@hzdr.de","title":"Description"},{"location":"Functions/#xasl_im_pvckernelm","text":"","title":"xASL_im_PVCkernel.m"},{"location":"Functions/#format_80","text":"[imPVEC,imCBFrec,imResidual] = xASL_im_PVCkernel(imCBF, imPV,kernel,mode)","title":"Format"},{"location":"Functions/#description_80","text":"PVEc correction of ASL data using prior GM-,WM-partial volume maps. Follows the principles of the PVEc algorithm by I. Asllani (MRM, 2008). Free for research use without guarantee. If used in a study or publication. Please, acknowledge the author. Created by Jan Petr, j.petr@hzdr.de","title":"Description"},{"location":"Functions/#xasl_im_presmoothm","text":"","title":"xASL_im_PreSmooth.m"},{"location":"Functions/#format_81","text":"pathOut = xASL_im_PreSmooth(pathRef,pathSrc[,pathSmo,resRef,resSrc,srcAffinePath, bInvAffine])","title":"Format"},{"location":"Functions/#description_81","text":"It assumes that the FWHM is equal to voxel size, unless the real resolution is given. Then takes into account the voxel sizes and orientation difference between the volumes, but performs the smoothing according to the given real resolution (it is possible to supply the resolution for just one image) - this should be helpful primarily when the It creates a Gaussian covariance matrix for the reference, transforms it according to the difference between the two images a produces the Gaussian covariance matrix of the pre-smoothing in the source space. Then it performs the smoothing. The following steps are performed: 1) Obtain the voxel size 2) Skip this function if reference resolution is equal to, or lower than source resolution 3) Deal with affine transformation 4) Obtain the transformation matrix from the Reference to the Source space 5) Apply the smoothing filter on the source image(s) 6) Save the smoothed image","title":"Description"},{"location":"Functions/#xasl_im_processm0conventionalm","text":"","title":"xASL_im_ProcessM0Conventional.m"},{"location":"Functions/#format_82","text":"[Corr_M0] = xASL_im_ProcessM0Conventional(ImIn, x)","title":"Format"},{"location":"Functions/#description_82","text":"This function uses the conventional M0 masking, and only a little smoothing, following what Philips uses for its 3D {{GRASE}}. Advantages of the newer M0 processing in ExploreASL are the lack of use of M0 threshold-based masking, the removal of high CSF values and higher SNR for ASL division.","title":"Description"},{"location":"Functions/#xasl_im_projectlabelsoverdatam","text":"","title":"xASL_im_ProjectLabelsOverData.m"},{"location":"Functions/#format_83","text":"OutputIM = xASL_im_ProjectLabelsOverData(DataIM,LabelIM,x,ScaleFactorData,ScaleFactorLabel)","title":"Format"},{"location":"Functions/#description_83","text":"This script projects labels over an image, but works only in 2D. Make sure to make a 2D image from a 3D or 4D image using xASL_vis_TransformData2View.m can be used in combination with xASL_vis_Imwrite.m","title":"Description"},{"location":"Functions/#xasl_im_resamplelinearfairm","text":"","title":"xASL_im_ResampleLinearFair.m"},{"location":"Functions/#format_84","text":"[output_res]=xASL_im_ResampleLinearFair(im_input,newsize)","title":"Format"},{"location":"Functions/#description_84","text":"Downsample (or upsample, works similarly) old_res image to low_res image, trilinear. NB: new_res should fit exactly integer fold in old_res NB: all dimensions of new_res should have equal size","title":"Description"},{"location":"Functions/#xasl_im_restoreorientationm","text":"","title":"xASL_im_RestoreOrientation.m"},{"location":"Functions/#format_85","text":"xASL_im_RestoreOrientation(PathNIfTI)","title":"Format"},{"location":"Functions/#description_85","text":"This function reverts the NIfTI header orientation matrix to the original orientation from the scanner/dcm2nii conversion.","title":"Description"},{"location":"Functions/#xasl_im_skullstripm","text":"","title":"xASL_im_SkullStrip.m"},{"location":"Functions/#format_86","text":"xASL_im_SkullStrip(InPath, PathMNIMask, x, OutPath)","title":"Format"},{"location":"Functions/#description_86","text":"Creates skull-stripped T1w image based on MNI -> native space registration from segmentation.","title":"Description"},{"location":"Functions/#xasl_im_smooth3dm","text":"","title":"xASL_im_Smooth3D.m"},{"location":"Functions/#format_87","text":"[imSmo,imGaussX,imGaussY,imGaussZ] = xASL_im_Smooth3D(sigma,imIn,PSFtype)","title":"Format"},{"location":"Functions/#description_87","text":"...","title":"Description"},{"location":"Functions/#xasl_im_upsamplem","text":"","title":"xASL_im_Upsample.m"},{"location":"Functions/#format_88","text":"xASL_im_Upsample(PathOrig, PathDest, NewVoxelSize, LeaveEmpty, PaddingDim, Kernel)","title":"Format"},{"location":"Functions/#description_88","text":"Upsamples an ASL image, without changing the orientation matrix, which can be used e.g. for PVEc in higher resolution but same space.","title":"Description"},{"location":"Functions/#xasl_im_zeroedgesm","text":"","title":"xASL_im_ZeroEdges.m"},{"location":"Functions/#format_89","text":"[IM] = xASL_im_ZeroEdges(IM[, EdgeThicknessPerc])","title":"Format"},{"location":"Functions/#description_89","text":"Resampling can sometimes give some strange errors near image edges. These should be NaNs, but sometimes can be zeros or ones, or even weird numbers. For resampling, NaNs should be set to 0 (this is done in another function) as they can influence the resampling (depending on the transformation matrix). To be sure that the edges are nicely fixed, this function sets a border at the image matrix edges to zero.","title":"Description"},{"location":"Functions/#xasl_im_dilateroim","text":"","title":"xASL_im_dilateROI.m"},{"location":"Functions/#format_90","text":"xASL_im_dilateROI(PathIn, PathTemp)","title":"Format"},{"location":"Functions/#description_90","text":"...","title":"Description"},{"location":"Functions/#xasl_im_rotatem","text":"","title":"xASL_im_rotate.m"},{"location":"Functions/#format_91","text":"rotated = xASL_im_rotate(im, angle)","title":"Format"},{"location":"Functions/#description_91","text":"Simple rotation of the first two dimension of a ND image by 0, 90, 180, 270 degrees.","title":"Description"},{"location":"Functions/#xasl_import_jsonm","text":"","title":"xASL_import_json.m"},{"location":"Functions/#format_92","text":"[x] = xASL_import_json(DataParFile)","title":"Format"},{"location":"Functions/#description_92","text":"This function reads in a DATA_PAR file and creates the x structure. The name of the DATA_PAR file is given as a string or character array. The output is the x structure. If the DATA_PAR file is the dataset_description.json file of the BIDS standard, the x structure is created according to BIDS.","title":"Description"},{"location":"Functions/#initialization","text":"","title":"Initialization"},{"location":"Functions/#xasl_init_convertm2jsonm","text":"","title":"xASL_init_ConvertM2JSON.m"},{"location":"Functions/#format_93","text":"[PathJSON] = xASL_init_ConvertM2JSON(PathM)","title":"Format"},{"location":"Functions/#description_93","text":"This function converts and replaces the legacy data parameter m-format by a JSON file. A DataPar.m was the settings/parameter file, specific to a dataset to be processed by ExploreASL, now replaced to JSON by BIDS. Note that the deployed/compiled version of ExploreASL requires the JSON file, this function should not be compiled along. This function performs the following steps: 1) Run the m-file to load parameters 2) Escape characters that are illegal in JSON 3) Write the JSON","title":"Description"},{"location":"Functions/#xasl_init_defaulteffectiveresolutionm","text":"","title":"xASL_init_DefaultEffectiveResolution.m"},{"location":"Functions/#format_94","text":"[EffectiveResolution] = xASL_init_DefaultEffectiveResolution(PathASL, x)","title":"Format"},{"location":"Functions/#description_94","text":"This ExploreASL module provides an educated guess on the effective spatial resolution of ASL. This may depend on the combination of acquisition PSF, reconstruction filter, head motion. Note that the derived/processed images may have a lower effective resolution because of smoothing effects from interpolation. Note that this remains an educated-guess, the actual FWHM may still differ, especially for 3D GRASE sequences, where e.g. the choice of number of segments can affect the smoothness. This function conducts the following steps: 1) Educated-guess FWHM 2) Attempt accounting for in-plane interpolation in reconstruction 3) Calculate and report effective spatial resolution","title":"Description"},{"location":"Functions/#xasl_init_definestudydatam","text":"","title":"xASL_init_DefineStudyData.m"},{"location":"Functions/#format_95","text":"[x] = xASL_init_DefineStudyData(x)","title":"Format"},{"location":"Functions/#description_95","text":"This initialization wrapper initializes the parameters for this pipeline run, i.e. subjects, sessions (runs), timepoints (visits), exclusions, sites, cohorts etc. Note that ASL sessions are defined here as what BIDS calls \"runs\". The \"longitudinal_Registration functions here manage different TimePoints, which is what BIDS calls \"visits\". With different structural scans, from the same participant. This is managed by subject name suffixes _1 _2 _n, and can be used for comparing visits in the population module, or running SPM's longitudinal within-subject registration. Parallelization is allowed here by calling ExploreASL different times, where it divides the subjects/images for processing across the nWorkers, using iWorker as the reference for the part that the current ExploreASL call will process. This requires having a Matlab license that can be started multiple times on a server, or alternatively running the ExploreASL compilation, and doesn't require the Matlab parallel toolbox. This function exists from the following parts: Manage included & excluded subjects Create dummy defaults (exclusion list, ASL sessions) Create list of total baseline & follow-up subjects, before exclusions Create TimePoint data-lists Manage exclusions Add sessions as statistical variable, if they exist Parallelization: If running parallel, select cases for this worker Add Longitudinal TimePoints (different T1 volumes) as covariate/set, after excluding Load & add statistical variables Make x.S.SetsOptions horizontal if vertical by transposing Create single site dummy, if there were no sites specified Check for time points sets Create list of baseline & follow-up subjects (i.e. after exclusion) Check what excluded from which TimePoints","title":"Description"},{"location":"Functions/#xasl_init_filesystemm","text":"","title":"xASL_init_FileSystem.m"},{"location":"Functions/#format_96","text":"[x] = xASL_init_FileSystem(x)","title":"Format"},{"location":"Functions/#description_96","text":"This function initializes the file system used throughout ExploreASL, for processing a single dataset/scan. It is repeated for each scan, and runs the following parts: 1) Create folders 2) Subject/session definitions 3) Add prefixes & suffixes 4) Add Subject-specific prefixes 5) Add sidecars","title":"Description"},{"location":"Functions/#xasl_init_initializemutexm","text":"","title":"xASL_init_InitializeMutex.m"},{"location":"Functions/#format_97","text":"[x] = xASL_init_InitializeMutex(x, ModuleName)","title":"Format"},{"location":"Functions/#description_97","text":"This function initializes the mutex/lock system of ExploreASL for a module. Mutex (for mutual exclusion) is a synchronization mechanism for enforcing limits of access to data (here a module for a single scan) to allow parallelization. It also allows stopping and continuing of ExploreASL. This function runs the following steps: 1) Lock folder management 2) Initialize mutex object","title":"Description"},{"location":"Functions/#xasl_init_loadmetadatam","text":"","title":"xASL_init_LoadMetadata.m"},{"location":"Functions/#format_98","text":"[x] = xASL_init_LoadMetadata(x)","title":"Format"},{"location":"Functions/#description_98","text":"This function loads all metadata used in the study, either statistical covariates (age, MMSE) or groups to compare between (site, sequence, cohort), or parameters to be used in quantification/image processing These parameters should be provided in .mat files in the root analysis folder. Each .mat file should contain a single type of metadata, and the filename should equal the variable name. Metadata content should be a cell array with subjects as first column and metadata as last column. Sessions (runs) can be included as second column. Metadata can be in any string or numerical format. participants.tsv is now added per BIDS. It looks for metadata in participants.tsv first, before going through the mat-files This function iterates through the following steps for each variable: 1) Admin (what nOptions do we call ordinal, convert subject numeric to string, remove white spaces from data) 2) Get unique list of data options & check for missing data 3) Deal with data format (correct NaNs, deal with numeric vs strings) 4) Distinguish continous data (e.g. age) or ordinal data (groups to compare, e.g. cohort) 5) Check if data is complete for all subjects 6) Include complete data in x.S.SETS","title":"Description"},{"location":"Functions/#xasl_init_longitudinalregistrationm","text":"","title":"xASL_init_LongitudinalRegistration.m"},{"location":"Functions/#format_99","text":"[SubjectNlist, TimePoint, IsSubject, SubjectID_FirstVolume] = xASL_init_LongitudinalRegistration(x)","title":"Format"},{"location":"Functions/#description_99","text":"This function initializes the longitudinal registration for ExploreASL, which implements the SPM longitudinal registration. This function recognizes and defines visits (i.e. multiple scans per subject) in the initialization of ExploreASL, based on the suffixes _1 _2 _n in the subject names (identified as foldernames). Specifically, this function is called in the registration modules LongReg and DARTEL, the first carrying out within-subject registration and the second between-subject registration, based on the first time point only. For the first function, we specify here a list of visits/timepoints that should be registered longitudinally, for the second function we specify a list of first visits only, as the between-subject registration in ExploreASL is based on the first scan (as opposed to the average subject's scan). This function runs the following steps: 1) Get TimePoint-list (list of visits) 2) Find subject IDs","title":"Description"},{"location":"Functions/#xasl_init_visualizationsettingsm","text":"","title":"xASL_init_VisualizationSettings.m"},{"location":"Functions/#format_100","text":"[x] = xASL_init_VisualizationSettings(x)","title":"Format"},{"location":"Functions/#description_100","text":"This function defines several visualization settings are used throughout ExploreASL's pipeline and tools, assuming a [121 145 121] matrix with 1.5 mm isotropic resolution in MNI space.","title":"Description"},{"location":"Functions/#input-and-output","text":"","title":"Input and Output"},{"location":"Functions/#xasl_io_createniftim","text":"","title":"xASL_io_CreateNifti.m"},{"location":"Functions/#format_101","text":"xASL_io_CreateNifti(pathNewNifti, imNew, resMat, nBits, bGZip)","title":"Format"},{"location":"Functions/#description_101","text":"This function creates a new NIfTI file, using the SPM \"nifti\" functionality, with the parameters specified as input arguments. This function performs the following steps: 1) Initialize NIfTI 2) Choose datatype (bit resolution) 3) Create scale slopes 4) Create orientation matrix 5) Write the new NIfTI, image matrix & scale slopes 6) Zip and deal with zipping (.nii vs. .nii.gz)","title":"Description"},{"location":"Functions/#xasl_io_dcmtkreadm","text":"","title":"xASL_io_DcmtkRead.m"},{"location":"Functions/#format_102","text":"header = xASL_io_DcmtkRead(filepath, bPixel)","title":"Format"},{"location":"Functions/#description_102","text":"SHORT Reads DICOM headers using DCMTK FORMAT: header = xASL_io_DcmtkRead(filepath, bPixel) INPUT: filepath (string) - full path to the DICOM file bPixel (bool) - read pixel data, default 0 OUTPUT: header (structure) - structure containing parsed DICOM header Calls the MEX function that uses DCMTK library to read the DICOM header. To change which parameters are read and their names - the MEX file needs to be edited. This function also corrects formating of certain parameters.","title":"Description"},{"location":"Functions/#xasl_io_makenifti4dicomm","text":"","title":"xASL_io_MakeNifti4DICOM.m"},{"location":"Functions/#format_103","text":"xASL_io_MakeNifti4DICOM(PathIn, x)","title":"Format"},{"location":"Functions/#description_103","text":"This function converts a NIfTI file to one that is ready to convert to DICOM for PACS visualization purposes: For scaling/visualization: 1) Remove peak signal 2) Remove valley signal 3) Remove NaNs 4) Rescale to 12 bit integers 5) Save NIfTI. We also zip the NIfTI as this NIfTI won't be opened by ExploreASL 6) Manage scale slope/datatype 7) Apply original orientation 8) Zip NIfTI","title":"Description"},{"location":"Functions/#xasl_io_pairwisesubtractionm","text":"","title":"xASL_io_PairwiseSubtraction.m"},{"location":"Functions/#format_104","text":"xASL_io_PairwiseSubtraction(InputFile,outputPath,do_mask,switch_sign)","title":"Format"},{"location":"Functions/#description_104","text":"Subtracts controls from labels and takes mean. Creates new perfusion-weighted delta_M file, prefaced with 's'. Converts into single precision floating point values (32 bit), removes scale slope. Only runs if ['s' input_file_ASL] doesn't exist. Remember to consider motion correction/ SPM realign (isotropically). Alternative to this function is robust fit (Camille Maumet).","title":"Description"},{"location":"Functions/#xasl_io_readthedicomm","text":"","title":"xASL_io_ReadTheDicom.m"},{"location":"Functions/#format_105","text":"[Info] = xASL_io_ReadTheDicom(bUseDCMTK, DicomPath)","title":"Format"},{"location":"Functions/#description_105","text":"This function tries to read a DICOM and throws a warning if it fails to","title":"Description"},{"location":"Functions/#xasl_io_splitasl_m0m","text":"","title":"xASL_io_SplitASL_M0.m"},{"location":"Functions/#format_106","text":"xASL_io_SplitASL_M0(InPath,iM0)","title":"Format"},{"location":"Functions/#description_106","text":"This function splits ASL4D & M0 if they were in the same sequence. If dcm2niiX has already splitted the ASL4D NIfTI, this is reconstructed first. If no M0 exists, or only ASL splitting is desired, leave iM0 empty ([]) Vendor product sequence examples: GE 3D spiral sometimes puts the M0 at the last volume of the series -> iM0 = [2]; Philips 3D GRASE puts the M0 as control-label volume pair -> iM0 = [1 2]; Siemens 3D GRASE puts the M0 as the first volume -> iM0 = 1;","title":"Description"},{"location":"Functions/#xasl_io_dcm2niim","text":"","title":"xASL_io_dcm2nii.m"},{"location":"Functions/#format_107","text":"[niifiles, ScanNameOut, usedinput, msg] = xASL_io_dcm2nii(inpath, destdir, series_name, varargin)","title":"Format"},{"location":"Functions/#description_107","text":"Convert DICOM NIfTI/BIDS format using the dcm2nii command line utility.","title":"Description"},{"location":"Functions/#xasl_num2strm","text":"","title":"xASL_num2str.m"},{"location":"Functions/#format_108","text":"[DataOut] = xASL_num2str(DataIn[, f])","title":"Format"},{"location":"Functions/#description_108","text":"when the provided data is numeric, this function will convert the number to string/characters, rewriting NaN into 'n/a' (BIDS convention) but otherwise preserving the Matlab builtin functionality, also for the second argument \"f\". If non-numeric data is provided, it is bypassed (avoiding any issues \"num2str\" will have with non-numeric data). See builtin num2str for more details","title":"Description"},{"location":"Functions/#qc","text":"","title":"QC"},{"location":"Functions/#xasl_qc_asymmetryindexm","text":"","title":"xASL_qc_AsymmetryIndex.m"},{"location":"Functions/#format_109","text":"[AI_perc] = xASL_qc_AsymmetryIndex(ImageIn)","title":"Format"},{"location":"Functions/#description_109","text":"Extract voxel-wise asymmetry index for QC purposes.","title":"Description"},{"location":"Functions/#xasl_qc_cat12_iqrm","text":"","title":"xASL_qc_CAT12_IQR.m"},{"location":"Functions/#format_110","text":"[QA_Output] = xASL_qc_CAT12_IQR(InputImage, InputC1, InputC2, InputC3, bFLAIR)","title":"Format"},{"location":"Functions/#description_110","text":"...","title":"Description"},{"location":"Functions/#xasl_qc_collectparametersm","text":"","title":"xASL_qc_CollectParameters.m"},{"location":"Functions/#format_111","text":"x = xASL_qc_CollectParameters(x, iSubject, ScanType, CollectQCFunction)","title":"Format"},{"location":"Functions/#description_111","text":"This function collects QC parameters for a module","title":"Description"},{"location":"Functions/#xasl_qc_collectqc_aslm","text":"","title":"xASL_qc_CollectQC_ASL.m"},{"location":"Functions/#format_112","text":"[x] = xASL_qc_CollectQC_ASL(x, iSubject)","title":"Format"},{"location":"Functions/#description_112","text":"This functions collects QC parameters for the ASL module These are stored in x.Output.ASL: ID - SubjectName ASL_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 SPM realign (too much motion is suspicious) MotionMean_mm - mean motion MotionExcl_Perc - percentage of excluded outliers MotionMax_mm - max motion MotionSD_mm - SD motion ASL quantification (strange average CBF, or strange GM-WM contrast) ASL acquisition parameters (should be fairly consistent over subjects/scans): TE - echo time TR - repetition time RescaleSlope - Philips Scaleslope - Philips Matrix X Y Z - matrix size Matrix Z - number of slices VoxelSize X Y - in plane resolution VoxelSize Z - slice thickness RigidBody2Anat_mm - Net Displacement Vector (RMS) from ASL to T1w image (mm) from registration","title":"Description"},{"location":"Functions/#xasl_qc_collectqc_structuralm","text":"","title":"xASL_qc_CollectQC_Structural.m"},{"location":"Functions/#format_113","text":"[x] = xASL_qc_CollectQC_Structural(x, iSubject)","title":"Format"},{"location":"Functions/#description_113","text":"This functions collects QC parameters for the structural module These are stored in x.Output.Structural: ID - SubjectName T1w_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 LST output: WMH_vol_mL - WMH volume WMH_n - WMH number of lesions CAT12 output: T1w_IQR_Perc - CAT12 IQR quality parameter for T1w volumetric: GM_vol_mL, WM_vol_mL, CSF_vol_mL, ICV_vol_mL, GM_ICV_Ratio","title":"Description"},{"location":"Functions/#xasl_qc_collectqc_funcm","text":"","title":"xASL_qc_CollectQC_func.m"},{"location":"Functions/#format_114","text":"[x] = xASL_qc_CollectQC_func(x, iSubject)","title":"Format"},{"location":"Functions/#description_114","text":"This functions collects QC parameters for the func module These are stored in x.Output.func: ID - SubjectName func_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 SPM realign (too much motion is suspicious) MotionMean_mm - mean motion MotionExcl_Perc - percentage of excluded outliers MotionMax_mm - max motion MotionSD_mm - SD motion func quantification (strange average CBF, or strange GM-WM contrast) CBF_GM_Median_mL100gmin - median GM CBF CBF_WM_Median_mL100gmin - median WM CBF SpatialCoV_GM_Perc - GM spatial CoV SpatialCoV_WM_Perc - WM spatial CoV CBF_GM_WM_Ratio - GM-WM CBF ratio func acquisition parameters (should be fairly consistent over subjects/scans): TE - echo time TR - repetition time RescaleSlope - Philips Scaleslope - Philips Matrix X Y Z - matrix size Matrix Z - number of slices VoxelSize X Y - in plane resolution VoxelSize Z - slice thickness RigidBody2Anat_mm - Net Displacement Vector (RMS) from func to T1w image (mm) from registration","title":"Description"},{"location":"Functions/#xasl_qc_collectsoftwareversionsm","text":"","title":"xASL_qc_CollectSoftwareVersions.m"},{"location":"Functions/#format_115","text":"[x] = xASL_qc_CollectSoftwareVersions(x)","title":"Format"},{"location":"Functions/#description_115","text":"This functions collects software versions for matlab, SPM, CAT, LST & ExploreASL These are stored in x.Output.Software","title":"Description"},{"location":"Functions/#xasl_qc_comparetemplatem","text":"","title":"xASL_qc_CompareTemplate.m"},{"location":"Functions/#format_116","text":"[QC] = xASL_qc_CompareTemplate(x, ModPrefix, iSubjectSession)","title":"Format"},{"location":"Functions/#description_116","text":"This function computes several advanced template-based QC parameters: RMSE_Perc - Root Mean Square Error between image and template (%) nRMSE_Perc - Same but then normalized AI_Perc - Asymmetry Index between image and template (%) Mean_SSIM_Perc - mean structural similarity index -> xASL_stat_MeanSSIM.m PeakSNR_Ratio - peak signal-to-noise ratio -> xASL_stat_PSNR.m","title":"Description"},{"location":"Functions/#xasl_qc_computefovcoveragem","text":"","title":"xASL_qc_ComputeFoVCoverage.m"},{"location":"Functions/#format_117","text":"[CoveragePerc] = xASL_qc_ComputeFoVCoverage(InputPath, x)","title":"Format"},{"location":"Functions/#description_117","text":"This function computes the intersection/overlap between brainmask on field-of-view (FoV) of low resolution image (native space) & the same brainmask with expanded FoV. It uses the pGM+pWM+pCSF as brainmask This assumes that the structural reference image has full brain coverage, and was properly segmented into GM, WM and CSF Also, we assume that the InputPath contains a single 3D volume","title":"Description"},{"location":"Functions/#xasl_qc_computeniftiorientationm","text":"","title":"xASL_qc_ComputeNiftiOrientation.m"},{"location":"Functions/#format_118","text":"[Struct] = xASL_qc_ComputeNiftiOrientation(x, PathNIfTI, Struct)","title":"Format"},{"location":"Functions/#description_118","text":"...","title":"Description"},{"location":"Functions/#xasl_qc_createpdfm","text":"","title":"xASL_qc_CreatePDF.m"},{"location":"Functions/#format_119","text":"xASL_qc_CreatePDF(x[, DoSubject])","title":"Format"},{"location":"Functions/#description_119","text":"This function iterates over all values in x.Output and all images in x.Output_im, and prints them in a PDF file. x.Output & x.Output_im should contain the QC/result output of all ExploreASL pipeline steps. Further code explanation: Below, using the Matlab & SPM Figure tools we create an image, which is then printed to a PDF file fg = the main Figure handle ax = \"axes\" handles, these are objects containing either 1) text or 2) images, with fg as \"parent\" (1) & (2) images have ax as \"parent\" Positions are calculated in such a way that 4 categories can be printed, which will be the first 4 fields found in x.Output then allowing 8 single slice images, and 15 text lines (name & value columns)","title":"Description"},{"location":"Functions/#xasl_qc_fa_outliersm","text":"","title":"xASL_qc_FA_Outliers.m"},{"location":"Functions/#format_120","text":"[FA_Outliers_mL] = xASL_qc_FA_Outliers(InputFA)","title":"Format"},{"location":"Functions/#description_120","text":"Extract the number of FA outliers, i.e. values of FA above 1 or below 0, from a FA image.","title":"Description"},{"location":"Functions/#xasl_qc_obtainqccategoriesfromjpgm","text":"","title":"xASL_qc_ObtainQCCategoriesFromJPG.m"},{"location":"Functions/#format_121","text":"xASL_qc_ObtainQCCategoriesFromJPG(x)","title":"Format"},{"location":"Functions/#description_121","text":"This function obtains QC categories as covariant/set, based on the JPGs in //Population/ASLCheck. These are initially sorted by spatial CoV, and should be visually checked & put in the correct folder.","title":"Description"},{"location":"Functions/#xasl_qc_pcpstructuralm","text":"","title":"xASL_qc_PCPStructural.m"},{"location":"Functions/#format_122","text":"[anatQA] = xASL_qc_PCPStructural(PathT1, Pathc1T1, Pathc2T1, x, PopPathT1)","title":"Format"},{"location":"Functions/#description_122","text":"This function computes several anatomical QC parameters as proposed in SPM Univariate Plus: WM_ref_vol_mL - volume of the WM reference region (mL) WMref_vol_Perc - same but as percentage of total WM volume SNR_GM - GM signal-to-Noise Ratio (SNR), ie the mean intensity within GM divided by SD of WM reference region. Higher = better. CNR_GM_WM - GM-WM Contrast-to-Noise Ratio (CNR), i.e. the mean of GM - mean of WM divided by the SD of the WM reference region. Higher = better. FBER_WMref_Ratio - Foreground to Background Energy Ratio (FBER), i.e. the variance of voxels within the brain (in pGM+pWM mask) divided by the variance of voxels in the WM reference region. Higher = better. EFC_bits - Shannon Entropy Focus Criterion (EFC), i.e. the entropy of voxel intensities proportional to the maximum possibly entropy for a similarly sized image. Indicates ghosting and head motion-induced blurring. Lower = better. Mean_AI_Perc - mean relative voxel-wise absolute Asymmetry Index (AI) within the brain (pGM+pWM mask) (%) SD - same but SD (%) REFERENCES: Preprocessed Connectome Project Quality Assurance Protocol (QAP): http://preprocessed-connectomes-project.org/quality-assessment-protocol/ http://ieeexplore.ieee.org/document/650886/","title":"Description"},{"location":"Functions/#xasl_qc_printorientationm","text":"","title":"xASL_qc_PrintOrientation.m"},{"location":"Functions/#format_123","text":"xASL_qc_PrintOrientation(DIR, reg_exp_INPUT,OUTPUT_DIR,Name);","title":"Format"},{"location":"Functions/#description_123","text":"Check orientation of niftis, useful to detect accidental left-right flips (all other flips will be visible). translations, rotations or shears are not to be worried about, only negative zooms. This can be detected by negative determinants. So orientation parameters and determinants should be similar across all scans from single scanner/coil, and registration should not give negative determinant.","title":"Description"},{"location":"Functions/#xasl_qc_tanimotocoeffm","text":"","title":"xASL_qc_TanimotoCoeff.m"},{"location":"Functions/#format_124","text":"TC = xASL_qc_TanimotoCoeff(Image1, Image2[, imMask, type])","title":"Format"},{"location":"Functions/#description_124","text":"Compares images Image1 and Image2 within the mask imMask. TYPE specifies the input data type. RATIONALE: Note that the Tanimoto Coefficient is a measure of image overlap/intersection, similar to the Dice coefficient. With the option type 3, this is a fuzzy coefficient, which doesn't require to convert the two images to a binary mask. The TC can be interpreted as a stringent Kappa, ranging from 0 (completely dissimilar) to 100% (identical images). Assuming that perfect registration should not lead to identical images but still retain physiological differences, TC>70% can be regarded as excellent image agreement. The TC will be overestimated when smoothing, but this may lead to more stable artifact detection.","title":"Description"},{"location":"Functions/#xasl_qc_wadqcdcm","text":"","title":"xASL_qc_WADQCDC.m"},{"location":"Functions/#format_125","text":"xASL_qc_WADQCDC(x, iSubject[, ScanType])","title":"Format"},{"location":"Functions/#description_125","text":"This QC function runs WAD-QC specific Python script to zip QC information & incorporate this into a DICOM field for analysis on the WAD-QC server, by the following: Define QCDC script: this is the Python script written by Gaspare, edited by Joost Kuijer & copied to the EPAD CustomScripts folder of ExploreASL Python installation location is checked, with several known locations, for several servers. If we cannot find it, the QCDC is not ran Previous QCDC results are cleaned. QCDC stores all its results in a separate folder (Something like 2 layers up from the current folder, here referred to as QCDCDir = [x.D.ROOT 'qcdc_output']) from these result files, only the filled DICOM file is interesting, all the rest are copies of the QC results that we embedded into the DICOM Run QCDC (if Python installation detected) The following files need to be set as executable: ('QCDC', 'src', 'qc_data_collector.py') ('QCDC', 'src', 'bash', 'create_dcm_only_wadqc.sh') ('QCDC', 'src', 'bash', 'sendwadqc.sh') Clean up new QCDC results (as above) & move the filled DICOM to ['qcdc_' DummyFile] within the current ScanType folder Sending the DICOM to the WAD-QC server using storescu","title":"Description"},{"location":"Functions/#xasl_qc_wadqc_generatedescriptorm","text":"","title":"xASL_qc_WADQC_GenerateDescriptor.m"},{"location":"Functions/#format_126","text":"xASL_qc_WADQC_GenerateDescriptor(x, iSubject)","title":"Format"},{"location":"Functions/#description_126","text":"This QC function generates a JSON descriptor for Gaspare' QCDC script, by the following steps: a) include information about where to find the dummy DICOM (i.e. placeholder DICOM) b) For ExploreASL' QC fields (as passed through in x.Output), here we note all these QC fields for each ScanType, as the x.Output should have been collected equally in the QC file 'QC_collection_SubjectName.json' by function xASL_qc_CollectParameters c) Subfunction xASL_qc_WADQC_images - Includes visual standard space QC images, by searching them on prescribed paths within the Population folder (where currently all derivatives reside) d) Insert the PDF report; this PDF report is subject-specific, not scan-specific. For completeness it is added to each QCDC descriptor e) Add WAD-QC server details (i.e. IP address etc) f) Save the Descriptor JSON file.","title":"Description"},{"location":"Functions/#xasl_qc_temporalsnrm","text":"","title":"xASL_qc_temporalSNR.m"},{"location":"Functions/#format_127","text":"tSNR = xASL_qc_temporalSNR(pathIm4D,pathImTissueProb)","title":"Format"},{"location":"Functions/#description_127","text":"This function computes several temporal SNR QC parameters as proposed in SPM Univariate Plus: tSNR.tSNR_GM_Ratio : mean GM signal / std GM over time tSNR.tSNR.tSNR_WM_Ratio : mean WM signal / std WM over time tSNR.tSNR.tSNR_CSF_Ratio: mean CSF signal / std CSF over time tSNR.tSNR_WMref_Ratio : mean signal/std over time in eroded deep WM tSNR.tSNR_GMWM_Ratio : mean (GM+WM) signal / sqrt(std(GM+WM)^2+std(WMref)^2) tSNR.tSNR_GMWM_WMref_Ratio: mean (GM+WM) signal / std WMref over time tSNR.tSNR_Physio2Thermal_Ratio: sqrt((tSNR(GM+WM)/tSNR_GMWM_WMref_Ratio))^2-1) tSNR.tSNR_Slope_Corr: Differences to the SPM U+ suggestion: - eroded WM is used for estimating background noise - Brainmask is determined in the same way as the structural anatQC, - CSF is determined from the pGM&pWM maps; REFERENCES: 1) Thomas Liu (2016). Noise contributions to the fMRI signal: An overview NeuroImage, 343, 141-151 http://dx.doi.org/10.1016/j.neuroimage.2016.09.008 2) Cesar Caballero-Gaudes and Richard C. Reynolds (2016). Methods For Cleaning The BOLD fMRI Signal. NeuroImage, 154,128-149 3) Lawrence Wald and Jonathan R Polimeni (2016). Impacting the effect of fMRI noise through hardware and acquisition choices ??? Implications for controlling false positive rates. NeuroImage, 154,15-22 4) SPM Utility + toolbox. Cyril Pernet. https://osf.io/wn3h8/","title":"Description"},{"location":"Functions/#quantization","text":"","title":"Quantization"},{"location":"Functions/#xasl_quant_agesex2hctm","text":"","title":"xASL_quant_AgeSex2Hct.m"},{"location":"Functions/#format_128","text":"[Hematocrit] = xASL_quant_AgeSex2Hct([age, sex])","title":"Format"},{"location":"Functions/#description_128","text":"This function estimates a participants hematocrit, based on literature-based values for age and sex. It performs the following steps: Warning unknown age/sex Imputing unknown age/sex Define hematocrit per age for unknown sex Define Hematocrit per age for males Define Hematocrit per age for females","title":"Description"},{"location":"Functions/#xasl_quant_feastm","text":"","title":"xASL_quant_FEAST.m"},{"location":"Functions/#format_129","text":"xASL_quant_FEAST(x)","title":"Format"},{"location":"Functions/#description_129","text":"This function quantifies ATT using the FEAST equations, using crushed and non-crushed sessions, of which the ratio is proportional to ATT. Note that the order of sessions should be 1) crushed 2) non-crushed This function runs the following steps: 1. Skip this function if no FEAST data available 2. Admin 3. Load data & correct for timing differences (PLD etc) 4. Smooth and clip CBF maps & FEAST ratio 5. Compute TT maps","title":"Description"},{"location":"Functions/#xasl_quant_getcontrollabelorderm","text":"","title":"xASL_quant_GetControlLabelOrder.m"},{"location":"Functions/#format_130","text":"[ControlIM, LabelIM, OrderContLabl] = xASL_quant_GetControlLabelOrder(FramesIn, x)","title":"Format"},{"location":"Functions/#description_130","text":"This function automatically checks (and corrects if required) the control and label order of ASL timeseries based on the larger signal in control volumes. It supposes that data is acquired in pairs.","title":"Description"},{"location":"Functions/#xasl_quant_hct2bloodt1m","text":"","title":"xASL_quant_Hct2BloodT1.m"},{"location":"Functions/#format_131","text":"BloodT1 = xASL_quant_Hct2BloodT1(Hematocrit, Y, B0, bVerbose)","title":"Format"},{"location":"Functions/#description_131","text":"This function converts hematocrit to blood T1, according to calculations defined by Patrick Hales. With courtesy and thanks! Note that we assume a venous O2 saturation of 68% (Yv=0.68) This function performs the following steps: 1) Check fraction vs percentage hematocrit & Y, should be between 0 and 1 2) Specify defaults (Hb, Fe) 3) Perform calculation 4) Convert s to ms 5) Print what we did","title":"Description"},{"location":"Functions/#xasl_quant_m0m","text":"","title":"xASL_quant_M0.m"},{"location":"Functions/#format_132","text":"[M0IM] = xASL_quant_M0(M0IM, x)","title":"Format"},{"location":"Functions/#description_132","text":"This function quantifies the M0, except for the difference in voxel size between the M0 and ASL source data (which is scaled in xASL_wrp_ProcessM0.m). This function runs the following steps: Correct scale slopes, if Philips Skip M0 quantification if ~x.ApplyQuantification(4) Set TR specifically for GE Check for correct TR values Quantify the M0, either for single 3D volume or slice-wise Apply custom scalefactor if requested (x.M0_GMScaleFactor)","title":"Description"},{"location":"Functions/#xasl_quant_singlepldm","text":"","title":"xASL_quant_SinglePLD.m"},{"location":"Functions/#format_133","text":"[ScaleImage[, CBF]] = xASL_quant_SinglePLD(PWI, M0_im, SliceGradient, x)","title":"Format"},{"location":"Functions/#description_133","text":"This script performs a multi-step quantification, by initializing a ScaleImage that travels through this script & gets changed by the following quantification factors: 1) PLD scalefactor (gradient if 2D multi-slice) (if x.ApplyQuantification(3)) 2) Label decay scale factor for single (blood T1) - or dual-compartment (blood+tissue T1) model, CASL or PASL Single-compartment model: Alsop MRM 2014 Dual-compartment model: Wang MRM 2002: Gevers JMRI 2012 (if x.ApplyQuantification(3)) 3) Scaling to physiological units [ml/gr/ms =>ml/100gr/min =>(60,000 ms=>min)(1 gr=>100gr)] (if x.ApplyQuantification(3)) 4) Vendor-specific scalefactor (if x.ApplyQuantification(1) -> future move to dcm2niiX stage) Finally, we: 5) Divide PWI/M0 (if x.ApplyQuantification(5)) 6) Print parameters used Note that the output always goes to the CBF image (in the future this could go to different stages, e.g. dcm2niiX or PWI stage)","title":"Description"},{"location":"Functions/#spm","text":"","title":"SPM"},{"location":"Functions/#xasl_spm_biasfieldcorrectionm","text":"","title":"xASL_spm_BiasfieldCorrection.m"},{"location":"Functions/#format_134","text":"xASL_spm_BiasfieldCorrection(PathIn, SPMdir, Quality, MaskName, PathOut)","title":"Format"},{"location":"Functions/#description_134","text":"This function is a wrapper around the SPM \"old segment\" function, for biasfield removal. It is tested for M0 and mean control images. It conducts the following steps: 1) Create implicit mask 2) Define SPM 'old segmentation' settings 3) Run SPM 'old segmentation' 4) Delete temporary files 5) Rename temporary SPM file into output file","title":"Description"},{"location":"Functions/#xasl_spm_affinem","text":"","title":"xASL_spm_affine.m"},{"location":"Functions/#format_135","text":"xASL_spm_affine(srcPath, refPath, fwhmSrc, fwhmRef[,otherList, bDCT])","title":"Format"},{"location":"Functions/#description_135","text":"This SPM wrapper runs SPM's old normalize-estimate function, which calculates the affine transformation (i.e. linear + zooming and shearing) that is required to align the source image with the reference image. By default it does not estimate the low-degree Discrete Cosine Transform (DCT) to have a simple affine transformation but this can be enabled in this wrapper. Also note that this affine transformation uses a correlation cost function, hence it requires the source and reference images to have similar contrasts and resolution - or provide the resolution estimates so the smoothing can be done. This function does not change the orientation header by default, but it allows to change those of others through the otherList. If bDCT is used or no otherList given, it stores its estimated affine transformation as orientation difference matrix in a file with the same path but _sn.mat extension. For the provided smoothing FWHM, note that smoothnesses combine with Pythagoras' rule (i.e. square summing).","title":"Description"},{"location":"Functions/#xasl_spm_coregm","text":"","title":"xASL_spm_coreg.m"},{"location":"Functions/#format_136","text":"xASL_spm_coreg(refPath, srcPath[, OtherList, x, sep, FastReg])","title":"Format"},{"location":"Functions/#description_136","text":"This SPM wrapper runs SPMs coregister-estimate function, which calculates the 6 parameter rigid-body transformation (a.k.a. linear) that is required to align the source image with the reference image. This 6 parameter transformation (i.e. 3 XYZ translations and 3 rotations) is applied to the orientation header of the source NIfTI image, and also to the images provided in OtherList (optional). Note that this SPM registration function uses a normalized mutual information (NMI) by default, enabling registration between two images with different contrast. Note that this algorithm will use the first volume of a multi-volume NIfTI","title":"Description"},{"location":"Functions/#xasl_spm_defacem","text":"","title":"xASL_spm_deface.m"},{"location":"Functions/#format_137","text":"xASL_spm_deface(PathIn, bReplace)","title":"Format"},{"location":"Functions/#description_137","text":"This function removes the face from an anatomical NIfTI image, e.g. T1w or FLAIR, for disidentification/privacy purposes. When this script is run after the ExploreASL structural module, it does a pretty good job even for 2D images. However, note that this can always fail, strip part of the brain, or change the output of pipelines. So best not to compare results from defaced and non-defaced images. Also, note that defacing makes it difficult to ensure that the FLAIR and T1w are from the same subject.","title":"Description"},{"location":"Functions/#xasl_spm_deformationsm","text":"","title":"xASL_spm_deformations.m"},{"location":"Functions/#format_138","text":"xASL_spm_deformations([x,] PathIn, PathOut[, Interpolation, InverseSpace, AffineTrans, DeformationPath])","title":"Format"},{"location":"Functions/#description_138","text":"This ExploreASL wrapper manages the SPM deformation tool. It takes multiple (ExploreASL pipeline) transformations and combines/concatenates them into a single transformation prior to applying it to the input images. This allows to apply multiple transformations with a single interpolation, avoiding propagation of undesired interpolation effects. Mainly used to get native space images into standard space, or vice versa. Best to combine as many files as possible within this function, since the deformation calculation (which is the most computation intensive part) needs to be performed once for multi-file resampling","title":"Description"},{"location":"Functions/#statistics","text":"","title":"Statistics"},{"location":"Functions/#xasl_stat_atlasforstatsm","text":"","title":"xASL_stat_AtlasForStats.m"},{"location":"Functions/#format_139","text":"[x] = xASL_stat_AtlasForStats(x)","title":"Format"},{"location":"Functions/#description_139","text":"This function loads atlases, checks them, and their ROI names, for later use as ROI definition in xASL_stat_GetROIstatistics Note that the atlases should be integer values, or different 4rd dimensions (i.e. multiple images), that are mutually exclusive. This function takes the following steps: 1) Load atlas ROI names There should be a TSV sidecar to the atlas NIfTI file, as explained above. 2) deal with memory mapping 3) Resample atlas 50 1.5 mm^3 MNI 4) Converted atlas with integers to 4D binary image 5) Convert/compress masks into Columns 6) Print atlas overview image","title":"Description"},{"location":"Functions/#xasl_stat_computediffercovm","text":"","title":"xASL_stat_ComputeDifferCoV.m"},{"location":"Functions/#format_140","text":"diffCoV = xASL_stat_ComputeDifferCoV(imCBF) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask,bPVC,imGM,imWM) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask,bPVC,imGM,imWM,b3D)","title":"Format"},{"location":"Functions/#description_140","text":"It calculates the spatial DiffCoV value on finite part of imCBF. Optionally a mask IMMASK is provide, and PVC is done for bPVC==2 using imGM and imWM masks and constructing pseudoCoV from pseudoCBF image. For bPVC~=2, imGM and imWM are ignored. It is calculated in 2D or assuming also 3D edges based on B3D. Calculate derivate spatial CoV, by summing up differences in CBF between neighbors. The derivative uses Sobels filter.","title":"Description"},{"location":"Functions/#xasl_stat_computemeanm","text":"","title":"xASL_stat_ComputeMean.m"},{"location":"Functions/#format_141","text":"[CBF_GM CBF_WM] = xASL_stat_ComputeMean(imCBF [,imMask,nMinSize,bPVC,imGM,imWM])","title":"Format"},{"location":"Functions/#description_141","text":"It behaves in a similar way as VAR.","title":"Description"},{"location":"Functions/#xasl_stat_computespatialcovm","text":"","title":"xASL_stat_ComputeSpatialCoV.m"},{"location":"Functions/#format_142","text":"sCov = xASL_stat_ComputeSpatialCoV(imCBF) sCov = xASL_stat_ComputeSpatialCoV(imCBF,imMask) sCov = xASL_stat_ComputeSpatialCoV(imCBF,imMask,nMinSize) sCov = xASL_stat_ComputeSpatialCoV(imCBF,imMask,nMinSize,bPVC,imGM,imWM)","title":"Format"},{"location":"Functions/#description_142","text":"It calculates the spatial CoV value on finite part of imCBF. Optionally a mask IMMASK is provide, ROIs of size < NMINSIZE are ignored, and PVC is done for bPVC==2 using imGM and imWM masks and constructing pseudoCoV from pseudoCBF image. For bPVC~=2, imGM and imWM are ignored","title":"Description"},{"location":"Functions/#xasl_stat_equalvariancestestm","text":"","title":"xASL_stat_EqualVariancesTest.m"},{"location":"Functions/#format_143","text":"[resTest, P] = xASL_stat_EqualVariancesTest(X[, alpha, type])","title":"Format"},{"location":"Functions/#description_143","text":"Brown-Forsythe or Levene's test for equality of variances. The response variable is transformed (yij = abs(xij - median(xj)) for Brown-Forsythe and yij = abs(xij - mean(xj)) for Levene's test). And then runs a one-way ANOVA F-test to check if the variances are equal.","title":"Description"},{"location":"Functions/#xasl_stat_getroistatisticsm","text":"","title":"xASL_stat_GetROIstatistics.m"},{"location":"Functions/#format_144","text":"[x] = xASL_stat_GetROIstatistics(x)","title":"Format"},{"location":"Functions/#description_144","text":"This function computes mean and spatial CoV for each ROI, in a [1.5 1.5 1.5] mm MNI space, with several ASL-specific adaptions: Skip ROI masks that are smaller than 1 mL as this would be too noisy for ASL (skipped when x.S.IsASL==false) Expand each ROI mask such that it has sufficient WM content (skipped when IsASL==false) Create for each ROI mask a left, right and bilateral copy Iterate over all subjects: a) Load partial volume maps b) Correct for WMH SEGM -> IS THIS STILL REQUIRED??? c) Load data d) Show ROIs projected on ASL image e) Actual data computations Partial Volume Correction (PVC) options: PVC==0 -> perform masking only, no regression PVC==1 -> single compartment regression, for pGM PVC==2 -> dual compartment regression for pGM & pWM (i.e. normal PVC) Here we mask out susceptibility artifacts (including outside FoV) for all ASL computations, and also mask out vascular artifacts for computing the mean. While other artifacts/FoV can be masked out on population level (i.e. >0.95 subjects need to have a valid signal in a certain voxel), vascular artifacts differ too much in their location between subjects, so we mask this on subject-level. Note that the words \"mask\" and \"ROI\" are used interchangeably throughout this function, where they can have a different or the same meaning PM: WE COULD CHANGE THIS, INTO MASK BEING USED TO EXCLUDE VOXELS AND ROI FOR INCLUDING VOXELS","title":"Description"},{"location":"Functions/#xasl_stat_madnanm","text":"","title":"xASL_stat_MadNan.m"},{"location":"Functions/#format_145","text":"y = xASL_stat_MadNan(x[,flag, dim])","title":"Format"},{"location":"Functions/#description_145","text":"Calculates a Median/Mean Absolute deviation, but ignoring NaNs in the calculation. xASL_stat_MadNan(X) or xASL_stat_MadNan(X,0) computes xASL_stat_MeanNan(ABS(X-xASL_stat_MeanNan(X)) xASL_stat_MadNan(X,1) computes xASL_stat_MedianNan(ABS(X-xASL_st_MedianNan(X)).","title":"Description"},{"location":"Functions/#xasl_stat_meanssimm","text":"","title":"xASL_stat_MeanSSIM.m"},{"location":"Functions/#format_146","text":"mssim=xASL_stat_MeanSSIM(imRef,imSrc[,dynRange])","title":"Format"},{"location":"Functions/#description_146","text":"Calculates the similarity index according to Want et al.","title":"Description"},{"location":"Functions/#xasl_stat_multiplelinregm","text":"","title":"xASL_stat_MultipleLinReg.m"},{"location":"Functions/#format_147","text":"[b,CI,pval,stats] = xASL_stat_MultipleLinReg(X,Y[,bIntercept])","title":"Format"},{"location":"Functions/#description_147","text":"Performs a multiple linear regression Y=b*X+a and provides the intercept and regression coefficients beta including their significance and confidence intervals. It calculates additionally the goodness of the fit.","title":"Description"},{"location":"Functions/#xasl_stat_psnrm","text":"","title":"xASL_stat_PSNR.m"},{"location":"Functions/#format_148","text":"PSNR=xASL_stat_PSNR(imRef,imSrc)","title":"Format"},{"location":"Functions/#description_148","text":"Calculates the PSNR, needs two input arguments - 3D images of the same size. Uses 95% percentile instead of MAX.","title":"Description"},{"location":"Functions/#xasl_stat_printstatsm","text":"","title":"xASL_stat_PrintStats.m"},{"location":"Functions/#format_149","text":"[x] = xASL_stat_PrintStats(x)","title":"Format"},{"location":"Functions/#description_149","text":"This function prints an overview of statistics from data that were acquired per ROI, in a TSV file. It starts by printing covariates (called \"Sets\"). Rows will be subjects/sessions, columns will be the sets and ROI-statistics: 1) First remove previous TSV-file, if already existed printing to a TSV file can be tricky if it is opened by Excel. Make sure to close previous versions first, otherwise this part will crash. 2) Print overview of sets to TSV as explained above. Uses subfunction xASL_stat_CreateLegend to put legends. Aim is to create a single TSV file that has a proper overview of the data, & is self-explanatory to those reading/using it. 3) Define number of ASL sessions, force to 1 in case of TT or volume metrics 4) Print the overview","title":"Description"},{"location":"Functions/#xasl_stat_quantilenanm","text":"","title":"xASL_stat_QuantileNan.m"},{"location":"Functions/#format_150","text":"y = xASL_stat_QuantileNan(x[,quant, dim])","title":"Format"},{"location":"Functions/#description_150","text":"Calculates a quantile, but ignoring NaNs in the calculation","title":"Description"},{"location":"Functions/#xasl_stat_robustmeanm","text":"","title":"xASL_stat_RobustMean.m"},{"location":"Functions/#format_151","text":"[NoOutliers, iOutliers, ThresholdDeviation] = xASL_stat_RobustMean(IM, ParameterFunction)","title":"Format"},{"location":"Functions/#description_151","text":"This function detects outlier images, that can be used to create a robust average, e.g. for template or biasfield creation. This is based either on the sum-of-squares with the mean image (SoS), or on the average relative asymmetry index (AI). Images that are median+/-3 mad off are defined as outliers. MAD = median/mean absolute difference","title":"Description"},{"location":"Functions/#xasl_stat_shapirowilkm","text":"","title":"xASL_stat_ShapiroWilk.m"},{"location":"Functions/#format_152","text":"[H, P, W] = xASL_stat_ShapiroWilk(x[, alpha])","title":"Format"},{"location":"Functions/#description_152","text":"Performs the statistical test of normality - null hypothesis is that the sample is from normal distribution with unspecified mean and variance. Based on the sample kurtosis it performs either Shapiro-Wilk (for platykurtic) or Shapiro-Francia test (for leptokurtic).","title":"Description"},{"location":"Functions/#xasl_stat_stdnanm","text":"","title":"xASL_stat_StdNan.m"},{"location":"Functions/#format_153","text":"y = xASL_stat_StdNan(x[,w,dim])","title":"Format"},{"location":"Functions/#description_153","text":"It behaves in a similar way as VAR - it directly passes all arguments to xASL_stat_VarNan.","title":"Description"},{"location":"Functions/#xasl_stat_sumnanm","text":"","title":"xASL_stat_SumNan.m"},{"location":"Functions/#format_154","text":"y = xASL_stat_SumNan(x[,dim])","title":"Format"},{"location":"Functions/#description_154","text":"It uses the function SUM, but it sets all the NaNs to zero before calling it.","title":"Description"},{"location":"Functions/#xasl_stat_varnanm","text":"","title":"xASL_stat_VarNan.m"},{"location":"Functions/#format_155","text":"y = xASL_stat_VarNan(x[,w,dim])","title":"Format"},{"location":"Functions/#description_155","text":"It behaves in a similar way as VAR.","title":"Description"},{"location":"Functions/#xasl_stat_fcdfm","text":"","title":"xASL_stat_fcdf.m"},{"location":"Functions/#format_156","text":"F = xASL_stat_fcdf(F,M,N)","title":"Format"},{"location":"Functions/#description_156","text":"Calculates the cumulative distribution function of the F-distribution for degrees of freedom M,N at value F.","title":"Description"},{"location":"Functions/#xasl_stat_tcdfm","text":"","title":"xASL_stat_tcdf.m"},{"location":"Functions/#format_157","text":"F = xASL_stat_tcdf(T,nu)","title":"Format"},{"location":"Functions/#description_157","text":"Calculates the cumulative distribution function of the Student's t-distribution for degrees of freedom nu at value T.","title":"Description"},{"location":"Functions/#xasl_stat_ticdfm","text":"","title":"xASL_stat_ticdf.m"},{"location":"Functions/#format_158","text":"T = xASL_stat_ticdf(P,nu)","title":"Format"},{"location":"Functions/#description_158","text":"Calculates the inverse of cumulative distribution function of the Student's t-distribution for degrees of freedom nu at value P.","title":"Description"},{"location":"Functions/#xasl_stat_ttestm","text":"","title":"xASL_stat_ttest.m"},{"location":"Functions/#format_159","text":"[H,P,CI,stats] = xASL_stat_ttest(X[,M,alpha,tail,dim])","title":"Format"},{"location":"Functions/#description_159","text":"Performs a t-test that the distribution of the input data X has a mean different from 0 (or from a given mean M, or that the distributions X and Y have different means). A normal distribution of the data with an unknown variance is assumed.","title":"Description"},{"location":"Functions/#xasl_stat_ttest2m","text":"","title":"xASL_stat_ttest2.m"},{"location":"Functions/#format_160","text":"[H,P,CI,stats] = xASL_stat_ttest2(X,Y[,alpha,tail,vartype,dim])","title":"Format"},{"location":"Functions/#description_160","text":"Performs a unpaired t-test that the distribution of the input data X has a mean different from that of Y. A normal distribution of the data with an unknown variance is assumed.","title":"Description"},{"location":"Functions/#xasl_str2numm","text":"","title":"xASL_str2num.m"},{"location":"Functions/#format_161","text":"[DataOut] = xASL_str2num(DataIn)","title":"Format"},{"location":"Functions/#description_161","text":"str2num wrapper, replacing 'n/a' with NaN (BIDS convention) and converting only strings to numbers. Also allows inputting cells.","title":"Description"},{"location":"Functions/#visualization","text":"","title":"Visualization"},{"location":"Functions/#xasl_vis_addim2qcm","text":"","title":"xASL_vis_AddIM2QC.m"},{"location":"Functions/#format_162","text":"[x] = xASL_vis_AddIM2QC(x,parms);","title":"Format"},{"location":"Functions/#description_162","text":"Checks which images already are loaded, and adds new image.","title":"Description"},{"location":"Functions/#xasl_vis_createvisualfigm","text":"","title":"xASL_vis_CreateVisualFig.m"},{"location":"Functions/#format_163","text":"[ImOut, FileName] = xASL_vis_CreateVisualFig(x, ImIn, DirOut, IntScale, NamePrefix, ColorMap, bClip)","title":"Format"},{"location":"Functions/#description_163","text":"This function creates a visualization Figure by merging flexibly rearranging NIfTI slices, input matrix or path, managing colormaps for different merged image layers. Current use is for visual QC figures and overview in papers. Function is structured as: Admin, deal with input arguments Process image layers separately * xASL_im_TransformData2View: Reshapes image data into visualization figure * xASL_im_ClipExtremes: Clips image to given percentile also we scale for peak intensity, we make sure that there is no visible clipping/distortion * Convert to colors, using any input colormaps combine image layers, using input argument IntScale print figure This function assumes that the first image is a grayscale background image (e.g. for transparancy reasons), if there are multiple images","title":"Description"},{"location":"Functions/#xasl_vis_cropparmsacquirem","text":"","title":"xASL_vis_CropParmsAcquire.m"},{"location":"Functions/#format_164","text":"[xmin xmax ymin ymax] = xASL_vis_CropParmsAcquire(temp_image)","title":"Format"},{"location":"Functions/#description_164","text":"Goes from outside to inside to acquire crop settings. Works with grayscale images (2 dimensions per slice). Image position information (2D matrix) should be first 2 dimensions. Could include colordimension later on.","title":"Description"},{"location":"Functions/#xasl_vis_cropparmsapplym","text":"","title":"xASL_vis_CropParmsApply.m"},{"location":"Functions/#format_165","text":"ImageOut = xASL_vis_CropParmsApply(ImageIn,CropParameters)","title":"Format"},{"location":"Functions/#description_165","text":"This function crops 2D image matrices.","title":"Description"},{"location":"Functions/#xasl_vis_imwritem","text":"","title":"xASL_vis_Imwrite.m"},{"location":"Functions/#format_166","text":"[ImOut] = xASL_vis_Imwrite(ImIn, PathOut[, ColorMap, bRescale])","title":"Format"},{"location":"Functions/#description_166","text":"This functions takes an input image matrix, interpolates it to HD resolution (1920x1080) for visibility, and saves the image as jpg. This function avoids the graphic interface of Matlab, for running from CLI Careful: this function overwrites any existing PathOut.","title":"Description"},{"location":"Functions/#xasl_vis_overlapt1_aslm","text":"","title":"xASL_vis_OverlapT1_ASL.m"},{"location":"Functions/#format_167","text":"xASL_vis_OverlapT1_ASL( x, ASL)","title":"Format"},{"location":"Functions/#description_167","text":"Part of ExploreASL. Shows spatial agreement ASL and probability maps.","title":"Description"},{"location":"Functions/#xasl_vis_tileimagesm","text":"","title":"xASL_vis_TileImages.m"},{"location":"Functions/#format_168","text":"...","title":"Format"},{"location":"Functions/#description_168","text":"Merges selected slices (3D) into one single 2D picture. Plots all slices in one figure with specified rows and columns, aiming for a square tile. PM: can be extended to multiple slices","title":"Description"},{"location":"Functions/#xasl_vis_transformdata2viewm","text":"","title":"xASL_vis_TransformData2View.m"},{"location":"Functions/#format_169","text":"FigureOut = xASL_vis_TransformData2View(ImagesIn, x)","title":"Format"},{"location":"Functions/#description_169","text":"This function changes the dimensionality and reshapes the input images in such a way that they are nicely tiled in a mosaic for visualization purposes. Reshaping a series of images with this function can be useful for visualization of SPM/voxel-based analyses.","title":"Description"},{"location":"Functions/#xasl_vis_visualqc_topupm","text":"","title":"xASL_vis_VisualQC_TopUp.m"},{"location":"Functions/#format_170","text":"[MeanAI_PreTopUp_Perc, MeanAI_PostTopUp_Perc] = xASL_vis_VisualQC_TopUp(PathPopB0, PathPopUnwarped, x, iSubject, CheckDir)","title":"Format"},{"location":"Functions/#description_170","text":"This function creates a Figure that showes the effect of TopUp with 6 images with axial slices: the NormPE, RevPE and their difference image in colorscale, and this before (upper row) & after (lower row) TopUp.","title":"Description"},{"location":"Functions/#xasl_vis_visualizeroism","text":"","title":"xASL_vis_VisualizeROIs.m"},{"location":"Functions/#format_171","text":"xASL_vis_VisualizeROIs(x, ROI_T1_list, ROI_FLAIR_list)","title":"Format"},{"location":"Functions/#description_171","text":"Creates for each subject a JPEG image containing the original T1w, WMH_SEGM and T1w after lesion-filling.","title":"Description"},{"location":"Import_Module/","text":"Submodules of the Import Module ExploreASL uses an import workflow based on ...","title":"Module Import"},{"location":"Import_Module/#submodules-of-the-import-module","text":"ExploreASL uses an import workflow based on ...","title":"Submodules of the Import Module"},{"location":"License/","text":"The ExploreASL Software is distributed under the license described below, designed to encourage collabortion while at the same time aiming to reuse commercial profit for academical purpose (e.g. hire an ExploreASL developer). All contents, except for those in the folder //External, are proprietary of ExploreASL. The content in the folder //External is not subject to this license. Provisionary license ExploreASL . This license will be renewed soon after legal checks. ExploreASL , Release 0.999 (c) 2020, Amsterdam University Medical Center (the \"Software\"). The Software remains the property of Amsterdam University Medical Center (AUMC, \"the University\"). The Software is distributed \"AS IS\" under this License solely for non-commercial use in the hope that it will be useful, but in order that the University as a charitable foundation protects its assets for the benefit of its educational and research purposes, the University makes clear that no condition is made or to be implied, nor is any warranty given or to be implied, as to the accuracy of the Software, or that it will be suitable for any particular purpose or for use under any specific conditions. Furthermore, the University disclaims all responsibility for the use which is made of the Software. It further disclaims any liability for the outcomes arising from using the Software. The Licensee agrees to indemnify the University and hold the University harmless from and against any and all claims, damages and liabilities asserted by third parties (including claims for negligence) which arise directly or indirectly from the use of the Software or the sale of any products based on the Software. No part of the Software may be reproduced, modified, transmitted or transferred in any form or by any means, electronic or mechanical, without the express permission of the University. The permission of the University is not required if the said reproduction, modification, transmission or transference is done without financial return, the conditions of this License are imposed upon the receiver of the product, and all original and amended source code is included in any transmitted product. You may be held legally responsible for any copyright infringement that is caused or encouraged by your failure to abide by these terms and conditions. You are not permitted under this License to use this Software commercially. Use for which any financial return is received shall be defined as commercial use, and includes (1) integration of all or part of the source code or the Software into a product for sale or license by or on behalf of Licensee to third parties or (2) use of the Software or any derivative of it for research with the final aim of developing software products for sale or license to a third party or (3) use of the Software or any derivative of it for research with the final aim of developing non-software products for sale or license to a third party, or (4) use of the Software to provide any service to an external organization for which payment is received. If you are interested in collaborating or contributing to this Software, please contact Henk Mutsaerts (h.j.mutsaerts@amsterdamumc.nl). If you are interested in using this Software commercially, please contact Innovation Exchange Amsterdam (\"IXA\"), the technology transfer company of the University, to negotiate a license.","title":"License"},{"location":"Modules/","text":"Modules 1. Module Import Functions function ExploreASL_Import(imPar, bCopySingleDicoms, bUseDCMTK, bCheckPermissions, bRunDCM2NII, bClone2Source, x) Description ... function imPar = ExploreASL_ImportConfig(StudyRoot) Description ... function [x] = ExploreASL_Initialize(DataParPath, ProcessData, iWorker, nWorkers) Description ... 2. Module Structural Function function [result, x] = xASL_module_Structural(x) Description This first ExploreASL module processes the structural images, i.e. high-resolution T1w and FLAIR (if present), on an individual (i.e. subject-to-subject) basis. If a FLAIR is present, this is processed first to obtain a WMH mask to fill the hypointense lesions on the T1w , before segmenting the T1w . For the T1w segmentation this module uses CAT12 by default but if this fails it falls back to SPM after trying to optimize the image contrast. Workflow LinearReg_T1w2MNI : Ensure the alignment of subjects' anterior commissure (AC) with the AC in MNI & apply this to all images LinearReg_FLAIR2T1w : Align the FLAIR (if present) with T1w FLAIR_BiasfieldCorrection : Perform a biasfield correction (if not performed by LST in following steps) LST_Segment_FLAIR_WMH : Segment WMH lesions on FLAIR (if present) LST_T1w_LesionFilling_WMH : Use WMH segmentation to fill lesions on T1w Segment_T1w : Tissue segmentation on T1w CleanUpWMH_SEGM : Extra WMH cleanup of some over- and under-segmentation Resample2StandardSpace : Clone all images to standard space GetVolumetrics : Obtain whole-brain volumes of GM, WM, CSF, WMH VisualQC : Obtain QC parameters & save QC Figures DoWADQCDC : QC for WAD-QC DICOM server (optional) Recommended usage % Initialize dataset DataParPath = \"ExamplePath\"; ProcessData = true; iWorker = 1; nWorkers = 1; x = ExploreASL_Initialize(DataParPath, ProcessData, iWorker, nWorkers); % Run the structural module [~, x] = xASL_Iteration(x,'xASL_module_Structural'); Interface definition Input: x structure Required input fields of the x structure: ... Output Added output fields of the x structure: ... Generated files: ... 3. Module ASL Function function [result, x] = xASL_module_ASL(x) Description This ExploreASL module processes the ASL images, i.e. ASL4D, M0, etc (if present), on an individual (i.e. session-to-session, where session indicates BIDS \"run\") basis. Both 2D and 3D options are automatially chosen, as well as processing of time-series (if available), such as motion correction and outlier exclusion. Workflow TopUpASL : FSL TopUp geometric distortion correction (if M0 images with reversed phase-encoding are present) RealignASL : If time-series are present, motion correction and outlier exclusion (ENABLE) RegisterASL : Registration of ASL to T1w anatomical images (if lacking, to MNI images) ResliceASL : Resample ASL images to standard space PreparePV : Create partial volume images in ASL space with ASL resolution ProcessM0 : M0 image processing Quantification : CBF quantification CreateAnalysisMask : Create mask using FoV, vascular outliers & susceptibility atlas VisualQC_ASL : Generate QC parameters & images WADQC : QC for WAD-QC DICOM server (OPTIONAL) Recommended usage [~, x] = xASL_Iteration(x,'xASL_module_ASL'); Interface definition Input: x structure Required input fields of the x structure: ... Output Added output fields of the x structure: ... Generated files: ... 4. Module Population Function function [result, x] = xASL_module_Population(x) Description This ExploreASL module processes all available images on the group level. It assumes that all images were adequately processed in the previous modules. Workflow CreatePopulationTemplates : Create population average images, to compare scanners, cohorts etc without physiological variance CreateAnalysisMask : Generate a group-level mask by combining individuals masks, for ROI-based analysis & VBA CreateBiasfield : When there are multiple scanners, create scanner-specific biasfields (uses Site.mat for this) GetDICOMStatistics : Create TSV file with overview of DICOM parameters GetVolumeStatistics : Create TSV file with overview of volumetric parameters GetMotionStatistics : Create TSV file with overview of motion parameters GetROIstatistics : Create TSV file with overview of regional values (e.g. qCBF, mean control, pGM etc) SortBySpatialCoV : Sort ASL_Check QC images by their spatial CoV in quality bins DeleteAndZip : Delete temporary files and gzip all NIfTIs Recommended usage [~, x] = xASL_Iteration(x,'xASL_module_Population'); Interface definition Input: x structure Required input fields of the x structure: ... Output Added output fields of the x structure: ... Generated files: ...","title":"Modules"},{"location":"Modules/#modules","text":"","title":"Modules"},{"location":"Modules/#1-module-import","text":"","title":"1. Module Import"},{"location":"Modules/#functions","text":"function ExploreASL_Import(imPar, bCopySingleDicoms, bUseDCMTK, bCheckPermissions, bRunDCM2NII, bClone2Source, x)","title":"Functions"},{"location":"Modules/#description","text":"... function imPar = ExploreASL_ImportConfig(StudyRoot)","title":"Description"},{"location":"Modules/#description_1","text":"... function [x] = ExploreASL_Initialize(DataParPath, ProcessData, iWorker, nWorkers)","title":"Description"},{"location":"Modules/#description_2","text":"...","title":"Description"},{"location":"Modules/#2-module-structural","text":"","title":"2. Module Structural"},{"location":"Modules/#function","text":"function [result, x] = xASL_module_Structural(x)","title":"Function"},{"location":"Modules/#description_3","text":"This first ExploreASL module processes the structural images, i.e. high-resolution T1w and FLAIR (if present), on an individual (i.e. subject-to-subject) basis. If a FLAIR is present, this is processed first to obtain a WMH mask to fill the hypointense lesions on the T1w , before segmenting the T1w . For the T1w segmentation this module uses CAT12 by default but if this fails it falls back to SPM after trying to optimize the image contrast.","title":"Description"},{"location":"Modules/#workflow","text":"LinearReg_T1w2MNI : Ensure the alignment of subjects' anterior commissure (AC) with the AC in MNI & apply this to all images LinearReg_FLAIR2T1w : Align the FLAIR (if present) with T1w FLAIR_BiasfieldCorrection : Perform a biasfield correction (if not performed by LST in following steps) LST_Segment_FLAIR_WMH : Segment WMH lesions on FLAIR (if present) LST_T1w_LesionFilling_WMH : Use WMH segmentation to fill lesions on T1w Segment_T1w : Tissue segmentation on T1w CleanUpWMH_SEGM : Extra WMH cleanup of some over- and under-segmentation Resample2StandardSpace : Clone all images to standard space GetVolumetrics : Obtain whole-brain volumes of GM, WM, CSF, WMH VisualQC : Obtain QC parameters & save QC Figures DoWADQCDC : QC for WAD-QC DICOM server (optional)","title":"Workflow"},{"location":"Modules/#recommended-usage","text":"% Initialize dataset DataParPath = \"ExamplePath\"; ProcessData = true; iWorker = 1; nWorkers = 1; x = ExploreASL_Initialize(DataParPath, ProcessData, iWorker, nWorkers); % Run the structural module [~, x] = xASL_Iteration(x,'xASL_module_Structural');","title":"Recommended usage"},{"location":"Modules/#interface-definition","text":"","title":"Interface definition"},{"location":"Modules/#input-x-structure","text":"Required input fields of the x structure: ...","title":"Input: x structure"},{"location":"Modules/#output","text":"Added output fields of the x structure: ... Generated files: ...","title":"Output"},{"location":"Modules/#3-module-asl","text":"","title":"3. Module ASL"},{"location":"Modules/#function_1","text":"function [result, x] = xASL_module_ASL(x)","title":"Function"},{"location":"Modules/#description_4","text":"This ExploreASL module processes the ASL images, i.e. ASL4D, M0, etc (if present), on an individual (i.e. session-to-session, where session indicates BIDS \"run\") basis. Both 2D and 3D options are automatially chosen, as well as processing of time-series (if available), such as motion correction and outlier exclusion.","title":"Description"},{"location":"Modules/#workflow_1","text":"TopUpASL : FSL TopUp geometric distortion correction (if M0 images with reversed phase-encoding are present) RealignASL : If time-series are present, motion correction and outlier exclusion (ENABLE) RegisterASL : Registration of ASL to T1w anatomical images (if lacking, to MNI images) ResliceASL : Resample ASL images to standard space PreparePV : Create partial volume images in ASL space with ASL resolution ProcessM0 : M0 image processing Quantification : CBF quantification CreateAnalysisMask : Create mask using FoV, vascular outliers & susceptibility atlas VisualQC_ASL : Generate QC parameters & images WADQC : QC for WAD-QC DICOM server (OPTIONAL)","title":"Workflow"},{"location":"Modules/#recommended-usage_1","text":"[~, x] = xASL_Iteration(x,'xASL_module_ASL');","title":"Recommended usage"},{"location":"Modules/#interface-definition_1","text":"","title":"Interface definition"},{"location":"Modules/#input-x-structure_1","text":"Required input fields of the x structure: ...","title":"Input: x structure"},{"location":"Modules/#output_1","text":"Added output fields of the x structure: ... Generated files: ...","title":"Output"},{"location":"Modules/#4-module-population","text":"","title":"4. Module Population"},{"location":"Modules/#function_2","text":"function [result, x] = xASL_module_Population(x)","title":"Function"},{"location":"Modules/#description_5","text":"This ExploreASL module processes all available images on the group level. It assumes that all images were adequately processed in the previous modules.","title":"Description"},{"location":"Modules/#workflow_2","text":"CreatePopulationTemplates : Create population average images, to compare scanners, cohorts etc without physiological variance CreateAnalysisMask : Generate a group-level mask by combining individuals masks, for ROI-based analysis & VBA CreateBiasfield : When there are multiple scanners, create scanner-specific biasfields (uses Site.mat for this) GetDICOMStatistics : Create TSV file with overview of DICOM parameters GetVolumeStatistics : Create TSV file with overview of volumetric parameters GetMotionStatistics : Create TSV file with overview of motion parameters GetROIstatistics : Create TSV file with overview of regional values (e.g. qCBF, mean control, pGM etc) SortBySpatialCoV : Sort ASL_Check QC images by their spatial CoV in quality bins DeleteAndZip : Delete temporary files and gzip all NIfTIs","title":"Workflow"},{"location":"Modules/#recommended-usage_2","text":"[~, x] = xASL_Iteration(x,'xASL_module_Population');","title":"Recommended usage"},{"location":"Modules/#interface-definition_2","text":"","title":"Interface definition"},{"location":"Modules/#input-x-structure_2","text":"Required input fields of the x structure: ...","title":"Input: x structure"},{"location":"Modules/#output_2","text":"Added output fields of the x structure: ... Generated files: ...","title":"Output"},{"location":"Population_Module/","text":"Submodules of the Population Module Delete Many Temp Files Function function xASL_adm_DeleteManyTempFiles(x) Description This function removes as many files as possible. Workflow Recommended usage Interface definition Gzip All Files Function function xASL_adm_GzipAllFiles(ROOT, bFolder, bUseLinux) Description This function zips all .nii files recursively into nii.gz. Note that the linux option cannot deal with spaces in filenames or directories. Workflow Recommended usage Interface definition Create Analysis Mask Function function [x] = xASL_im_CreateAnalysisMask(x, Threshold) Description Creates population analysis mask. Workflow This function takes the mean population-based probability maps of masks, thresholds and combines them: 1. Creation GM, WM & WholeBrain masks by p>0.5 2. Create, combine & save vascular, susceptibity & FoV masks: * MaskVascular * MaskSusceptibility = MaskSusceptibility & MaskFoV 3. Create & save VBA mask * MaskAnalysis = MaskVascular & MaskSusceptibility * x.S.VBAmask = MaskAnalysis & GMmask 4. Visualization: Creates a figure with columns being following maps/masks overlaid over mean population T1w: * FoV probability 0-50% missing voxels * Vascular 0-7.5% missing voxels * Susceptibility 0-50% missing voxels * Analysis mask Recommended usage Interface definition Sort By Spatial CoV Function function xASL_qc_SortBySpatialCoV(x, Threshold1, Threshold2) Description Compute statistics for each ROI. Workflow This function organizes the ASL QC images in //analysis/Population/ASLCheck into CBF, vascular and artifactual contrast per the spatial CoV thresholds defined above, in folders: //analysis/Population/ASLCheck/1_CBFContrast //analysis/Population/ASLCheck/2_VascularContrast //analysis/Population/ASLCheck/3_ArtifactualContrast Invalid spatial CoV numbers (e.g. NaN) will go to: //analysis/Population/ASLCheck/4_Unknown_sCoV Note: these outputs need to be visually checked; but pre-sorting them by spatial CoV puts them already in categories that are quick to skim through and manually correct by moving the images The idea is then that only category 1 images are used for perfusion (CBF) analyses, both categories 1 & 2 for the vascular (sCoV) analyses, and the category 3 images excluded from analysis. PM : this code does not include multiple sessions per subject yet! NB : this code uses the //analysis/Population/Stats/CoV_qCBF TotalGM .csv file, make sure that this file isn't edited! Recommended usage Interface definition Compute Ws CV Function function x = xASL_stat_ComputeWsCV(x) Description Calculates the within and between-subject coefficient of variance (wsCV and bsCV respectively), to estimate the power to detect effects. This requires 4D images that have been split. Workflow Recommended usage Interface definition Get Acquisition Time Function function x = xASL_stat_GetAcquisitionTime(x) Description Summarize the acquisition time of scans. Workflow This functions collects the DICOM field AcquisitionTime from each json sidecar (& parms.mat for backward compatibility) and saves them in the participants.tsv. Additionally, it creates a AcquisitionTime histogram of the full study, which can be useful to check time of scanning -> can influence physiological CBF variability. Collect times Save times Create time histogram Recommended usage Interface definition Get DICOM Statistics Function function xASL_stat_GetDICOMStatistics(x, ScanType, HasSessions, bOverwrite) Description Collect DICOM metadata in CSV file to check. Workflow This functions prints DICOM metadata (e.g. parameters used for quantification) and collects them in a single tsv (per BIDS). Summarizes this for the total population. Can be useful to detect software upgrades, where only slight parameter changes can hint on quantification changes. This function carries out the following steps: Load & save individual parameter files Print summary Write TSV file Recommended usage Interface definition Get Motion Statistics Function function xASL_stat_GetMotionStatistics(x) Description Summarize motion values. Workflow This functions collects motion stats, with the following steps: Collect motion data If no data, skip this function Print motion vs exclusion overview Add motion data to participants.tsv Recommended usage Interface definition Get Volume Statistics Function function xASL_stat_GetVolumeStatistics(x) Description Summarize volume values. Workflow This functions collects motion stats, with the following steps: Collect structural volume data Collect WMH data Add stats in participants.tsv Recommended usage Interface definition Create Biasfield Function function xASL_wrp_CreateBiasfield(x) Description Create sequence-specific intensity biasfields. Workflow This function creates a smooth biasfield as intensity map to normalize intensities between different sequences/scanner/sites within a single study. This is a simple pragmatic approach and is not validated, but is the best we can do. First acquires average additive & multiplicative factors for total GM, then does a smooth voxel-wise rescaling. This doesn't make an assumption whether site or sequence differences are additive or multiplicative, but rather fits them both. Global scaling it performed to GM CBF == 60 mL/100g/min NB : make sure that sequence resolution differences have been taken in account before creating these biasfields. PM : add normalization of between-subjects SD as well. PM : are there other things we can normalize? Recommended usage Interface definition Create Population Templates Function function xASL_wrp_CreatePopulationTemplates(x, SaveUnmasked, bCompute4Sets, SpecificScantype, bSkipMissingScans, bRemoveOutliers, FunctionsAre) Description ExploreASL Population module wrapper, creates population parametric images for each ScanType. Workflow This function creates simple parametric images, a.k.a. templates, for different image/scan types, on population level, as well as for different sets (e.g. sites/scanners/cohorts, etc) if specified. By default these images are masked, and transformed into a single column, for quick computations with low memory usage. The default parametric images that are created are the mean, between-subject SD, and the maximal intensity projection (MIP). The latter can e.g. identify intra-vascular signal that is similar between different subjects. Other parametric maps can be decommented (now commented out for speed). Recommended usage Interface definition Get ROI statistics Function function xASL_wrp_GetROIstatistics(x) Description Compute statistics for each ROI. Workflow This wrapper organizes the computation of statistics for different ROIs in a [1.5 1.5 1.5] mm MNI space: Load the atlas: xASL_stat_AtlasForStats Organize TSV output name: using x.S.output_ID Obtain the ROI statistics: xASL_stat_GetROIstatistics Print statistics in TSV files: xASL_stat_PrintStats Recommended usage Interface definition Load 4D Mem Mapping Lesions ROIs Function function [x] = xASL_wrp_Load4DMemMapping_LesionsROIs(x) Description Part of ExploreASL analysis module. Loads data & maps it to memory mapping file on disc, if not done before. Workflow Recommended usage Interface definition","title":"Module Population"},{"location":"Population_Module/#submodules-of-the-population-module","text":"","title":"Submodules of the Population Module"},{"location":"Population_Module/#delete-many-temp-files","text":"","title":"Delete Many Temp Files"},{"location":"Population_Module/#function","text":"function xASL_adm_DeleteManyTempFiles(x)","title":"Function"},{"location":"Population_Module/#description","text":"This function removes as many files as possible.","title":"Description"},{"location":"Population_Module/#workflow","text":"","title":"Workflow"},{"location":"Population_Module/#recommended-usage","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition","text":"","title":"Interface definition"},{"location":"Population_Module/#gzip-all-files","text":"","title":"Gzip All Files"},{"location":"Population_Module/#function_1","text":"function xASL_adm_GzipAllFiles(ROOT, bFolder, bUseLinux)","title":"Function"},{"location":"Population_Module/#description_1","text":"This function zips all .nii files recursively into nii.gz. Note that the linux option cannot deal with spaces in filenames or directories.","title":"Description"},{"location":"Population_Module/#workflow_1","text":"","title":"Workflow"},{"location":"Population_Module/#recommended-usage_1","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition_1","text":"","title":"Interface definition"},{"location":"Population_Module/#create-analysis-mask","text":"","title":"Create Analysis Mask"},{"location":"Population_Module/#function_2","text":"function [x] = xASL_im_CreateAnalysisMask(x, Threshold)","title":"Function"},{"location":"Population_Module/#description_2","text":"Creates population analysis mask.","title":"Description"},{"location":"Population_Module/#workflow_2","text":"This function takes the mean population-based probability maps of masks, thresholds and combines them: 1. Creation GM, WM & WholeBrain masks by p>0.5 2. Create, combine & save vascular, susceptibity & FoV masks: * MaskVascular * MaskSusceptibility = MaskSusceptibility & MaskFoV 3. Create & save VBA mask * MaskAnalysis = MaskVascular & MaskSusceptibility * x.S.VBAmask = MaskAnalysis & GMmask 4. Visualization: Creates a figure with columns being following maps/masks overlaid over mean population T1w: * FoV probability 0-50% missing voxels * Vascular 0-7.5% missing voxels * Susceptibility 0-50% missing voxels * Analysis mask","title":"Workflow"},{"location":"Population_Module/#recommended-usage_2","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition_2","text":"","title":"Interface definition"},{"location":"Population_Module/#sort-by-spatial-cov","text":"","title":"Sort By Spatial CoV"},{"location":"Population_Module/#function_3","text":"function xASL_qc_SortBySpatialCoV(x, Threshold1, Threshold2)","title":"Function"},{"location":"Population_Module/#description_3","text":"Compute statistics for each ROI.","title":"Description"},{"location":"Population_Module/#workflow_3","text":"This function organizes the ASL QC images in //analysis/Population/ASLCheck into CBF, vascular and artifactual contrast per the spatial CoV thresholds defined above, in folders: //analysis/Population/ASLCheck/1_CBFContrast //analysis/Population/ASLCheck/2_VascularContrast //analysis/Population/ASLCheck/3_ArtifactualContrast Invalid spatial CoV numbers (e.g. NaN) will go to: //analysis/Population/ASLCheck/4_Unknown_sCoV Note: these outputs need to be visually checked; but pre-sorting them by spatial CoV puts them already in categories that are quick to skim through and manually correct by moving the images The idea is then that only category 1 images are used for perfusion (CBF) analyses, both categories 1 & 2 for the vascular (sCoV) analyses, and the category 3 images excluded from analysis. PM : this code does not include multiple sessions per subject yet! NB : this code uses the //analysis/Population/Stats/CoV_qCBF TotalGM .csv file, make sure that this file isn't edited!","title":"Workflow"},{"location":"Population_Module/#recommended-usage_3","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition_3","text":"","title":"Interface definition"},{"location":"Population_Module/#compute-ws-cv","text":"","title":"Compute Ws CV"},{"location":"Population_Module/#function_4","text":"function x = xASL_stat_ComputeWsCV(x)","title":"Function"},{"location":"Population_Module/#description_4","text":"Calculates the within and between-subject coefficient of variance (wsCV and bsCV respectively), to estimate the power to detect effects. This requires 4D images that have been split.","title":"Description"},{"location":"Population_Module/#workflow_4","text":"","title":"Workflow"},{"location":"Population_Module/#recommended-usage_4","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition_4","text":"","title":"Interface definition"},{"location":"Population_Module/#get-acquisition-time","text":"","title":"Get Acquisition Time"},{"location":"Population_Module/#function_5","text":"function x = xASL_stat_GetAcquisitionTime(x)","title":"Function"},{"location":"Population_Module/#description_5","text":"Summarize the acquisition time of scans.","title":"Description"},{"location":"Population_Module/#workflow_5","text":"This functions collects the DICOM field AcquisitionTime from each json sidecar (& parms.mat for backward compatibility) and saves them in the participants.tsv. Additionally, it creates a AcquisitionTime histogram of the full study, which can be useful to check time of scanning -> can influence physiological CBF variability. Collect times Save times Create time histogram","title":"Workflow"},{"location":"Population_Module/#recommended-usage_5","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition_5","text":"","title":"Interface definition"},{"location":"Population_Module/#get-dicom-statistics","text":"","title":"Get DICOM Statistics"},{"location":"Population_Module/#function_6","text":"function xASL_stat_GetDICOMStatistics(x, ScanType, HasSessions, bOverwrite)","title":"Function"},{"location":"Population_Module/#description_6","text":"Collect DICOM metadata in CSV file to check.","title":"Description"},{"location":"Population_Module/#workflow_6","text":"This functions prints DICOM metadata (e.g. parameters used for quantification) and collects them in a single tsv (per BIDS). Summarizes this for the total population. Can be useful to detect software upgrades, where only slight parameter changes can hint on quantification changes. This function carries out the following steps: Load & save individual parameter files Print summary Write TSV file","title":"Workflow"},{"location":"Population_Module/#recommended-usage_6","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition_6","text":"","title":"Interface definition"},{"location":"Population_Module/#get-motion-statistics","text":"","title":"Get Motion Statistics"},{"location":"Population_Module/#function_7","text":"function xASL_stat_GetMotionStatistics(x)","title":"Function"},{"location":"Population_Module/#description_7","text":"Summarize motion values.","title":"Description"},{"location":"Population_Module/#workflow_7","text":"This functions collects motion stats, with the following steps: Collect motion data If no data, skip this function Print motion vs exclusion overview Add motion data to participants.tsv","title":"Workflow"},{"location":"Population_Module/#recommended-usage_7","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition_7","text":"","title":"Interface definition"},{"location":"Population_Module/#get-volume-statistics","text":"","title":"Get Volume Statistics"},{"location":"Population_Module/#function_8","text":"function xASL_stat_GetVolumeStatistics(x)","title":"Function"},{"location":"Population_Module/#description_8","text":"Summarize volume values.","title":"Description"},{"location":"Population_Module/#workflow_8","text":"This functions collects motion stats, with the following steps: Collect structural volume data Collect WMH data Add stats in participants.tsv","title":"Workflow"},{"location":"Population_Module/#recommended-usage_8","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition_8","text":"","title":"Interface definition"},{"location":"Population_Module/#create-biasfield","text":"","title":"Create Biasfield"},{"location":"Population_Module/#function_9","text":"function xASL_wrp_CreateBiasfield(x)","title":"Function"},{"location":"Population_Module/#description_9","text":"Create sequence-specific intensity biasfields.","title":"Description"},{"location":"Population_Module/#workflow_9","text":"This function creates a smooth biasfield as intensity map to normalize intensities between different sequences/scanner/sites within a single study. This is a simple pragmatic approach and is not validated, but is the best we can do. First acquires average additive & multiplicative factors for total GM, then does a smooth voxel-wise rescaling. This doesn't make an assumption whether site or sequence differences are additive or multiplicative, but rather fits them both. Global scaling it performed to GM CBF == 60 mL/100g/min NB : make sure that sequence resolution differences have been taken in account before creating these biasfields. PM : add normalization of between-subjects SD as well. PM : are there other things we can normalize?","title":"Workflow"},{"location":"Population_Module/#recommended-usage_9","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition_9","text":"","title":"Interface definition"},{"location":"Population_Module/#create-population-templates","text":"","title":"Create Population Templates"},{"location":"Population_Module/#function_10","text":"function xASL_wrp_CreatePopulationTemplates(x, SaveUnmasked, bCompute4Sets, SpecificScantype, bSkipMissingScans, bRemoveOutliers, FunctionsAre)","title":"Function"},{"location":"Population_Module/#description_10","text":"ExploreASL Population module wrapper, creates population parametric images for each ScanType.","title":"Description"},{"location":"Population_Module/#workflow_10","text":"This function creates simple parametric images, a.k.a. templates, for different image/scan types, on population level, as well as for different sets (e.g. sites/scanners/cohorts, etc) if specified. By default these images are masked, and transformed into a single column, for quick computations with low memory usage. The default parametric images that are created are the mean, between-subject SD, and the maximal intensity projection (MIP). The latter can e.g. identify intra-vascular signal that is similar between different subjects. Other parametric maps can be decommented (now commented out for speed).","title":"Workflow"},{"location":"Population_Module/#recommended-usage_10","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition_10","text":"","title":"Interface definition"},{"location":"Population_Module/#get-roi-statistics","text":"","title":"Get ROI statistics"},{"location":"Population_Module/#function_11","text":"function xASL_wrp_GetROIstatistics(x)","title":"Function"},{"location":"Population_Module/#description_11","text":"Compute statistics for each ROI.","title":"Description"},{"location":"Population_Module/#workflow_11","text":"This wrapper organizes the computation of statistics for different ROIs in a [1.5 1.5 1.5] mm MNI space: Load the atlas: xASL_stat_AtlasForStats Organize TSV output name: using x.S.output_ID Obtain the ROI statistics: xASL_stat_GetROIstatistics Print statistics in TSV files: xASL_stat_PrintStats","title":"Workflow"},{"location":"Population_Module/#recommended-usage_11","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition_11","text":"","title":"Interface definition"},{"location":"Population_Module/#load-4d-mem-mapping-lesions-rois","text":"","title":"Load 4D Mem Mapping Lesions ROIs"},{"location":"Population_Module/#function_12","text":"function [x] = xASL_wrp_Load4DMemMapping_LesionsROIs(x)","title":"Function"},{"location":"Population_Module/#description_12","text":"Part of ExploreASL analysis module. Loads data & maps it to memory mapping file on disc, if not done before.","title":"Description"},{"location":"Population_Module/#workflow_12","text":"","title":"Workflow"},{"location":"Population_Module/#recommended-usage_12","text":"","title":"Recommended usage"},{"location":"Population_Module/#interface-definition_12","text":"","title":"Interface definition"},{"location":"Requirements/","text":"ExploreASL Requirements Matlab Version Docker Version","title":"Requirements"},{"location":"Requirements/#exploreasl-requirements","text":"","title":"ExploreASL Requirements"},{"location":"Requirements/#matlab-version","text":"","title":"Matlab Version"},{"location":"Requirements/#docker-version","text":"","title":"Docker Version"},{"location":"Structural_Module/","text":"Submodules of the Structural Module Clean Up WMH SEGM Function function xASL_wrp_CleanUpWMH_SEGM(x) Description Submodule of ExploreASL Structural Module, that cleans up under- and over-segmentations of WMH SEGM . Workflow This submodule aims to clean up WMH under- or oversegmentations in a conservatively & robust way, i.e. erring on the side of caution. It uses input from the tissue class segmentation (e.g. CAT12 ) to repair the WMH segmentation (e.g. LST LPA/LGA or externally provided). Note that before running the tissue segmentation, the T1w was (conservatively) filled for WMH lesions. This function is not tested a lot, so mainly conservatively set up to improve the WMH volumetrics, rather than improve the registration. This submodule contains the following steps: Administration Correct pGM islands inside pWM : WMH can have an intensity similar to GM on the T1w , which erroneously classifies them as GM instead of WM(H) . The rule used here, is to define GM islands within the WM as clusters of pGM >0.05 for which 3 layers (dilations) have at least 95% pWM . For these islands, pGM is given 100% to pWM . 50% of pWM is given to pWMH (the pWMH/pNAWM distinction is made later in the pipeline, here still pWM=pWMH+pNAWM ). The reason is that not all low T1w intensities within the WM are WMH , we still expect some lacunes, perivascular (Virchow-Robin) spaces, which could be considered pNAWM rather than pWMH. Perform brainmasking & join masks Correct any WMH inside GM or CSF -> here we assume that CAT12 did a good segmentation job. If pGM is larger than pWM & larger than pWMH , we consider a voxel to be pGM and remove the pWMH. This effectively removes pWMH segmentation noise in the GM or CSF , it doesn't correct any significant misclassification of WMH in the GM or CSF . If the WMH segmentation does a significant misclassification (e.g. setting the pWMH inside GM or CSF to a probability higher than GM or CSF is by tissue segmentation), this is lesion filled after the WMH segmentation, on the T1w , hence the tissue segmentation won't have a chance to correct this. Fortunately, most oversegmentations in the GM/CSF have low pWMH , as WMH segmentation algorithms already perform a light tissue prior-based clean up themselves. Saving & file management Prepare visuals for visual QC & file management Recommended usage Interface definition FLAIR Biasfield Correction Function function xASL_wrp_FLAIR_BiasfieldCorrection(x) Description Submodule of ExploreASL Structural Module, that performs a biasfield correction on T1w & applies it on the FLAIR . Workflow This submodule performs a biasfield correction on T1w and applies it on FLAIR . This can be useful, when there are large lesions on the FLAIR that hamper capturing the biasfield nicely on the FLAIR itself. In such cases, the biasfield of the T1w might be easier to obtain and should be the same as the FLAIR , provided they are scanned in the same scan session (i.e.g same scanner, same coil). BE CAREFUL : this submodule assumes that the biasfields of the T1w and FLAIR are comparable, which is not the case when one of the two (or both) are already biasfield corrected. Recommended usage Interface definition Get Volumetrics Function function xASL_wrp_GetVolumetrics(x) Description Submodule of ExploreASL Structural Module, that obtains volumes from the tissue segmentations (& FLAIR WMH segmentations if they exist). Workflow This submodule computes the total volume for each of the tissue classes & stores them in a TSV file (per BIDS ). This is computed from the native space segmentation derivatives ( GM, WM & CSF ), from which the ICV & relative volumes can be calculated. This is performed for CAT12 or SPM12 (whichever was used), and optionally for a WMH_SEGM . Recommended usage Interface definition LST Segment FLAIR WMH Function function xASL_wrp_LST_Segment_FLAIR_WMH(x, rWMHPath, WMHsegmAlg) Description Submodule of ExploreASL Structural Module, that performs a biasfield correction on T1w & applies it on the FLAIR . Workflow This submodule runs the LST WMH segmentation, either with LGA or LPA . LPA is the default choice, it outperforms LGA a bit, depending on the image quality. These algorithms perform optimally with 3T images, with good contrast. Generally, LPA oversegments whereas LGA undersegments. The LPA oversegmentation is corrected in a later submodule. If a WMH_SEGM already existed, the LST is run quickly as dummy only, to be replaced by the original WMH_SEGM image. This function has the following parts: Reslice FLAIR (& WMH_SEGM , if exists) to T1w Define parameters for segmentation Run the segmentation Replace by already existing WMH_SEGM File management Remove NaNs from segmentations & fix image edges Recommended usage Interface definition LST T1w Lesion Filling WMH Function function xASL_wrp_LST_T1w_LesionFilling_WMH(x, rWMHPath) Description Submodule of ExploreASL Structural Module, that performs lesion filling on T1w based on WMH segmented on the FLAIR . Workflow This submodule runs the LST WMH -based T1w lesion filling, which should improve the registration & segmentation of the T1w by e.g. CAT12/SPM12 . The WMH can be either segmented in the previous submodule by LST LGA/LPGA or provided externally. Before lesion filling, we clean up the WMH segmentation, to make the lesion filling a bit more conservative. Sometimes the WMH segmentation oversegments inside the GM (as there can be hyperintensities on the FLAIR ) & we don't want to lesion-fill these on the T1w (which would turn their intensities in intensities similar to WM , leading to misclassifications by the T1w segmentation). Note that this is submodule only performs the lesion filling, and the clean up is also performed for the lesion filling only. A more thorough WMH clean up (for e.g. WMH volumetrics) is performed later in the Structural module, using also the results from the T1w segmentation. Note when changing the lesion filling here, LST lesion filling expects a probability map, doesnt work nicely with binary mask This function runs the following steps: File management Clean up the WMH segmentation used for lesion filling Run lesion filling Correction of too much/erronous lesion filling File management Recommended usage Interface definition Linear Reg FLAIR 2 T1w Function function xASL_wrp_LinearReg_FLAIR2T1w(x, bAutoACPC) Description Submodule of ExploreASL Structural Module, that aligns FLAIR with T1w . Workflow This submodule registers FLAIR linearly to the T1w . The same transformation is applied to all other related scans ( FLAIR -segmented lesions, WMH specifically or other lesions). This is required to enable the application of T1w derivatives (e.g. transformations to standard space, tissue segmentation) for FLAIR and vice versa (e.g. WMH lesion-filling). Recommended usage Interface definition Linear Reg T1w2MNI Function function xASL_wrp_LinearReg_T1w2MNI(x, bAutoACPC) Description Submodule of ExploreASL Structural Module, that aligns T1w with MNI . Workflow This submodule registers T1w linearly to the center of MNI space, a.k.a. ACPC alignment. The same transformation is applied to all other related scans ( ASL4D, M0, FLAIR, etc.). This facilitates MNI -based algorithms (e.g. SPM -based segmentation), and allows for visual QC with all images roughly in the same space. This submodule first clips high values that can bias the registration algorithm, then performs a center of mass-based ACPC alignment, and then several iterations of SPM coregistration. Assuming that this submodule is run at the start of ExploreASL, all NIfTI orientation matrices are restored before running the registration. Recommended usage Interface definition Resample 2 Standard Space Function function xASL_wrp_Resample2StandardSpace(x) Description Submodule of ExploreASL Structural Module, that resamples all structural images & derivatives. Workflow This submodule resamples all structural images & their derivatives to standard space. It uses the transformation fields that were obtained previously in the Structural module, concatenates all transformations into a single transformation (if not already done) & applies the transformation with a single interpolation (either trilinear for low quality or probability maps, or 2nd order B-spline). Finally, it computes the Jacobian determinants (i.e. the derivative of the transformation field) to obtain a map of the volumetric effects of the transformation. This Jacobian map is multiplied with the standard space resampled images, to restore their (local & global) total volume. The sum of volumes in native & standard space are compared as QC . This submodule is not only part of the structural module, but can be repeated when the transformation map is edited, e.g. after longitudinal registration or after creation of a group-wise template. Recommended usage Interface definition Segment T1w Function function [x] = xASL_wrp_SegmentT1w(x, SegmentSPM12) Description Submodule of ExploreASL Structural Module, that segments 3D T1 (or T2 ) scan. Workflow This submodule segments high resolution structural/anatomical scans into GM/WM/CSF /soft tissue/bone/air tissue classes. It will save GM/WM/CSF in native space, and the transformation from native to standard space. This transformation includes Geodesic Shooting/DARTEL for CAT12 . This submodule contains the following steps: Administration Extra segmentation options by Jan Petr Segmentation using CAT12 If CAT12 fails, it will be repeated with higher contrast, higher strength affine preprocessing & less biasfield regularization If CAT12 fails twice, it will be skipped & SPM12 will be run Segmentation using SPM12 File management CAT12 File management lesions Resample lesions to standard space For the lesion masking. MORE EXPLANATION NEEDED BY JAN Manage flowfields Smooth combination non-linear flowfield outside the lesion & uniform flowfield within the lesion File management Recommended usage Interface definition Visual QC Structural Function function xASL_wrp_VisualQC_Structural(x) Description Submodule of ExploreASL Structural Module, that performs several visualizations for . Workflow This submodule performs several visualizations for visual & quantitative QC . After initial admin It starts with the SPM UP parameters (courtesy of Cyril Pernet, his SPM UP scripts were made more robust & accurate by Jan & Henk, & are implemented here for T1w (& optionally FLAIR ). Then it performs a collection of visualizations Also repeated specifically for lesions & manually provided ROIs Finally, this contains a report of all missing raw & derivative files, in native & standard space, printing the NIfTI orientation matrix content before ( hdr.mat0 ) & after registrations ( hdr.mat ). The determinant of these matrices should be the same, otherwise LeftRight has flipped. This should also be the same across a group scanned at the same scanner. Then various other QC functions are called & all are summarized in a PDF report. Recommended usage Interface definition","title":"Module Structural"},{"location":"Structural_Module/#submodules-of-the-structural-module","text":"","title":"Submodules of the Structural Module"},{"location":"Structural_Module/#clean-up-wmh-segm","text":"","title":"Clean Up WMH SEGM"},{"location":"Structural_Module/#function","text":"function xASL_wrp_CleanUpWMH_SEGM(x)","title":"Function"},{"location":"Structural_Module/#description","text":"Submodule of ExploreASL Structural Module, that cleans up under- and over-segmentations of WMH SEGM .","title":"Description"},{"location":"Structural_Module/#workflow","text":"This submodule aims to clean up WMH under- or oversegmentations in a conservatively & robust way, i.e. erring on the side of caution. It uses input from the tissue class segmentation (e.g. CAT12 ) to repair the WMH segmentation (e.g. LST LPA/LGA or externally provided). Note that before running the tissue segmentation, the T1w was (conservatively) filled for WMH lesions. This function is not tested a lot, so mainly conservatively set up to improve the WMH volumetrics, rather than improve the registration. This submodule contains the following steps: Administration Correct pGM islands inside pWM : WMH can have an intensity similar to GM on the T1w , which erroneously classifies them as GM instead of WM(H) . The rule used here, is to define GM islands within the WM as clusters of pGM >0.05 for which 3 layers (dilations) have at least 95% pWM . For these islands, pGM is given 100% to pWM . 50% of pWM is given to pWMH (the pWMH/pNAWM distinction is made later in the pipeline, here still pWM=pWMH+pNAWM ). The reason is that not all low T1w intensities within the WM are WMH , we still expect some lacunes, perivascular (Virchow-Robin) spaces, which could be considered pNAWM rather than pWMH. Perform brainmasking & join masks Correct any WMH inside GM or CSF -> here we assume that CAT12 did a good segmentation job. If pGM is larger than pWM & larger than pWMH , we consider a voxel to be pGM and remove the pWMH. This effectively removes pWMH segmentation noise in the GM or CSF , it doesn't correct any significant misclassification of WMH in the GM or CSF . If the WMH segmentation does a significant misclassification (e.g. setting the pWMH inside GM or CSF to a probability higher than GM or CSF is by tissue segmentation), this is lesion filled after the WMH segmentation, on the T1w , hence the tissue segmentation won't have a chance to correct this. Fortunately, most oversegmentations in the GM/CSF have low pWMH , as WMH segmentation algorithms already perform a light tissue prior-based clean up themselves. Saving & file management Prepare visuals for visual QC & file management","title":"Workflow"},{"location":"Structural_Module/#recommended-usage","text":"","title":"Recommended usage"},{"location":"Structural_Module/#interface-definition","text":"","title":"Interface definition"},{"location":"Structural_Module/#flair-biasfield-correction","text":"","title":"FLAIR Biasfield Correction"},{"location":"Structural_Module/#function_1","text":"function xASL_wrp_FLAIR_BiasfieldCorrection(x)","title":"Function"},{"location":"Structural_Module/#description_1","text":"Submodule of ExploreASL Structural Module, that performs a biasfield correction on T1w & applies it on the FLAIR .","title":"Description"},{"location":"Structural_Module/#workflow_1","text":"This submodule performs a biasfield correction on T1w and applies it on FLAIR . This can be useful, when there are large lesions on the FLAIR that hamper capturing the biasfield nicely on the FLAIR itself. In such cases, the biasfield of the T1w might be easier to obtain and should be the same as the FLAIR , provided they are scanned in the same scan session (i.e.g same scanner, same coil). BE CAREFUL : this submodule assumes that the biasfields of the T1w and FLAIR are comparable, which is not the case when one of the two (or both) are already biasfield corrected.","title":"Workflow"},{"location":"Structural_Module/#recommended-usage_1","text":"","title":"Recommended usage"},{"location":"Structural_Module/#interface-definition_1","text":"","title":"Interface definition"},{"location":"Structural_Module/#get-volumetrics","text":"","title":"Get Volumetrics"},{"location":"Structural_Module/#function_2","text":"function xASL_wrp_GetVolumetrics(x)","title":"Function"},{"location":"Structural_Module/#description_2","text":"Submodule of ExploreASL Structural Module, that obtains volumes from the tissue segmentations (& FLAIR WMH segmentations if they exist).","title":"Description"},{"location":"Structural_Module/#workflow_2","text":"This submodule computes the total volume for each of the tissue classes & stores them in a TSV file (per BIDS ). This is computed from the native space segmentation derivatives ( GM, WM & CSF ), from which the ICV & relative volumes can be calculated. This is performed for CAT12 or SPM12 (whichever was used), and optionally for a WMH_SEGM .","title":"Workflow"},{"location":"Structural_Module/#recommended-usage_2","text":"","title":"Recommended usage"},{"location":"Structural_Module/#interface-definition_2","text":"","title":"Interface definition"},{"location":"Structural_Module/#lst-segment-flair-wmh","text":"","title":"LST Segment FLAIR WMH"},{"location":"Structural_Module/#function_3","text":"function xASL_wrp_LST_Segment_FLAIR_WMH(x, rWMHPath, WMHsegmAlg)","title":"Function"},{"location":"Structural_Module/#description_3","text":"Submodule of ExploreASL Structural Module, that performs a biasfield correction on T1w & applies it on the FLAIR .","title":"Description"},{"location":"Structural_Module/#workflow_3","text":"This submodule runs the LST WMH segmentation, either with LGA or LPA . LPA is the default choice, it outperforms LGA a bit, depending on the image quality. These algorithms perform optimally with 3T images, with good contrast. Generally, LPA oversegments whereas LGA undersegments. The LPA oversegmentation is corrected in a later submodule. If a WMH_SEGM already existed, the LST is run quickly as dummy only, to be replaced by the original WMH_SEGM image. This function has the following parts: Reslice FLAIR (& WMH_SEGM , if exists) to T1w Define parameters for segmentation Run the segmentation Replace by already existing WMH_SEGM File management Remove NaNs from segmentations & fix image edges","title":"Workflow"},{"location":"Structural_Module/#recommended-usage_3","text":"","title":"Recommended usage"},{"location":"Structural_Module/#interface-definition_3","text":"","title":"Interface definition"},{"location":"Structural_Module/#lst-t1w-lesion-filling-wmh","text":"","title":"LST T1w Lesion Filling WMH"},{"location":"Structural_Module/#function_4","text":"function xASL_wrp_LST_T1w_LesionFilling_WMH(x, rWMHPath)","title":"Function"},{"location":"Structural_Module/#description_4","text":"Submodule of ExploreASL Structural Module, that performs lesion filling on T1w based on WMH segmented on the FLAIR .","title":"Description"},{"location":"Structural_Module/#workflow_4","text":"This submodule runs the LST WMH -based T1w lesion filling, which should improve the registration & segmentation of the T1w by e.g. CAT12/SPM12 . The WMH can be either segmented in the previous submodule by LST LGA/LPGA or provided externally. Before lesion filling, we clean up the WMH segmentation, to make the lesion filling a bit more conservative. Sometimes the WMH segmentation oversegments inside the GM (as there can be hyperintensities on the FLAIR ) & we don't want to lesion-fill these on the T1w (which would turn their intensities in intensities similar to WM , leading to misclassifications by the T1w segmentation). Note that this is submodule only performs the lesion filling, and the clean up is also performed for the lesion filling only. A more thorough WMH clean up (for e.g. WMH volumetrics) is performed later in the Structural module, using also the results from the T1w segmentation. Note when changing the lesion filling here, LST lesion filling expects a probability map, doesnt work nicely with binary mask This function runs the following steps: File management Clean up the WMH segmentation used for lesion filling Run lesion filling Correction of too much/erronous lesion filling File management","title":"Workflow"},{"location":"Structural_Module/#recommended-usage_4","text":"","title":"Recommended usage"},{"location":"Structural_Module/#interface-definition_4","text":"","title":"Interface definition"},{"location":"Structural_Module/#linear-reg-flair-2-t1w","text":"","title":"Linear Reg FLAIR 2 T1w"},{"location":"Structural_Module/#function_5","text":"function xASL_wrp_LinearReg_FLAIR2T1w(x, bAutoACPC)","title":"Function"},{"location":"Structural_Module/#description_5","text":"Submodule of ExploreASL Structural Module, that aligns FLAIR with T1w .","title":"Description"},{"location":"Structural_Module/#workflow_5","text":"This submodule registers FLAIR linearly to the T1w . The same transformation is applied to all other related scans ( FLAIR -segmented lesions, WMH specifically or other lesions). This is required to enable the application of T1w derivatives (e.g. transformations to standard space, tissue segmentation) for FLAIR and vice versa (e.g. WMH lesion-filling).","title":"Workflow"},{"location":"Structural_Module/#recommended-usage_5","text":"","title":"Recommended usage"},{"location":"Structural_Module/#interface-definition_5","text":"","title":"Interface definition"},{"location":"Structural_Module/#linear-reg-t1w2mni","text":"","title":"Linear Reg T1w2MNI"},{"location":"Structural_Module/#function_6","text":"function xASL_wrp_LinearReg_T1w2MNI(x, bAutoACPC)","title":"Function"},{"location":"Structural_Module/#description_6","text":"Submodule of ExploreASL Structural Module, that aligns T1w with MNI .","title":"Description"},{"location":"Structural_Module/#workflow_6","text":"This submodule registers T1w linearly to the center of MNI space, a.k.a. ACPC alignment. The same transformation is applied to all other related scans ( ASL4D, M0, FLAIR, etc.). This facilitates MNI -based algorithms (e.g. SPM -based segmentation), and allows for visual QC with all images roughly in the same space. This submodule first clips high values that can bias the registration algorithm, then performs a center of mass-based ACPC alignment, and then several iterations of SPM coregistration. Assuming that this submodule is run at the start of ExploreASL, all NIfTI orientation matrices are restored before running the registration.","title":"Workflow"},{"location":"Structural_Module/#recommended-usage_6","text":"","title":"Recommended usage"},{"location":"Structural_Module/#interface-definition_6","text":"","title":"Interface definition"},{"location":"Structural_Module/#resample-2-standard-space","text":"","title":"Resample 2 Standard Space"},{"location":"Structural_Module/#function_7","text":"function xASL_wrp_Resample2StandardSpace(x)","title":"Function"},{"location":"Structural_Module/#description_7","text":"Submodule of ExploreASL Structural Module, that resamples all structural images & derivatives.","title":"Description"},{"location":"Structural_Module/#workflow_7","text":"This submodule resamples all structural images & their derivatives to standard space. It uses the transformation fields that were obtained previously in the Structural module, concatenates all transformations into a single transformation (if not already done) & applies the transformation with a single interpolation (either trilinear for low quality or probability maps, or 2nd order B-spline). Finally, it computes the Jacobian determinants (i.e. the derivative of the transformation field) to obtain a map of the volumetric effects of the transformation. This Jacobian map is multiplied with the standard space resampled images, to restore their (local & global) total volume. The sum of volumes in native & standard space are compared as QC . This submodule is not only part of the structural module, but can be repeated when the transformation map is edited, e.g. after longitudinal registration or after creation of a group-wise template.","title":"Workflow"},{"location":"Structural_Module/#recommended-usage_7","text":"","title":"Recommended usage"},{"location":"Structural_Module/#interface-definition_7","text":"","title":"Interface definition"},{"location":"Structural_Module/#segment-t1w","text":"","title":"Segment T1w"},{"location":"Structural_Module/#function_8","text":"function [x] = xASL_wrp_SegmentT1w(x, SegmentSPM12)","title":"Function"},{"location":"Structural_Module/#description_8","text":"Submodule of ExploreASL Structural Module, that segments 3D T1 (or T2 ) scan.","title":"Description"},{"location":"Structural_Module/#workflow_8","text":"This submodule segments high resolution structural/anatomical scans into GM/WM/CSF /soft tissue/bone/air tissue classes. It will save GM/WM/CSF in native space, and the transformation from native to standard space. This transformation includes Geodesic Shooting/DARTEL for CAT12 . This submodule contains the following steps: Administration Extra segmentation options by Jan Petr Segmentation using CAT12 If CAT12 fails, it will be repeated with higher contrast, higher strength affine preprocessing & less biasfield regularization If CAT12 fails twice, it will be skipped & SPM12 will be run Segmentation using SPM12 File management CAT12 File management lesions Resample lesions to standard space For the lesion masking. MORE EXPLANATION NEEDED BY JAN Manage flowfields Smooth combination non-linear flowfield outside the lesion & uniform flowfield within the lesion File management","title":"Workflow"},{"location":"Structural_Module/#recommended-usage_8","text":"","title":"Recommended usage"},{"location":"Structural_Module/#interface-definition_8","text":"","title":"Interface definition"},{"location":"Structural_Module/#visual-qc-structural","text":"","title":"Visual QC Structural"},{"location":"Structural_Module/#function_9","text":"function xASL_wrp_VisualQC_Structural(x)","title":"Function"},{"location":"Structural_Module/#description_9","text":"Submodule of ExploreASL Structural Module, that performs several visualizations for .","title":"Description"},{"location":"Structural_Module/#workflow_9","text":"This submodule performs several visualizations for visual & quantitative QC . After initial admin It starts with the SPM UP parameters (courtesy of Cyril Pernet, his SPM UP scripts were made more robust & accurate by Jan & Henk, & are implemented here for T1w (& optionally FLAIR ). Then it performs a collection of visualizations Also repeated specifically for lesions & manually provided ROIs Finally, this contains a report of all missing raw & derivative files, in native & standard space, printing the NIfTI orientation matrix content before ( hdr.mat0 ) & after registrations ( hdr.mat ). The determinant of these matrices should be the same, otherwise LeftRight has flipped. This should also be the same across a group scanned at the same scanner. Then various other QC functions are called & all are summarized in a PDF report.","title":"Workflow"},{"location":"Structural_Module/#recommended-usage_9","text":"","title":"Recommended usage"},{"location":"Structural_Module/#interface-definition_9","text":"","title":"Interface definition"}]}