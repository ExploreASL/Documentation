{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ExploreASL Description Installation Workflow Documentation ExploreASL team Acknowledgments How to cite Description ExploreASL is a pipeline and toolbox for image processing and statistics of arterial spin labeling perfusion MR images. It is designed as a multi-OS , open source, collaborative framework that facilitates cross-pollination between image processing method developers and clinical investigators. The software provides a complete head-to-tail approach that runs fully automatically, encompassing all necessary tasks from data import and structural segmentation, registration and normalization, up to CBF quantification. In addition, the software package includes and quality control ( QC ) procedures and region-of-interest ( ROI ) as well as voxel-wise analysis on the extracted data. To-date, ExploreASL has been used for processing ~10000 ASL datasets from all major MRI vendors and ASL sequences, and a variety of patient populations, representing ~30 studies. The ultimate goal of ExploreASL is to combine data from multiple studies to identify disease related perfusion patterns that may prove crucial in using ASL as a diagnostic tool and enhance our understanding of the interplay of perfusion and structural changes in neurodegenerative pathophysiology. Additionally, this (semi-)automatic pipeline allows us to minimize manual intervention, which increases the reproducibility of studies. Installation To use ExploreASL within Matlab, you can download a stable release version from the GitHub releases section. Navigate within Matlab to the ExporeASL directory, to make ExploreASL the current working directory. To start ExploreASL from Matlab, type: ExploreASL Workflow Documentation Additional information about ExploreASL can be found in the Neuroimage paper and on the ExploreASL website , including the walkthrough document and how-to videos. Further documentation is work in progress. For any help please contact the lead authors/developers at h.j.mutsaerts@amsterdamumc.nl or j.petr@hzdr.de. ExploreASL team Henk Mutsaerts - co-creator Jan Petr - co-creator Michael Stritt - PhD student, ASPIRE Paul Groot - developer backbone, IT specialist Pieter Vandemaele - developer Matlab BIDS app Luigi Lorenzini - developer ExploreQC Maurice Pasternak - developer GUI Mathijs Dijsselhof - PhD student, Cerebrovascular Age Beatriz Padrela - PhD student, BBB-ASL Sandeep Ganji - developer integration Philips ISD Patricia Clement - developer ASL-BIDS & organizer Acknowledgments This project is supported by the Dutch Heart Foundation (2020T049), the Eurostars-2 joint programme with co-funding from the European Union Horizon 2020 research and innovation programme ( ASPIRE E!113701 ), including the Netherlands Enterprise Agency (RvO), and by the EU Joint Program for Neurodegenerative Disease Research, including the Netherlands Organisation for health Research and Development and Alzheimer Nederland ( DEBBIE JPND2020-568-106 ). This project has previously received support from the following EU/EFPIA Innovative Medicines Initiatives (1 and 2) Joint Undertakings: EPAD grant no. 115736, AMYPAD grant no. 115952 and Amsterdam Neuroscience . The authors wish to thank the COST-AID (European Cooperation in Science and Technology - Arterial spin labeling Initiative in Dementia) Action BM1103 and the Open Source Initiative for Perfusion Imaging (OSIPI) and the ISMRM Perfusion Study groups for facilitating meetings for researchers to discuss the implementation of ExploreASL. The authors acknowledge Guillaume Flandin, Robert Dahnke, and Paul Schmidt for reviewing the structural module for its implementation of SPM12 , CAT12 , and LST , respectively; Krzysztof Gorgolewksi for his advice on the BIDS implementation; Jens Maus for help with MEX compilation; Cyril Pernet for providing the SPM Univariate Plus QC scripts. Contributors \u2728 Thanks goes to these wonderful people ( emoji key ): Henk Mutsaerts \ud83d\udc68\u200d\ud83d\udd2c \ud83d\udd8b \ud83d\udcbb Jan Petr \ud83d\udc68\u200d\ud83d\udd2c \ud83d\udd8b \ud83d\udcbb Michael Stritt \ud83d\udcbb \ud83d\udd8b \ud83d\udcd6 Paul Groot \ud83d\udcbb \ud83d\udd8b Pieter Vandemaele \ud83d\udcbb \ud83e\udd14 \ud83e\udde0 luislorenzini \ud83d\udcbb \ud83d\udd27 MauricePasternak \ud83d\udcca \ud83d\udcbb \ud83c\udfa8 Patricia Clement \ud83e\udde0 \ud83e\udd14 \ud83d\udcd6 Mathijs Dijsselhof \ud83d\udd8b \ud83e\udde0 Beatriz Padrela \ud83d\udd8b \ud83e\udde0 Sandeep Ganji \ud83d\udd8b \ud83e\udd14 \ud83e\udde0 Martin Craig \ud83d\udd8b \ud83d\udcbb \ud83e\udde0 jozsait \ud83d\udcbb \ud83d\udea7 DaveThoma5 \ud83e\udd14 \ud83e\udde0 This project follows the all-contributors specification. Contributions of any kind welcome! How to cite The bare minimum of references is the ExploreASL manuscript and the used ExploreASL release, which you can find on Zenodo (e.g. version 1.3.0 ). The following provides an example as how to correctly cite ExploreASL and its third-party tools. The versions of the included third-party tools are described in CHANGES.md for each ExploreASL release. The data were analysed using ExploreASL ref1 version x.x.x ref2 , including SPM12 version xxxx ref3 , CAT12 version xxxx ref4 , and LST version x.x.x ref5 . This Matlab-based software was used with Matlab (MathWorks, MA, USA) version x.x (yearx) ref6 . Ref1: the ExploreASL paper, describing the full pipeline and decisions for processing steps: https://www.sciencedirect.com/science/article/pii/S1053811920305176 Ref2: the Zenodo DOI for the actual ExploreASL release used to analyse the data. The release numbers (e.g. 1.3.0) follow semantic versioning . Ref3: SPM12 references: https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib14 & https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib53. Note that the SPM version (e.g. 7219) is adapted and extended for use with ExploreASL. Ref4: CAT12 reference: https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib55. Note that the CAT12 version (e.g. 1364) is adapted for use with ExploreASL. Ref5: LST reference: https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib118. Note that the LST version (e.g. 2.0.15) is adapted for use with ExploreASL. Ref6: Matlab publishes a release twice yearly, which can be reviewed here: https://www.mathworks.com/products/compiler/matlab-runtime.html. You can provide the release number (e.g. 9.4) or year number (e.g. 2018a), or both.","title":"Home"},{"location":"#description","text":"ExploreASL is a pipeline and toolbox for image processing and statistics of arterial spin labeling perfusion MR images. It is designed as a multi-OS , open source, collaborative framework that facilitates cross-pollination between image processing method developers and clinical investigators. The software provides a complete head-to-tail approach that runs fully automatically, encompassing all necessary tasks from data import and structural segmentation, registration and normalization, up to CBF quantification. In addition, the software package includes and quality control ( QC ) procedures and region-of-interest ( ROI ) as well as voxel-wise analysis on the extracted data. To-date, ExploreASL has been used for processing ~10000 ASL datasets from all major MRI vendors and ASL sequences, and a variety of patient populations, representing ~30 studies. The ultimate goal of ExploreASL is to combine data from multiple studies to identify disease related perfusion patterns that may prove crucial in using ASL as a diagnostic tool and enhance our understanding of the interplay of perfusion and structural changes in neurodegenerative pathophysiology. Additionally, this (semi-)automatic pipeline allows us to minimize manual intervention, which increases the reproducibility of studies.","title":"Description"},{"location":"#installation","text":"To use ExploreASL within Matlab, you can download a stable release version from the GitHub releases section. Navigate within Matlab to the ExporeASL directory, to make ExploreASL the current working directory. To start ExploreASL from Matlab, type: ExploreASL","title":"Installation"},{"location":"#workflow","text":"","title":"Workflow"},{"location":"#documentation","text":"Additional information about ExploreASL can be found in the Neuroimage paper and on the ExploreASL website , including the walkthrough document and how-to videos. Further documentation is work in progress. For any help please contact the lead authors/developers at h.j.mutsaerts@amsterdamumc.nl or j.petr@hzdr.de.","title":"Documentation"},{"location":"#exploreasl-team","text":"Henk Mutsaerts - co-creator Jan Petr - co-creator Michael Stritt - PhD student, ASPIRE Paul Groot - developer backbone, IT specialist Pieter Vandemaele - developer Matlab BIDS app Luigi Lorenzini - developer ExploreQC Maurice Pasternak - developer GUI Mathijs Dijsselhof - PhD student, Cerebrovascular Age Beatriz Padrela - PhD student, BBB-ASL Sandeep Ganji - developer integration Philips ISD Patricia Clement - developer ASL-BIDS & organizer","title":"ExploreASL team"},{"location":"#acknowledgments","text":"This project is supported by the Dutch Heart Foundation (2020T049), the Eurostars-2 joint programme with co-funding from the European Union Horizon 2020 research and innovation programme ( ASPIRE E!113701 ), including the Netherlands Enterprise Agency (RvO), and by the EU Joint Program for Neurodegenerative Disease Research, including the Netherlands Organisation for health Research and Development and Alzheimer Nederland ( DEBBIE JPND2020-568-106 ). This project has previously received support from the following EU/EFPIA Innovative Medicines Initiatives (1 and 2) Joint Undertakings: EPAD grant no. 115736, AMYPAD grant no. 115952 and Amsterdam Neuroscience . The authors wish to thank the COST-AID (European Cooperation in Science and Technology - Arterial spin labeling Initiative in Dementia) Action BM1103 and the Open Source Initiative for Perfusion Imaging (OSIPI) and the ISMRM Perfusion Study groups for facilitating meetings for researchers to discuss the implementation of ExploreASL. The authors acknowledge Guillaume Flandin, Robert Dahnke, and Paul Schmidt for reviewing the structural module for its implementation of SPM12 , CAT12 , and LST , respectively; Krzysztof Gorgolewksi for his advice on the BIDS implementation; Jens Maus for help with MEX compilation; Cyril Pernet for providing the SPM Univariate Plus QC scripts.","title":"Acknowledgments"},{"location":"#contributors","text":"Thanks goes to these wonderful people ( emoji key ): Henk Mutsaerts \ud83d\udc68\u200d\ud83d\udd2c \ud83d\udd8b \ud83d\udcbb Jan Petr \ud83d\udc68\u200d\ud83d\udd2c \ud83d\udd8b \ud83d\udcbb Michael Stritt \ud83d\udcbb \ud83d\udd8b \ud83d\udcd6 Paul Groot \ud83d\udcbb \ud83d\udd8b Pieter Vandemaele \ud83d\udcbb \ud83e\udd14 \ud83e\udde0 luislorenzini \ud83d\udcbb \ud83d\udd27 MauricePasternak \ud83d\udcca \ud83d\udcbb \ud83c\udfa8 Patricia Clement \ud83e\udde0 \ud83e\udd14 \ud83d\udcd6 Mathijs Dijsselhof \ud83d\udd8b \ud83e\udde0 Beatriz Padrela \ud83d\udd8b \ud83e\udde0 Sandeep Ganji \ud83d\udd8b \ud83e\udd14 \ud83e\udde0 Martin Craig \ud83d\udd8b \ud83d\udcbb \ud83e\udde0 jozsait \ud83d\udcbb \ud83d\udea7 DaveThoma5 \ud83e\udd14 \ud83e\udde0 This project follows the all-contributors specification. Contributions of any kind welcome!","title":"Contributors \u2728"},{"location":"#how-to-cite","text":"The bare minimum of references is the ExploreASL manuscript and the used ExploreASL release, which you can find on Zenodo (e.g. version 1.3.0 ). The following provides an example as how to correctly cite ExploreASL and its third-party tools. The versions of the included third-party tools are described in CHANGES.md for each ExploreASL release. The data were analysed using ExploreASL ref1 version x.x.x ref2 , including SPM12 version xxxx ref3 , CAT12 version xxxx ref4 , and LST version x.x.x ref5 . This Matlab-based software was used with Matlab (MathWorks, MA, USA) version x.x (yearx) ref6 . Ref1: the ExploreASL paper, describing the full pipeline and decisions for processing steps: https://www.sciencedirect.com/science/article/pii/S1053811920305176 Ref2: the Zenodo DOI for the actual ExploreASL release used to analyse the data. The release numbers (e.g. 1.3.0) follow semantic versioning . Ref3: SPM12 references: https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib14 & https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib53. Note that the SPM version (e.g. 7219) is adapted and extended for use with ExploreASL. Ref4: CAT12 reference: https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib55. Note that the CAT12 version (e.g. 1364) is adapted for use with ExploreASL. Ref5: LST reference: https://www.sciencedirect.com/science/article/pii/S1053811920305176#bib118. Note that the LST version (e.g. 2.0.15) is adapted for use with ExploreASL. Ref6: Matlab publishes a release twice yearly, which can be reviewed here: https://www.mathworks.com/products/compiler/matlab-runtime.html. You can provide the release number (e.g. 9.4) or year number (e.g. 2018a), or both.","title":"How to cite"},{"location":"ASL_Module/","text":"Submodules of the ASL Module xASL_wrp_CreateAnalysisMask.m Format: xASL_wrp_CreateAnalysisMask(x) Description: This function creates an analysis mask with the following steps: 0. Create FoV mask (native & MNI spaces) 1. Detect negative vascular signal (native & MNI spaces, within pGM>0.5) 2. Detect peak vascular signal (native & MNI spaces, within pGM==80% percentile on ASL image) 3. Brainmasking & FoV-masking (A) native & B) MNI spaces) - Add WM vascular parts back to the mask (defined as pWM>0.8) & remove extracranial signal In the WM, negative or peak signal is more expected from noise rather than from intra-vascular signal, not many big vessels exist in the WM 4. Save vascular masks 5. Create susceptibility mask (standard space only) Here, we combine manually segmented susceptibility artifact regions in which a population-based susceptibility probability map is created This map is combined (i.e. taking the product) with the mean control & PWI intensity distribution in these regions. This product is thresholded with the average of the 75th percentile & 15% of the intensity (for a bit more robustness against individual variability in sinus sizes). xASL_wrp_PVC.m Format: xASL_wrp_PVC(x) Description: This submodule performs partial volume correction (PVC) in native ASL space. It runs the Asllani's method for partial volume correction by linear regression. It has two main extensions - first it uses a 3D kernel. Second, it can use a Gaussian weights instead of the default flat kernel. Admin and checking values and files Getting the resolution and preparing parameters Running PV-correction Saving files and cleaning xASL_wrp_PreparePV.m Format: xASL_wrp_PreparePV(x, bStandardSpace) Description: This submodule prepares partial volume correction (PVC) by creating correct PV maps in ASL resolution, in native space, as well as in standard space if requested (to perform PVC in standard space): If bStandardSpace: Create dummy upsampled ASL scan, for registration Reslice pGM & pWM to hi-res ASL Estimate effective spatial resolution of ASL Smooth pGM & pWM to this spatial resolution Move smoothed tissue posteriors to MNI space else: run step 3 only, which will use the effective spatial resolution that is default for the respective sequence: 2D EPI: [1 1 1] * VoxelSize 3D GRASE: [1.1 1.1 1.38] * VoxelSize 3D spiral: [4.3 4.4 10.1] * VoxelSize (assuming GE uses the upsampled 2x2x4 mm & run steps 1&2, but in native space these entail presmoothing & downsampling. xASL_wrp_ProcessM0.m Format: xASL_wrp_ProcessM0(x) Description: This submodule performs the image processing and quantification of M0 maps (if they exist), with the following steps: Register M0 to mean control if it exists Before registration, contrast is equalized between the images & biasfields are removed Quantify M0 (correction scale slope & incomplete T1 recovery) Masking & smoothing of M0 image, either using: A) traditional technique (very sharp masking & little smoothing) B) new ExploreASL-specific technique: * extrapolating outside mask (avoiding artifacts from too much or too little masking) * smooth very extensively, to create a biasfield (increases robustness & comparison of M0 between sequences/patients) Any M0 will be processed here. Even if part of the subjects does not have an M0, since this can be later imputed, or an average population M0 image could be used. Also, without background suppression and without an M0, the MeanControl image is before saved as M0, and will be processed here as well. Note that any voxel-size differences between M0 and ASL are allowed here: step 0B below rescales the PD inside an M0 voxel to the same as the ASL resolution (assuming a voxel with half volume contains half the amount of protons). The M0 is further processed in standard space, and reduced to a biasfield. For the quantification in standard space, the PWI and M0 are now by definition in the same space. Also, the standard space M0 biasfield is resampled to the native PWI space (at the end of step 3B), ensuring that both are also in the same native space. xASL_wrp_Quantify.m Format: xASL_wrp_Quantify(x) Description: This submodule converts PWIs to quantified CBF maps (or related derivatives). Note that we don't delete x.P.Path_PWI4D here, as this NIfTI file may be needed by xASL_wrp_VisualQC_ASL.m Load PWI Prepare M0 Hematocrit & blood T1 correction ASL & M0 parameters comparisons Load SliceGradient Initialize & define quantification parameters Define labeling efficiency Perform quantification Save files Perform FEAST quantification (if exist) Create standard space masked image to visualize masking effect xASL_wrp_RealignASL.m Format: xASL_wrp_RealignASL(x[,bSubtraction]) Description: This submodule estimates motion by spm_realign, which uses a rigid-body registration (3 translations, 3 rotations). It runs ENABLE to reject outliers and provides a visualization. ENABLE, QC and visualizations are based on the Net Displacement Vector (NDV) (in mm): according to Pythagorean/Euclydian RMS https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=ind1211&L=fsl&P=R34458&1=fsl&9=A&J=on&d=No+Match%3BMatch%3BMatches&z=4 view this link for image of rotation roll, pitch and yaw https://www.google.nl/search?q=rotation+pitch+yaw+roll&espv=2&tbm=isch&imgil=LW3Nn1K-L6Oc7M%253A%253B-aSyykkRityJoM%253Bhttp%25253A%25252F%25252Fwww.grc.nasa.gov%25252FWWW%25252Fk-12%25252Fairplane%25252Frotations.html&source=iu&usg=__MlLQ5VuyRbm6kZP0vBJlPxmfbkw%3D&sa=X&ei=TWfjU4WcK4bqyQPqu4Fo&ved=0CD8Q9QEwBQ&biw=1680&bih=946#facrc=_&imgdii=_&imgrc=LW3Nn1K-L6Oc7M%253A%3B-aSyykkRityJoM%3Bhttp%253A%252F%252Fwww.grc.nasa.gov%252FWWW%252Fk-12%252Fairplane%252FImages%252Frotations.gif%3Bhttp%253A%252F%252Fwww.grc.nasa.gov%252FWWW%252Fk-12%252Fairplane%252Frotations.html%3B709%3B533 This submodule performs the following steps: Estimate motion Calculate and plot position and motion parameters Threshold-free spike definition (based on ENABLE, but with t-stats rather than the threshold p<0.05) Remove spike frames from nifti xASL_wrp_RegisterASL.m Format: xASL_wrp_RegisterASL(x) Description: This submodule registers ASL images to T1w space, by using a combination of the registration techniques below. Note that in the absence of raw structural files (i.e. T1.nii[.gz] or T1_ORI.nii[.gz], it will recreate dummy files from standard space to do this registration M0-T1w rigid-body -> this works well in 2D EPI sequences PWI-pGM rigid-body -> this is robust across sequences with different readouts and consequently different effective spatial resolutions. With low spatial resolution (e.g. GE 3D spiral product sequence), M0-T1w registration may not work, but PWI-pGM will work. PWI-pGM registration fails with large (vascular) artifacts, therefore this is performed only with relatively low spatial CoV. PWI-pGM affine -> If the spatial CoV is sufficiently low, this can improve the registration These images are registered to ASL templates that were inversely transformed from MNI to the T1w space (& resampled to the ASL space) As this would have an ever higher similarity with the M0 & PWI This submodule performs the following steps: 0. Administration: - A. ASL4D is dealth with, if motion peaks were removed this is called despiked_ASL4D - B. a default \"OtherList\" is specified. This is used every registration instance, except for removing the ref and src NIfTIs used in the registration instance. Also, inside the registration function the unexisting OtherList NIfTIs are skipped - C. Define paths to the ASL templates - D. Previous registration output files are removed - E. Allow registration without structural data - F. native->MNI transformation flow field y_T1.nii is smoothed to the effective ASL resolution y_ASL.nii - G. Registration contrasts are dealth with: x.modules.asl.bRegistrationContrast - specifies the image contrast used for registration (OPTIONAL, DEFAULT = 2): - 0 = Control->T1w - 1 = CBF->pseudoCBF from template/pGM+pWM (skip if sCoV>0.667) - 2 = automatic (mix of both) - 3 = option 2 & force CBF->pseudoCBF irrespective of sCoV or Tanimoto coefficient - H. Dummy src NIfTIs are created: mean_control.nii to register with T1w mean_PWI_Clipped.nii to register with pseudoCBF - I. Create reference images, downsampled pseudoTissue Registration Center of Mass Registration ASL -> anat (Control->T1w) (this step is only applied if it improves the Tanimoto coefficient) Registration CBF->pseudoCBF (this step is only applied if it improves the Tanimoto coefficient). Also, this step is only applied if the spatial CoV<0.67. Note that this is usually the case for 3D scans because of their lower effective spatial resolution. x.modules.asl.bAffineRegistration - specifies the ASL-T1w rigid-body registration is followed up by an affine registration (OPTIONAL, DEFAULT = 0) - 0 = affine registration disabled - 1 = affine registration enabled - 2 = affine registration automatically chosen based on spatial CoV of PWI x.modules.asl.bDCTRegistration - Specifies if to include the DCT registration on top of Affine, all other requirements for affine are thus also taken into account (OPTIONAL, DEFAULT = 0) - 0 = DCT registration disabled - 1 = DCT registration enabled if affine enabled and conditions for affine passed - 2 = DCT enabled as above, but use PVC on top of it to get the local intensity scaling right xASL_wrp_ResampleASL.m Format: xASL_wrp_ResampleASL(x) Description: This submodule resamples native space NIfTIs to standard space, using the deformation fields computed in the structural module after smoothing these transformation fields to the ASL resolution. The applied interpolation is a combination of all transformations (e.g. motion correction, registration to T1w, and transformation of T1w to standard space. This submodule performs the following steps: Administration Warp TopUp QC files Create slice gradient image for quantification reference, in case of 2D ASL Resample ASL time series to MNI space Resample to native space (applying any motion correction or registration) Bilateral filter (currently disabled) Create mean control image, if available, in native & standard space Clone mean control image to be used as pseudo-M0 (if x.Q.M0==UseControlAsM0) Pair-wise subtraction & saving PWI & PWI4D in both spaces Save PWI NIfTI & time-series-related maps (SD, SNR) Delete temporary files Report spatial CoV as QC xASL_wrp_VisualQC_ASL.m Format: xASL_wrp_VisualQC_ASL(x) Description: This submodule performs several visualizations for visual & quantitative QC. After initial admin It starts with making ASL NIfTIs ready for visualization & conversion to DICOM (though skipped by default) Then it performs a collection of visualizations Visualizes results of the TopUp geometric distortion correction Visualization of slice gradient Visualization & calculation of temporal QC parameters Compute DICE overlap/intersection of ASL brain in FoV & T1w, to calculate coverage Summarize orientation & check left-right flips Collect several other parameters & store in PDF overview","title":"Module ASL"},{"location":"ASL_Module/#submodules-of-the-asl-module","text":"","title":"Submodules of the ASL Module"},{"location":"ASL_Module/#xasl_wrp_createanalysismaskm","text":"Format: xASL_wrp_CreateAnalysisMask(x) Description: This function creates an analysis mask with the following steps: 0. Create FoV mask (native & MNI spaces) 1. Detect negative vascular signal (native & MNI spaces, within pGM>0.5) 2. Detect peak vascular signal (native & MNI spaces, within pGM==80% percentile on ASL image) 3. Brainmasking & FoV-masking (A) native & B) MNI spaces) - Add WM vascular parts back to the mask (defined as pWM>0.8) & remove extracranial signal In the WM, negative or peak signal is more expected from noise rather than from intra-vascular signal, not many big vessels exist in the WM 4. Save vascular masks 5. Create susceptibility mask (standard space only) Here, we combine manually segmented susceptibility artifact regions in which a population-based susceptibility probability map is created This map is combined (i.e. taking the product) with the mean control & PWI intensity distribution in these regions. This product is thresholded with the average of the 75th percentile & 15% of the intensity (for a bit more robustness against individual variability in sinus sizes).","title":"xASL_wrp_CreateAnalysisMask.m"},{"location":"ASL_Module/#xasl_wrp_pvcm","text":"Format: xASL_wrp_PVC(x) Description: This submodule performs partial volume correction (PVC) in native ASL space. It runs the Asllani's method for partial volume correction by linear regression. It has two main extensions - first it uses a 3D kernel. Second, it can use a Gaussian weights instead of the default flat kernel. Admin and checking values and files Getting the resolution and preparing parameters Running PV-correction Saving files and cleaning","title":"xASL_wrp_PVC.m"},{"location":"ASL_Module/#xasl_wrp_preparepvm","text":"Format: xASL_wrp_PreparePV(x, bStandardSpace) Description: This submodule prepares partial volume correction (PVC) by creating correct PV maps in ASL resolution, in native space, as well as in standard space if requested (to perform PVC in standard space): If bStandardSpace: Create dummy upsampled ASL scan, for registration Reslice pGM & pWM to hi-res ASL Estimate effective spatial resolution of ASL Smooth pGM & pWM to this spatial resolution Move smoothed tissue posteriors to MNI space else: run step 3 only, which will use the effective spatial resolution that is default for the respective sequence: 2D EPI: [1 1 1] * VoxelSize 3D GRASE: [1.1 1.1 1.38] * VoxelSize 3D spiral: [4.3 4.4 10.1] * VoxelSize (assuming GE uses the upsampled 2x2x4 mm & run steps 1&2, but in native space these entail presmoothing & downsampling.","title":"xASL_wrp_PreparePV.m"},{"location":"ASL_Module/#xasl_wrp_processm0m","text":"Format: xASL_wrp_ProcessM0(x) Description: This submodule performs the image processing and quantification of M0 maps (if they exist), with the following steps: Register M0 to mean control if it exists Before registration, contrast is equalized between the images & biasfields are removed Quantify M0 (correction scale slope & incomplete T1 recovery) Masking & smoothing of M0 image, either using: A) traditional technique (very sharp masking & little smoothing) B) new ExploreASL-specific technique: * extrapolating outside mask (avoiding artifacts from too much or too little masking) * smooth very extensively, to create a biasfield (increases robustness & comparison of M0 between sequences/patients) Any M0 will be processed here. Even if part of the subjects does not have an M0, since this can be later imputed, or an average population M0 image could be used. Also, without background suppression and without an M0, the MeanControl image is before saved as M0, and will be processed here as well. Note that any voxel-size differences between M0 and ASL are allowed here: step 0B below rescales the PD inside an M0 voxel to the same as the ASL resolution (assuming a voxel with half volume contains half the amount of protons). The M0 is further processed in standard space, and reduced to a biasfield. For the quantification in standard space, the PWI and M0 are now by definition in the same space. Also, the standard space M0 biasfield is resampled to the native PWI space (at the end of step 3B), ensuring that both are also in the same native space.","title":"xASL_wrp_ProcessM0.m"},{"location":"ASL_Module/#xasl_wrp_quantifym","text":"Format: xASL_wrp_Quantify(x) Description: This submodule converts PWIs to quantified CBF maps (or related derivatives). Note that we don't delete x.P.Path_PWI4D here, as this NIfTI file may be needed by xASL_wrp_VisualQC_ASL.m Load PWI Prepare M0 Hematocrit & blood T1 correction ASL & M0 parameters comparisons Load SliceGradient Initialize & define quantification parameters Define labeling efficiency Perform quantification Save files Perform FEAST quantification (if exist) Create standard space masked image to visualize masking effect","title":"xASL_wrp_Quantify.m"},{"location":"ASL_Module/#xasl_wrp_realignaslm","text":"Format: xASL_wrp_RealignASL(x[,bSubtraction]) Description: This submodule estimates motion by spm_realign, which uses a rigid-body registration (3 translations, 3 rotations). It runs ENABLE to reject outliers and provides a visualization. ENABLE, QC and visualizations are based on the Net Displacement Vector (NDV) (in mm): according to Pythagorean/Euclydian RMS https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=ind1211&L=fsl&P=R34458&1=fsl&9=A&J=on&d=No+Match%3BMatch%3BMatches&z=4 view this link for image of rotation roll, pitch and yaw https://www.google.nl/search?q=rotation+pitch+yaw+roll&espv=2&tbm=isch&imgil=LW3Nn1K-L6Oc7M%253A%253B-aSyykkRityJoM%253Bhttp%25253A%25252F%25252Fwww.grc.nasa.gov%25252FWWW%25252Fk-12%25252Fairplane%25252Frotations.html&source=iu&usg=__MlLQ5VuyRbm6kZP0vBJlPxmfbkw%3D&sa=X&ei=TWfjU4WcK4bqyQPqu4Fo&ved=0CD8Q9QEwBQ&biw=1680&bih=946#facrc=_&imgdii=_&imgrc=LW3Nn1K-L6Oc7M%253A%3B-aSyykkRityJoM%3Bhttp%253A%252F%252Fwww.grc.nasa.gov%252FWWW%252Fk-12%252Fairplane%252FImages%252Frotations.gif%3Bhttp%253A%252F%252Fwww.grc.nasa.gov%252FWWW%252Fk-12%252Fairplane%252Frotations.html%3B709%3B533 This submodule performs the following steps: Estimate motion Calculate and plot position and motion parameters Threshold-free spike definition (based on ENABLE, but with t-stats rather than the threshold p<0.05) Remove spike frames from nifti","title":"xASL_wrp_RealignASL.m"},{"location":"ASL_Module/#xasl_wrp_registeraslm","text":"Format: xASL_wrp_RegisterASL(x) Description: This submodule registers ASL images to T1w space, by using a combination of the registration techniques below. Note that in the absence of raw structural files (i.e. T1.nii[.gz] or T1_ORI.nii[.gz], it will recreate dummy files from standard space to do this registration M0-T1w rigid-body -> this works well in 2D EPI sequences PWI-pGM rigid-body -> this is robust across sequences with different readouts and consequently different effective spatial resolutions. With low spatial resolution (e.g. GE 3D spiral product sequence), M0-T1w registration may not work, but PWI-pGM will work. PWI-pGM registration fails with large (vascular) artifacts, therefore this is performed only with relatively low spatial CoV. PWI-pGM affine -> If the spatial CoV is sufficiently low, this can improve the registration These images are registered to ASL templates that were inversely transformed from MNI to the T1w space (& resampled to the ASL space) As this would have an ever higher similarity with the M0 & PWI This submodule performs the following steps: 0. Administration: - A. ASL4D is dealth with, if motion peaks were removed this is called despiked_ASL4D - B. a default \"OtherList\" is specified. This is used every registration instance, except for removing the ref and src NIfTIs used in the registration instance. Also, inside the registration function the unexisting OtherList NIfTIs are skipped - C. Define paths to the ASL templates - D. Previous registration output files are removed - E. Allow registration without structural data - F. native->MNI transformation flow field y_T1.nii is smoothed to the effective ASL resolution y_ASL.nii - G. Registration contrasts are dealth with: x.modules.asl.bRegistrationContrast - specifies the image contrast used for registration (OPTIONAL, DEFAULT = 2): - 0 = Control->T1w - 1 = CBF->pseudoCBF from template/pGM+pWM (skip if sCoV>0.667) - 2 = automatic (mix of both) - 3 = option 2 & force CBF->pseudoCBF irrespective of sCoV or Tanimoto coefficient - H. Dummy src NIfTIs are created: mean_control.nii to register with T1w mean_PWI_Clipped.nii to register with pseudoCBF - I. Create reference images, downsampled pseudoTissue Registration Center of Mass Registration ASL -> anat (Control->T1w) (this step is only applied if it improves the Tanimoto coefficient) Registration CBF->pseudoCBF (this step is only applied if it improves the Tanimoto coefficient). Also, this step is only applied if the spatial CoV<0.67. Note that this is usually the case for 3D scans because of their lower effective spatial resolution. x.modules.asl.bAffineRegistration - specifies the ASL-T1w rigid-body registration is followed up by an affine registration (OPTIONAL, DEFAULT = 0) - 0 = affine registration disabled - 1 = affine registration enabled - 2 = affine registration automatically chosen based on spatial CoV of PWI x.modules.asl.bDCTRegistration - Specifies if to include the DCT registration on top of Affine, all other requirements for affine are thus also taken into account (OPTIONAL, DEFAULT = 0) - 0 = DCT registration disabled - 1 = DCT registration enabled if affine enabled and conditions for affine passed - 2 = DCT enabled as above, but use PVC on top of it to get the local intensity scaling right","title":"xASL_wrp_RegisterASL.m"},{"location":"ASL_Module/#xasl_wrp_resampleaslm","text":"Format: xASL_wrp_ResampleASL(x) Description: This submodule resamples native space NIfTIs to standard space, using the deformation fields computed in the structural module after smoothing these transformation fields to the ASL resolution. The applied interpolation is a combination of all transformations (e.g. motion correction, registration to T1w, and transformation of T1w to standard space. This submodule performs the following steps: Administration Warp TopUp QC files Create slice gradient image for quantification reference, in case of 2D ASL Resample ASL time series to MNI space Resample to native space (applying any motion correction or registration) Bilateral filter (currently disabled) Create mean control image, if available, in native & standard space Clone mean control image to be used as pseudo-M0 (if x.Q.M0==UseControlAsM0) Pair-wise subtraction & saving PWI & PWI4D in both spaces Save PWI NIfTI & time-series-related maps (SD, SNR) Delete temporary files Report spatial CoV as QC","title":"xASL_wrp_ResampleASL.m"},{"location":"ASL_Module/#xasl_wrp_visualqc_aslm","text":"Format: xASL_wrp_VisualQC_ASL(x) Description: This submodule performs several visualizations for visual & quantitative QC. After initial admin It starts with making ASL NIfTIs ready for visualization & conversion to DICOM (though skipped by default) Then it performs a collection of visualizations Visualizes results of the TopUp geometric distortion correction Visualization of slice gradient Visualization & calculation of temporal QC parameters Compute DICE overlap/intersection of ASL brain in FoV & T1w, to calculate coverage Summarize orientation & check left-right flips Collect several other parameters & store in PDF overview","title":"xASL_wrp_VisualQC_ASL.m"},{"location":"About/","text":"About ExploreASL Team Henk Mutsaerts - co-creator Jan Petr - co-creator Michael Stritt - PhD student, ASPIRE Paul Groot - developer backbone, IT specialist Pieter Vandemaele - developer Matlab BIDS app Luigi Lorenzini - developer ExploreQC Maurice Pasternak - developer GUI Mathijs Dijsselhof - PhD student, Cerebrovascular Age Beatriz Padrela - PhD student, BBB-ASL Sandeep Ganji - developer integration Philips ISD Patricia Clement - developer ASL-BIDS & organizer","title":"About"},{"location":"About/#about","text":"","title":"About"},{"location":"About/#exploreasl-team","text":"Henk Mutsaerts - co-creator Jan Petr - co-creator Michael Stritt - PhD student, ASPIRE Paul Groot - developer backbone, IT specialist Pieter Vandemaele - developer Matlab BIDS app Luigi Lorenzini - developer ExploreQC Maurice Pasternak - developer GUI Mathijs Dijsselhof - PhD student, Cerebrovascular Age Beatriz Padrela - PhD student, BBB-ASL Sandeep Ganji - developer integration Philips ISD Patricia Clement - developer ASL-BIDS & organizer","title":"ExploreASL Team"},{"location":"Changes/","text":"ExploreASL Change Log ExploreASL v1.7.0 Versions included software Versions included & used third-party tools (see /External/README_SPM.txt ): SPM12 7219 CAT12 r1615 LST 2.0.15 Feature improvements Issue #455: Automatically compare results of TestDataSets with a saved reference results Issues #480, #623, #649, #661: Restructure x : x.opts (input arguments and their derivatives), x.dir (directories), x.settings (mostly booleans for pipeline settings), x.dataset (dataset related fields), x.external , ... Issue #572: Restructure JSON handling during NiFTI to BIDS import Issue #580: Add parsing of Gold Standard Phantoms ASL-DRO Issues #588, #612: ExploreASL reads folders and automatically searches for sourceStructure , studyPar and dataPar JSON files Issue #600: Put participants.tsv to the derivatives folder during import to legacy ExploreASL format Issue #602: Remove option for cloning the NIfTI output after import as BIDS directory is a read-only archive Issue #603: Give ExploreASL version in JSON files after BIDS to Legacy conversion Issue #631: Remove repeated warnings Issue #632: Add comparison script for untouched NIfTI comparison Issue #643: bids.layout : avoid printing the same warning repetitively in case multiple scans in a data set have the same issue Issue #656: Improve warnings (data loading) Bug fixes Issue #583: Proper testing of flavors using ExploreASL_Master Issue #584: Print the subject name depending on the existence of its definition in x.SUBJECT to avoid crashes for error reporting in the population module Issue #586: Avoid crashing xASL_adm_GetPopulationSessions if no sessions are found Issue #591: MultiTE import puts TE before PLD in the time series and corrects the JSON output Issue #618: Add session name to all M0Check and ASLCheck QC files in the Population folder Issue #620: xASL_adm_GzipAllFiles : Allow spaces in an input path for macOS/Linux Issue #625: Fix bug related to session format Issue #627: Remove a BIDS fiels and BIDS2Legacy should crash and show you why it crashed Issue #628: Fix parsing sessions and runs for converting rawdata to derivatives Issue #630: Move creation of population folder Issue #646: Improve BIDS warnings Issue #652: xASL_vis_CreateVisualFig : allow empty overlays Issue #659: xASL_stat_PrintStats : Fix visits bug (legacy format) Issue #655: xASL_adm_GetPopulationSessions gave incorrect warnings Issue #666: Warning when multiple dataPar*.json or studyPar*.json or sourcestructure*.json are present Issue #670: Fix warnings and behavior of ExploreASL_Initialize Other improvements Issue #465: Add projects to acknowledgments Issue #615: Add change log to documentation Issue #637: Restyle ExploreASL change log ExploreASL v1.6.2 Bug Fixes Issue #589 Fix scaling issues in JSONs in TestDataSet/derivatives ExploreASL v1.6.1 Bug Fixes Issue #578 Fix incorrect path searching by providing error if no .json-file is inputted ExploreASL v1.6.0 Versions included software Versions included & used third-party tools (see /External/README_SPM.txt ): SPM12 7219 CAT12 r1615 LST 2.0.15 Feature improvements (still backward compatible) Issues #62, #266, #449: JSON i/o unify and use spm_jsonread and spm_jsonwrite for all operations Issue #349: Improve screenprint of the current subjects/sessions/modules by xASL_Iteration Issue #384: Add method to export image matrices as structured points in VTK format Issue #523: Update ExploreASL_ImportConfig to work with JSONs and add alert for users Issue #538: Function to user-replace label values in atlas NIfTI, written for the CICERO study Issue #559: Add option x.MakeNIfTI4DICOM to create CBF optimized for DICOM creation/PACS export Work in progress BASIL Issue #20: Data pre-processing prepared for BASIL Issue #391: Add single-PLD model for BASIL ASL-BIDS Issues #290,#483,#484: Initial version of the ASL-BIDS import workflow Issue #353: Correct conversion BIDS->Legacy for M0 with reversed PE direction Issues #394,#514,#545: Improve modularity of the ASL-BIDS import module Issue #411: Delete temporary folders in DICOM->BIDS conversion Issue #421: Use ImageType DICOM field to detect scan order in GE in DICOM->BIDS import Issue #426: Reading PLD from DICOM for GE in import to BIDS Issue #479: ASL-BIDS import for Hadamard encoded FME sequences DRO and QASPER Issues #361,#443: Import and import test of DRO Issues #467: Improve script to generate ASL-BIDS version of ASL DRO v2.2.0 Compilation/stand-alone version Bug Fixes Issue #184: Skip PVC in Population statistics, when this does not make sense for a given ROI Issue #262: Improve GZIP on windows Issue #341: Reduce extensive usage of ExploreASL CLI progress tracker Issue #368: Fix problem with writing trailing zeros in real numbers in spm_jsonwrite Issue #387: Remove graphical waitbar interface from xASL_im_ResampleLinearFair Issue #415: xASL_Copy: Allow recursive copying of directories Issue #418: Verifies the SliceTiming parameter if timing difference is consistent between slices Issue #424,#454: Remove string and contains functions to ensure Matlab compatibility for R2016 Issue #430: Fix xASL_adm_ReplaceSymbols crash when trying to replace sub-strings in PhoenixProtocol field Issues #433,#474,#542: Splitting of ASL and M0 - fix on rerun, split metadata, backup aslcontext.tsv Issue #451: Clean unused code and cleaned the development directory Issue #466: Warning if the equal sign is used in JSON files instead of colon Issue #475: Fix error with studies that have a special character in their name Issue #477: Change vascular territory atlases file extensions to .nii.gz Issue #496: Fixed session numbers in population module Issue #502: Fix smoothing of 4D NIfTIs Issue #505: Allow Token Aliases in import to be row vectors in import Issue #518: ExploreASL logo and verbose overview shown only once in a single pipeline run Issue #520: Stop import workflow from creating Population folder in root directory Issue #543: Minor fix of xASL_num2str behavior Issue #563: Minor design fix for ExploreASL dataset initialization Documentation Issues #403,#423,#457: Improved inline comments and headers Issue #452: Provide descriptions of available atlas options Issue #463: Remove remaining markdown file to a separate Documentation repository Issues #486,#489: Introduce document templates for GitHub QC Workflow Issue #499: Make heading in documentation work in dark mode as well Issue #515: Added tutorials to documentation Issue #536: Create a first version of the QC walkthrough document in markdown Testing Issue #156: Make internal error messages more specific by providing subject information Issue #352: Improve parsing of errors and warnings from log files Issue #395,#416: Improve testing of BIDS import Issue #517: Improve unit testing scripts Issue #529: TestDataSet is in BIDS derivatives format Issue #570: Release testing and minor documentation improvements ExploreASL v1.5.1 Bug Fixes Issue #439 Fix population module error by correctly renaming MNI_Structural.* files ExploreASL v1.5.0 Versions included software Versions included & used third-party tools (see /External/README_SPM.txt ): SPM12 7219 CAT12 r1615 LST 2.0.15 Feature improvements (still backward compatible) Issue #39: Create PV-corrected GM & WM CBF maps in native space Issue #56,#410: Add Mindboggle atlas to ExploreASL and restructure general atlas access in population module Issue #283: xASL_stat_GetROIstatistics provide more feedback on missing images Issue #299: Move CustomScripts with study-specific scripts to a separate repository Issue #302: Remove server calls in CAT12 functions Issue #313: Move GUI to a separate repository Issue #351: T2 and T1c files are now also aligned to the T1w and outputted to standard space Issue #354: Added an option x.DummyScanPositionInASL4D that removes marked dummy scans when splitting ASL to ASL+M0+dummy Issues #356,#396,#397: Internally restructure SliceTime allowing ExploreASL now to work with multi-band 2D EPI as well or any other SliceTime order Work in progress ASL-BIDS Issues #163,#189,#357,#373: Conversion from DICOM to BIDS Issues #334,#382: Import of PAR-REC to BIDS Issue #343: Add separate M0 option to mTrial import Compilation/stand-alone version Issue #335: All input arguments can be passed in the deployed mode Issue #380: Enable advanced input parsing for xASL compiled Bug Fixes Issue #228: Fix CAT12 warnings with non-existent field cm Issue #272: Fix errors in JSON import of ASL sidecars Issues #273,#285,#291,#363: Minor fixes in input parameter administration Issues #276,#280,#288,#329,#400: Fix error in reading TSV files with unclear number of columns Issue #282: Population module is run serially in otherwise parallel mode Issue #292: xASL_qc_SortBySpatialCoV now use all subjects without skipping Issue #305: xASL_adm_UnixPath : bug with Windows+WSL Issues #306,#378: Fix JSON reading with 'i' interpreted as a complex number Issue #309: Fix non-linear registration of T1w to standard space with too high T1w values Issue #312: xASL_stat_GetROIstatistics fix skipping of actual ROI extraction Issue #325: xASL_adm_CleanUpBeforeRerun delete files correctly Issue #339: Fix JSON reading of special characters Issue #399: Fix special characters in Windows filenames Issue #405: Fix range-check error in Background Suppression timing calculation Issue #406: Fix xASL_stat_MedianNan for all-NaN input Issues #408,#409: Skip missing fields in CAT during reports in compiled ExploreASL Documentation Issue #7: Create README files in subfolders and added to interactive documentation Issues #279, #345: Move documentation to a separate repository Issues #300,#318: Improve ExploreASL tutorial Issue #355: Documentation improvements regarding input parameters Testing Issues #193,#350,#398: Testing DICOM to BIDS conversion against a reference Issue #294: Implement initial unit testing framework Issue #326: Parse warnings/errors from all log in all subdirectories Issue #369: Unit testing of xASL_test_getLogContent Issues #371,#376,#404: Testing script for the DICOM->BIDS->Legacy conversion and processing ExploreASL v1.4.0 Versions included software Versions included & used third-party tools (see /External/README_SPM.txt): SPM12 7219 CAT12 r1615 LST 2.0.15 Feature improvements (still backward compatible) Issue #20 Implement BASIL -> changed order quantification/masking, and always save resampled PWI4D for quantification, facilitating BASIL Issue #35 Calculation background suppression efficiency for pseudo-M0 -> in case of missing separate M0 images but still using background suppressed mean control as pseudo-M0, a single correction value (3D) or slice-wise correction value (2D) are applied to the pseudo-M0 image/slices Issue #131 ExploreASL_GUI beta-testing enhancements set 1 -> Aesthetic improvements in certain modules, fixed incorrect removal of Philips-related json-sidecar fields in DCM2BIDS / Import module. Correction of ASL image flickering bug and ability for the user to subset without having to reload the data. Added ability to clarify data type of variables without the need to reload data. Added auto-select / auto-complete functionality in the ParmsMaker module as soon as the user indicates an analysis directory (i.e auto-completion of SliceReadoutTime for pCASL) Issue #166 Update ADNI import in ExploreASL_Import Issue #179 Finish creation average maps for CICERO -> improvements xASL_wrp_CreatePopulationTemplates Issue #190 Hammers atlas option CAT12 -> restored the original Hammers atlas option for a colleague (note it's license though!) Issue #225 Create DataPar option for running SPM12 longitudinal registration Issue #241 Add warning when loading data without x output structure Issue #243 Shorten SPM initialization time -> removed configuration loading of unused toolboxes (check if the SPM DICOM import module is still needed) Work in progress ASL-BIDS Issue #193 Comparing BIDS folders (for testing purpose) Issue #226 Add new DICOM tags to DCMTK import Bug Fixes Issue #191 WMH warning when no FLAIR analyzed -> this warning is now removed if no FLAIR was present in the data Issue #248 Temporary fix native space processing -> in Population module Issue #252 Population modules analysis masks - minor errors Issue #267 Error in reading JSONs from EPAD Documentation Issue #196 All contributors -> all contributors are now automatically added to the main README.md Issue #217 Documentation improvements Issue #219 Add user to documentation ExploreASL v1.3.0 Versions included software Versions included & used third-party tools (see /External/README_SPM.txt): SPM12 7219 CAT12 r1615 LST 2.0.15 Feature improvements (still backward compatible) Issue #59: Assign \"weights\" to status files, allowing the external Python ExploreASL GUI to provide a better estimate of the progress Issue #71 Remove custom lesions (Lesion\\_(FLAIR|T1)\\_\\\\d\\\\.nii) from WMH_SEGM.nii Issue #76: Improve functionality of ExploreASL through Command Line Interface (CLI), i.e. without using the Graphical User Interface (GUI) of Matlab Issue #123 Create status files also for skipped processing parts: this is mainly the case for running the structural module without a FLAIR scan. Having all status files helps third-party tools such as the Python ExploreASL GUI to know that processing has succesfully completed (duplicate issues #137 and #129) The same was done for the ASL realignment status file, in case realignment is skipped for a 3D scan Issue #145: Improve .nii(.gz) management in xASL_spm_deformations : allow either .nii or .nii.gz as input, treat them equally, and when .nii.gz is provided as output path, zip the resulting deformed image Work in progress Issue #32 Docker integration Issue #55 ExploreASL GUI, written in Python Issue #106 xASL_im_SplitImageLabels : Allow splitting labels, and warping them to standard space. This is part of a continuous development on creating average flow territory templates and figures. Issue #162 Remove bNativeSpaceProcessing from TestDataSet for now, return this when bNativeSpaceProcess is made more modular ASL-BIDS Issue #82 Avoid 4D files with nT==1, which is not allowed in the BIDS validator Compilation/stand-alone version Issue #88 xASL_SysMove error in Windows when a path includes whitespaces ' ' Bug Fixes Issue #85 Improvement ApplyQuantification Issue #99 Improve loading of metadata ( xASL_str2num & xASL_init_LoadMetaData ) Issue #105 In case of missing data, fill x.S.SUBJECTID and S.DAT data for the last subject/session Issue #119 Create status file for last subject, if it's processing is skipped Issue #120 xASL_im_CreateAnalysisMask in native space mode when in parallel execution Issue #138 Fix structure TestDataJSON & its JSON files Issue #139 Ensure that x fields are not case sensitive, by e.g. replacing strcmp by strcmpi Issue #141 Solve conflicts between develop and master, these were minor edits that weren't implemented in develop yet Issue #143 ensure that VBA masks are also created for a 3D spiral sequence (this was not created yet as the susceptibility masks were missing for this sequence) Issue #148 Syncing the ROI/lesion processing of T1w & FLAIR Issue #151 Minor bugfixes for TopUp Issue #177 Fix xASL_adm_UnzipNifti & xASL_io_SaveNifti when path is incomplete Skip warnings for small populations (in the start of xASL_module_Population ) Fix regular expression in xASL_init_LoadMetaData iRow counting fix in xASL_bids_Add2ParticipantsTSV Documentation Issue #7 Documentation/revamp xASL_im_ClipExtremes Issue #159 Ensure that all sequence notations use underscores instead of whitespace, e.g. 3D_spiral instead of 3D spiral Testing Issue #86 xASL_qc_TestExploreASL : improve Table creation Issue #112 Save Tanimoto Coefficient (i.e. a fuzzy overlap/Dice score) of the final ASL-T1w registration Issue #128 Improved one internal test dataset Issue #130 xASL_qc_TestExploreASL : Complete functionality by allowing Windows parallelization & testing the Windows ExploreASL compilation. Also added unit testing framework in the same issue. ExploreASL v1.2.2 Bug Fixes Issue #119 xASL_wrp_LinearReg_T1w2MNI.m: ROI .nii files correctly aligned with T1 ExploreASL v1.2.1 Bug Fixes xASL_qc_TestExploreASL: Remove locked folders if rerun Issue #90 xASL_io_Nifti2Im : manage the detection of odd scaling Issue #93 xASL_SysMove : diz illegal symbols Windows Issue #102 xASL_wrp_CreatePopulationTemplates : minor bugfix Issue #104 Fix creation ResultsTable for TestCases (also #86) Issue #114 Acquiring Matlab version doesn't crash anymore in deployed mode Issue #115 Fixing NaNs problem in M0 mask computation Issue #118 xASL_adm_GzipAllFiles doesn't crash anymore in Windows Issue #116 ExploreASL testing fixes: Edit header of saved .tsv-file Cosmetic changes\\nUnzip before SPM Clear variables before loading .mat Replace spaces in headers with underscores (which happened automatically apparently upon saving) Remove SPM cellstring ASL-BIDS-related bug fixes Issue #96 Fix order of magnitude in JSON sidecars Issue #109 No warning if SliceReadoutTime not provided in DataPar Issue #110 xASL_bids_parms2BIDS.m now deals correctly with vectors and SliceReadoutTime = 'shortestTR' : created function for this: xASL_quant_SliceReadoutTime_Shortest_TR ExploreASL v1.2.0 Versions included software Versions included & used third-party tools (see /External/README_SPM.txt): SPM12 7219 CAT12 r1615 LST 2.0.15 Major feature improvements (still backward compatible) Add user flexibility for creating average maps, allowing flipping Provide a lesion or ROI mask, to be used not only for cost function masking but also as standard space ROI for ROI-analysis This use is now easier, by simply adding Lesion_FLAIR_1.nii or Lesion_T1_2.nii etc, and visualization improved. These masks are now automatically created (where lesion can be any other ROI): Intralesional Perilesional, pGM+pWM Hemisphere (ipsilateral to lesion) Contralateral (i) Contralateral (ii) Contralateral (iii) Option x.S.bMasking added, allowing specifying masking separately for: bSusceptibilityMask bVascularMask subject-wise bGMMask (e.g. the pGM>0.7 ) brainmasking when loading for lower memory usage Affine registration improved & Discrete Cosine Transform (DCT) non-linear registration option added, including an option with partial volume correction built-in for improved DCT-based registration Bug Fixes Allow zipping in Unix-based OS without JavaVirtualMachine Quantification issue with Philips scale slopes DCTMK fix, import parameters Use xASL_adm_UnixPath() for Unix system calls, for correct path usage (e.g. for spaces that need escaping) Double escaping of backslashes in converting .m to .json for DataPar file - subject-regexp Compilation path error Correctly concatenate numbers when xASL_num2str Improvements xASL_adm_LoadParms for converting parameters ASL flavors to BIDS/ExploreASL internally Features New startup option for starting ExploreASL, loading data, without processing data Shortcut ExploreASL for ExploreASL_Master Now we have xASL_csvWrite, xASL_csvRead, xASL_tsvRead, xASL_tsvWrite xASL_io_Nifti2Im now detects erroneously extreme high scaling (potential import issue with Philips RescaleSlope) issues a warning and/or tries to fix automatically for FLAIR/T1w images Work in progress Docu Crawler for automatic documentation creation ExploreASL_Import for different ASL flavors BIDS implementation import Documentation create new prefix for visualization functions ( xASL_vis\\_\\* instead of xASL_im\\_\\* ) revamp quantification functions for better headers, comments etc ExploreASL v1.1.3 Bug Fixes hotfix minor bug in running the import using DCMTK without the Matlab Image Processing Toolbox #30 ExploreASL v1.1.2 Bug Fixes hotfix minor bug in loading NIfTIs containing lesion masks in CAT12 #28 ExploreASL v1.1.1 Bug Fixes hotfix minor bug in creating participants.tsv #23 ExploreASL v1.1.0 Versions included software Versions included & used third-party tools (see /External/README_SPM.txt ): SPM12 7219 CAT12 r1615 LST 2.0.15 Bug Fixes Bug fixes and overall code improvements related to the BIDS import workflow (#11) Registration with poor CBF contrast will not issue an error anymore but correctly switch to control-T1w registration only (#17) Unexisting x.Sequence field fixed, now an appropriate warning is issued and this field is defined automatically by xASL_adm_DefineASLSequence.m (#16) Features Quantification can now be fully disabled by: x.ApplyQuantification = [0 0 0 0 0]; (#14) Insert option to disable M0-ASL registration (#13) Update of CAT (Computational Anatomy Toolbox) from version 12.5 to 12.7 (#2) Work in progress Minor improvements of custom scripts for BBB-ASL and BIDS (#8) Minor improvements regarding unit testing of ExploreASL (#10) Additional warnings for ExploreASL users (#12) Documentation Recent changes include the improvement of the documentation within the ExploreASL structure using markdown files and the introduction of a new documentation repository (#7) Some function headers were added for increased understandability (#19). These can be viewed in Matlab by: help ExploreASL_Master where you can replace ExploreASL_Master by the actual function name ExploreASL v1.0.0 This is the first release version. Versions included software Versions included & used third-party tools (see /External/README_SPM.txt): SPM12 7219 CAT12 r1363 LST 2.0.15","title":"Change Log"},{"location":"Changes/#exploreasl-change-log","text":"","title":"ExploreASL Change Log"},{"location":"Changes/#exploreasl-v170","text":"","title":"ExploreASL v1.7.0"},{"location":"Changes/#versions-included-software","text":"Versions included & used third-party tools (see /External/README_SPM.txt ): SPM12 7219 CAT12 r1615 LST 2.0.15","title":"Versions included software"},{"location":"Changes/#feature-improvements","text":"Issue #455: Automatically compare results of TestDataSets with a saved reference results Issues #480, #623, #649, #661: Restructure x : x.opts (input arguments and their derivatives), x.dir (directories), x.settings (mostly booleans for pipeline settings), x.dataset (dataset related fields), x.external , ... Issue #572: Restructure JSON handling during NiFTI to BIDS import Issue #580: Add parsing of Gold Standard Phantoms ASL-DRO Issues #588, #612: ExploreASL reads folders and automatically searches for sourceStructure , studyPar and dataPar JSON files Issue #600: Put participants.tsv to the derivatives folder during import to legacy ExploreASL format Issue #602: Remove option for cloning the NIfTI output after import as BIDS directory is a read-only archive Issue #603: Give ExploreASL version in JSON files after BIDS to Legacy conversion Issue #631: Remove repeated warnings Issue #632: Add comparison script for untouched NIfTI comparison Issue #643: bids.layout : avoid printing the same warning repetitively in case multiple scans in a data set have the same issue Issue #656: Improve warnings (data loading)","title":"Feature improvements"},{"location":"Changes/#bug-fixes","text":"Issue #583: Proper testing of flavors using ExploreASL_Master Issue #584: Print the subject name depending on the existence of its definition in x.SUBJECT to avoid crashes for error reporting in the population module Issue #586: Avoid crashing xASL_adm_GetPopulationSessions if no sessions are found Issue #591: MultiTE import puts TE before PLD in the time series and corrects the JSON output Issue #618: Add session name to all M0Check and ASLCheck QC files in the Population folder Issue #620: xASL_adm_GzipAllFiles : Allow spaces in an input path for macOS/Linux Issue #625: Fix bug related to session format Issue #627: Remove a BIDS fiels and BIDS2Legacy should crash and show you why it crashed Issue #628: Fix parsing sessions and runs for converting rawdata to derivatives Issue #630: Move creation of population folder Issue #646: Improve BIDS warnings Issue #652: xASL_vis_CreateVisualFig : allow empty overlays Issue #659: xASL_stat_PrintStats : Fix visits bug (legacy format) Issue #655: xASL_adm_GetPopulationSessions gave incorrect warnings Issue #666: Warning when multiple dataPar*.json or studyPar*.json or sourcestructure*.json are present Issue #670: Fix warnings and behavior of ExploreASL_Initialize","title":"Bug fixes"},{"location":"Changes/#other-improvements","text":"Issue #465: Add projects to acknowledgments Issue #615: Add change log to documentation Issue #637: Restyle ExploreASL change log","title":"Other improvements"},{"location":"Changes/#exploreasl-v162","text":"","title":"ExploreASL v1.6.2"},{"location":"Changes/#bug-fixes_1","text":"Issue #589 Fix scaling issues in JSONs in TestDataSet/derivatives","title":"Bug Fixes"},{"location":"Changes/#exploreasl-v161","text":"","title":"ExploreASL v1.6.1"},{"location":"Changes/#bug-fixes_2","text":"Issue #578 Fix incorrect path searching by providing error if no .json-file is inputted","title":"Bug Fixes"},{"location":"Changes/#exploreasl-v160","text":"","title":"ExploreASL v1.6.0"},{"location":"Changes/#versions-included-software_1","text":"Versions included & used third-party tools (see /External/README_SPM.txt ): SPM12 7219 CAT12 r1615 LST 2.0.15","title":"Versions included software"},{"location":"Changes/#feature-improvements-still-backward-compatible","text":"Issues #62, #266, #449: JSON i/o unify and use spm_jsonread and spm_jsonwrite for all operations Issue #349: Improve screenprint of the current subjects/sessions/modules by xASL_Iteration Issue #384: Add method to export image matrices as structured points in VTK format Issue #523: Update ExploreASL_ImportConfig to work with JSONs and add alert for users Issue #538: Function to user-replace label values in atlas NIfTI, written for the CICERO study Issue #559: Add option x.MakeNIfTI4DICOM to create CBF optimized for DICOM creation/PACS export","title":"Feature improvements (still backward compatible)"},{"location":"Changes/#work-in-progress","text":"","title":"Work in progress"},{"location":"Changes/#basil","text":"Issue #20: Data pre-processing prepared for BASIL Issue #391: Add single-PLD model for BASIL","title":"BASIL"},{"location":"Changes/#asl-bids","text":"Issues #290,#483,#484: Initial version of the ASL-BIDS import workflow Issue #353: Correct conversion BIDS->Legacy for M0 with reversed PE direction Issues #394,#514,#545: Improve modularity of the ASL-BIDS import module Issue #411: Delete temporary folders in DICOM->BIDS conversion Issue #421: Use ImageType DICOM field to detect scan order in GE in DICOM->BIDS import Issue #426: Reading PLD from DICOM for GE in import to BIDS Issue #479: ASL-BIDS import for Hadamard encoded FME sequences","title":"ASL-BIDS"},{"location":"Changes/#dro-and-qasper","text":"Issues #361,#443: Import and import test of DRO Issues #467: Improve script to generate ASL-BIDS version of ASL DRO v2.2.0","title":"DRO and QASPER"},{"location":"Changes/#compilationstand-alone-version","text":"","title":"Compilation/stand-alone version"},{"location":"Changes/#bug-fixes_3","text":"Issue #184: Skip PVC in Population statistics, when this does not make sense for a given ROI Issue #262: Improve GZIP on windows Issue #341: Reduce extensive usage of ExploreASL CLI progress tracker Issue #368: Fix problem with writing trailing zeros in real numbers in spm_jsonwrite Issue #387: Remove graphical waitbar interface from xASL_im_ResampleLinearFair Issue #415: xASL_Copy: Allow recursive copying of directories Issue #418: Verifies the SliceTiming parameter if timing difference is consistent between slices Issue #424,#454: Remove string and contains functions to ensure Matlab compatibility for R2016 Issue #430: Fix xASL_adm_ReplaceSymbols crash when trying to replace sub-strings in PhoenixProtocol field Issues #433,#474,#542: Splitting of ASL and M0 - fix on rerun, split metadata, backup aslcontext.tsv Issue #451: Clean unused code and cleaned the development directory Issue #466: Warning if the equal sign is used in JSON files instead of colon Issue #475: Fix error with studies that have a special character in their name Issue #477: Change vascular territory atlases file extensions to .nii.gz Issue #496: Fixed session numbers in population module Issue #502: Fix smoothing of 4D NIfTIs Issue #505: Allow Token Aliases in import to be row vectors in import Issue #518: ExploreASL logo and verbose overview shown only once in a single pipeline run Issue #520: Stop import workflow from creating Population folder in root directory Issue #543: Minor fix of xASL_num2str behavior Issue #563: Minor design fix for ExploreASL dataset initialization","title":"Bug Fixes"},{"location":"Changes/#documentation","text":"Issues #403,#423,#457: Improved inline comments and headers Issue #452: Provide descriptions of available atlas options Issue #463: Remove remaining markdown file to a separate Documentation repository Issues #486,#489: Introduce document templates for GitHub QC Workflow Issue #499: Make heading in documentation work in dark mode as well Issue #515: Added tutorials to documentation Issue #536: Create a first version of the QC walkthrough document in markdown","title":"Documentation"},{"location":"Changes/#testing","text":"Issue #156: Make internal error messages more specific by providing subject information Issue #352: Improve parsing of errors and warnings from log files Issue #395,#416: Improve testing of BIDS import Issue #517: Improve unit testing scripts Issue #529: TestDataSet is in BIDS derivatives format Issue #570: Release testing and minor documentation improvements","title":"Testing"},{"location":"Changes/#exploreasl-v151","text":"","title":"ExploreASL v1.5.1"},{"location":"Changes/#bug-fixes_4","text":"Issue #439 Fix population module error by correctly renaming MNI_Structural.* files","title":"Bug Fixes"},{"location":"Changes/#exploreasl-v150","text":"","title":"ExploreASL v1.5.0"},{"location":"Changes/#versions-included-software_2","text":"Versions included & used third-party tools (see /External/README_SPM.txt ): SPM12 7219 CAT12 r1615 LST 2.0.15","title":"Versions included software"},{"location":"Changes/#feature-improvements-still-backward-compatible_1","text":"Issue #39: Create PV-corrected GM & WM CBF maps in native space Issue #56,#410: Add Mindboggle atlas to ExploreASL and restructure general atlas access in population module Issue #283: xASL_stat_GetROIstatistics provide more feedback on missing images Issue #299: Move CustomScripts with study-specific scripts to a separate repository Issue #302: Remove server calls in CAT12 functions Issue #313: Move GUI to a separate repository Issue #351: T2 and T1c files are now also aligned to the T1w and outputted to standard space Issue #354: Added an option x.DummyScanPositionInASL4D that removes marked dummy scans when splitting ASL to ASL+M0+dummy Issues #356,#396,#397: Internally restructure SliceTime allowing ExploreASL now to work with multi-band 2D EPI as well or any other SliceTime order","title":"Feature improvements (still backward compatible)"},{"location":"Changes/#work-in-progress_1","text":"","title":"Work in progress"},{"location":"Changes/#asl-bids_1","text":"Issues #163,#189,#357,#373: Conversion from DICOM to BIDS Issues #334,#382: Import of PAR-REC to BIDS Issue #343: Add separate M0 option to mTrial import","title":"ASL-BIDS"},{"location":"Changes/#compilationstand-alone-version_1","text":"Issue #335: All input arguments can be passed in the deployed mode Issue #380: Enable advanced input parsing for xASL compiled","title":"Compilation/stand-alone version"},{"location":"Changes/#bug-fixes_5","text":"Issue #228: Fix CAT12 warnings with non-existent field cm Issue #272: Fix errors in JSON import of ASL sidecars Issues #273,#285,#291,#363: Minor fixes in input parameter administration Issues #276,#280,#288,#329,#400: Fix error in reading TSV files with unclear number of columns Issue #282: Population module is run serially in otherwise parallel mode Issue #292: xASL_qc_SortBySpatialCoV now use all subjects without skipping Issue #305: xASL_adm_UnixPath : bug with Windows+WSL Issues #306,#378: Fix JSON reading with 'i' interpreted as a complex number Issue #309: Fix non-linear registration of T1w to standard space with too high T1w values Issue #312: xASL_stat_GetROIstatistics fix skipping of actual ROI extraction Issue #325: xASL_adm_CleanUpBeforeRerun delete files correctly Issue #339: Fix JSON reading of special characters Issue #399: Fix special characters in Windows filenames Issue #405: Fix range-check error in Background Suppression timing calculation Issue #406: Fix xASL_stat_MedianNan for all-NaN input Issues #408,#409: Skip missing fields in CAT during reports in compiled ExploreASL","title":"Bug Fixes"},{"location":"Changes/#documentation_1","text":"Issue #7: Create README files in subfolders and added to interactive documentation Issues #279, #345: Move documentation to a separate repository Issues #300,#318: Improve ExploreASL tutorial Issue #355: Documentation improvements regarding input parameters","title":"Documentation"},{"location":"Changes/#testing_1","text":"Issues #193,#350,#398: Testing DICOM to BIDS conversion against a reference Issue #294: Implement initial unit testing framework Issue #326: Parse warnings/errors from all log in all subdirectories Issue #369: Unit testing of xASL_test_getLogContent Issues #371,#376,#404: Testing script for the DICOM->BIDS->Legacy conversion and processing","title":"Testing"},{"location":"Changes/#exploreasl-v140","text":"","title":"ExploreASL v1.4.0"},{"location":"Changes/#versions-included-software_3","text":"Versions included & used third-party tools (see /External/README_SPM.txt): SPM12 7219 CAT12 r1615 LST 2.0.15","title":"Versions included software"},{"location":"Changes/#feature-improvements-still-backward-compatible_2","text":"Issue #20 Implement BASIL -> changed order quantification/masking, and always save resampled PWI4D for quantification, facilitating BASIL Issue #35 Calculation background suppression efficiency for pseudo-M0 -> in case of missing separate M0 images but still using background suppressed mean control as pseudo-M0, a single correction value (3D) or slice-wise correction value (2D) are applied to the pseudo-M0 image/slices Issue #131 ExploreASL_GUI beta-testing enhancements set 1 -> Aesthetic improvements in certain modules, fixed incorrect removal of Philips-related json-sidecar fields in DCM2BIDS / Import module. Correction of ASL image flickering bug and ability for the user to subset without having to reload the data. Added ability to clarify data type of variables without the need to reload data. Added auto-select / auto-complete functionality in the ParmsMaker module as soon as the user indicates an analysis directory (i.e auto-completion of SliceReadoutTime for pCASL) Issue #166 Update ADNI import in ExploreASL_Import Issue #179 Finish creation average maps for CICERO -> improvements xASL_wrp_CreatePopulationTemplates Issue #190 Hammers atlas option CAT12 -> restored the original Hammers atlas option for a colleague (note it's license though!) Issue #225 Create DataPar option for running SPM12 longitudinal registration Issue #241 Add warning when loading data without x output structure Issue #243 Shorten SPM initialization time -> removed configuration loading of unused toolboxes (check if the SPM DICOM import module is still needed)","title":"Feature improvements (still backward compatible)"},{"location":"Changes/#work-in-progress_2","text":"","title":"Work in progress"},{"location":"Changes/#asl-bids_2","text":"Issue #193 Comparing BIDS folders (for testing purpose) Issue #226 Add new DICOM tags to DCMTK import","title":"ASL-BIDS"},{"location":"Changes/#bug-fixes_6","text":"Issue #191 WMH warning when no FLAIR analyzed -> this warning is now removed if no FLAIR was present in the data Issue #248 Temporary fix native space processing -> in Population module Issue #252 Population modules analysis masks - minor errors Issue #267 Error in reading JSONs from EPAD","title":"Bug Fixes"},{"location":"Changes/#documentation_2","text":"Issue #196 All contributors -> all contributors are now automatically added to the main README.md Issue #217 Documentation improvements Issue #219 Add user to documentation","title":"Documentation"},{"location":"Changes/#exploreasl-v130","text":"","title":"ExploreASL v1.3.0"},{"location":"Changes/#versions-included-software_4","text":"Versions included & used third-party tools (see /External/README_SPM.txt): SPM12 7219 CAT12 r1615 LST 2.0.15","title":"Versions included software"},{"location":"Changes/#feature-improvements-still-backward-compatible_3","text":"Issue #59: Assign \"weights\" to status files, allowing the external Python ExploreASL GUI to provide a better estimate of the progress Issue #71 Remove custom lesions (Lesion\\_(FLAIR|T1)\\_\\\\d\\\\.nii) from WMH_SEGM.nii Issue #76: Improve functionality of ExploreASL through Command Line Interface (CLI), i.e. without using the Graphical User Interface (GUI) of Matlab Issue #123 Create status files also for skipped processing parts: this is mainly the case for running the structural module without a FLAIR scan. Having all status files helps third-party tools such as the Python ExploreASL GUI to know that processing has succesfully completed (duplicate issues #137 and #129) The same was done for the ASL realignment status file, in case realignment is skipped for a 3D scan Issue #145: Improve .nii(.gz) management in xASL_spm_deformations : allow either .nii or .nii.gz as input, treat them equally, and when .nii.gz is provided as output path, zip the resulting deformed image","title":"Feature improvements (still backward compatible)"},{"location":"Changes/#work-in-progress_3","text":"Issue #32 Docker integration Issue #55 ExploreASL GUI, written in Python Issue #106 xASL_im_SplitImageLabels : Allow splitting labels, and warping them to standard space. This is part of a continuous development on creating average flow territory templates and figures. Issue #162 Remove bNativeSpaceProcessing from TestDataSet for now, return this when bNativeSpaceProcess is made more modular","title":"Work in progress"},{"location":"Changes/#asl-bids_3","text":"Issue #82 Avoid 4D files with nT==1, which is not allowed in the BIDS validator","title":"ASL-BIDS"},{"location":"Changes/#compilationstand-alone-version_2","text":"Issue #88 xASL_SysMove error in Windows when a path includes whitespaces ' '","title":"Compilation/stand-alone version"},{"location":"Changes/#bug-fixes_7","text":"Issue #85 Improvement ApplyQuantification Issue #99 Improve loading of metadata ( xASL_str2num & xASL_init_LoadMetaData ) Issue #105 In case of missing data, fill x.S.SUBJECTID and S.DAT data for the last subject/session Issue #119 Create status file for last subject, if it's processing is skipped Issue #120 xASL_im_CreateAnalysisMask in native space mode when in parallel execution Issue #138 Fix structure TestDataJSON & its JSON files Issue #139 Ensure that x fields are not case sensitive, by e.g. replacing strcmp by strcmpi Issue #141 Solve conflicts between develop and master, these were minor edits that weren't implemented in develop yet Issue #143 ensure that VBA masks are also created for a 3D spiral sequence (this was not created yet as the susceptibility masks were missing for this sequence) Issue #148 Syncing the ROI/lesion processing of T1w & FLAIR Issue #151 Minor bugfixes for TopUp Issue #177 Fix xASL_adm_UnzipNifti & xASL_io_SaveNifti when path is incomplete Skip warnings for small populations (in the start of xASL_module_Population ) Fix regular expression in xASL_init_LoadMetaData iRow counting fix in xASL_bids_Add2ParticipantsTSV","title":"Bug Fixes"},{"location":"Changes/#documentation_3","text":"Issue #7 Documentation/revamp xASL_im_ClipExtremes Issue #159 Ensure that all sequence notations use underscores instead of whitespace, e.g. 3D_spiral instead of 3D spiral","title":"Documentation"},{"location":"Changes/#testing_2","text":"Issue #86 xASL_qc_TestExploreASL : improve Table creation Issue #112 Save Tanimoto Coefficient (i.e. a fuzzy overlap/Dice score) of the final ASL-T1w registration Issue #128 Improved one internal test dataset Issue #130 xASL_qc_TestExploreASL : Complete functionality by allowing Windows parallelization & testing the Windows ExploreASL compilation. Also added unit testing framework in the same issue.","title":"Testing"},{"location":"Changes/#exploreasl-v122","text":"","title":"ExploreASL v1.2.2"},{"location":"Changes/#bug-fixes_8","text":"Issue #119 xASL_wrp_LinearReg_T1w2MNI.m: ROI .nii files correctly aligned with T1","title":"Bug Fixes"},{"location":"Changes/#exploreasl-v121","text":"","title":"ExploreASL v1.2.1"},{"location":"Changes/#bug-fixes_9","text":"xASL_qc_TestExploreASL: Remove locked folders if rerun Issue #90 xASL_io_Nifti2Im : manage the detection of odd scaling Issue #93 xASL_SysMove : diz illegal symbols Windows Issue #102 xASL_wrp_CreatePopulationTemplates : minor bugfix Issue #104 Fix creation ResultsTable for TestCases (also #86) Issue #114 Acquiring Matlab version doesn't crash anymore in deployed mode Issue #115 Fixing NaNs problem in M0 mask computation Issue #118 xASL_adm_GzipAllFiles doesn't crash anymore in Windows Issue #116 ExploreASL testing fixes: Edit header of saved .tsv-file Cosmetic changes\\nUnzip before SPM Clear variables before loading .mat Replace spaces in headers with underscores (which happened automatically apparently upon saving) Remove SPM cellstring","title":"Bug Fixes"},{"location":"Changes/#asl-bids-related-bug-fixes","text":"Issue #96 Fix order of magnitude in JSON sidecars Issue #109 No warning if SliceReadoutTime not provided in DataPar Issue #110 xASL_bids_parms2BIDS.m now deals correctly with vectors and SliceReadoutTime = 'shortestTR' : created function for this: xASL_quant_SliceReadoutTime_Shortest_TR","title":"ASL-BIDS-related bug fixes"},{"location":"Changes/#exploreasl-v120","text":"","title":"ExploreASL v1.2.0"},{"location":"Changes/#versions-included-software_5","text":"Versions included & used third-party tools (see /External/README_SPM.txt): SPM12 7219 CAT12 r1615 LST 2.0.15","title":"Versions included software"},{"location":"Changes/#major-feature-improvements-still-backward-compatible","text":"Add user flexibility for creating average maps, allowing flipping Provide a lesion or ROI mask, to be used not only for cost function masking but also as standard space ROI for ROI-analysis This use is now easier, by simply adding Lesion_FLAIR_1.nii or Lesion_T1_2.nii etc, and visualization improved. These masks are now automatically created (where lesion can be any other ROI): Intralesional Perilesional, pGM+pWM Hemisphere (ipsilateral to lesion) Contralateral (i) Contralateral (ii) Contralateral (iii) Option x.S.bMasking added, allowing specifying masking separately for: bSusceptibilityMask bVascularMask subject-wise bGMMask (e.g. the pGM>0.7 ) brainmasking when loading for lower memory usage Affine registration improved & Discrete Cosine Transform (DCT) non-linear registration option added, including an option with partial volume correction built-in for improved DCT-based registration","title":"Major feature improvements (still backward compatible)"},{"location":"Changes/#bug-fixes_10","text":"Allow zipping in Unix-based OS without JavaVirtualMachine Quantification issue with Philips scale slopes DCTMK fix, import parameters Use xASL_adm_UnixPath() for Unix system calls, for correct path usage (e.g. for spaces that need escaping) Double escaping of backslashes in converting .m to .json for DataPar file - subject-regexp Compilation path error Correctly concatenate numbers when xASL_num2str Improvements xASL_adm_LoadParms for converting parameters ASL flavors to BIDS/ExploreASL internally","title":"Bug Fixes"},{"location":"Changes/#features","text":"New startup option for starting ExploreASL, loading data, without processing data Shortcut ExploreASL for ExploreASL_Master Now we have xASL_csvWrite, xASL_csvRead, xASL_tsvRead, xASL_tsvWrite xASL_io_Nifti2Im now detects erroneously extreme high scaling (potential import issue with Philips RescaleSlope) issues a warning and/or tries to fix automatically for FLAIR/T1w images","title":"Features"},{"location":"Changes/#work-in-progress_4","text":"Docu Crawler for automatic documentation creation ExploreASL_Import for different ASL flavors BIDS implementation import","title":"Work in progress"},{"location":"Changes/#documentation_4","text":"create new prefix for visualization functions ( xASL_vis\\_\\* instead of xASL_im\\_\\* ) revamp quantification functions for better headers, comments etc","title":"Documentation"},{"location":"Changes/#exploreasl-v113","text":"","title":"ExploreASL v1.1.3"},{"location":"Changes/#bug-fixes_11","text":"hotfix minor bug in running the import using DCMTK without the Matlab Image Processing Toolbox #30","title":"Bug Fixes"},{"location":"Changes/#exploreasl-v112","text":"","title":"ExploreASL v1.1.2"},{"location":"Changes/#bug-fixes_12","text":"hotfix minor bug in loading NIfTIs containing lesion masks in CAT12 #28","title":"Bug Fixes"},{"location":"Changes/#exploreasl-v111","text":"","title":"ExploreASL v1.1.1"},{"location":"Changes/#bug-fixes_13","text":"hotfix minor bug in creating participants.tsv #23","title":"Bug Fixes"},{"location":"Changes/#exploreasl-v110","text":"","title":"ExploreASL v1.1.0"},{"location":"Changes/#versions-included-software_6","text":"Versions included & used third-party tools (see /External/README_SPM.txt ): SPM12 7219 CAT12 r1615 LST 2.0.15","title":"Versions included software"},{"location":"Changes/#bug-fixes_14","text":"Bug fixes and overall code improvements related to the BIDS import workflow (#11) Registration with poor CBF contrast will not issue an error anymore but correctly switch to control-T1w registration only (#17) Unexisting x.Sequence field fixed, now an appropriate warning is issued and this field is defined automatically by xASL_adm_DefineASLSequence.m (#16)","title":"Bug Fixes"},{"location":"Changes/#features_1","text":"Quantification can now be fully disabled by: x.ApplyQuantification = [0 0 0 0 0]; (#14) Insert option to disable M0-ASL registration (#13) Update of CAT (Computational Anatomy Toolbox) from version 12.5 to 12.7 (#2)","title":"Features"},{"location":"Changes/#work-in-progress_5","text":"Minor improvements of custom scripts for BBB-ASL and BIDS (#8) Minor improvements regarding unit testing of ExploreASL (#10) Additional warnings for ExploreASL users (#12)","title":"Work in progress"},{"location":"Changes/#documentation_5","text":"Recent changes include the improvement of the documentation within the ExploreASL structure using markdown files and the introduction of a new documentation repository (#7) Some function headers were added for increased understandability (#19). These can be viewed in Matlab by: help ExploreASL_Master where you can replace ExploreASL_Master by the actual function name","title":"Documentation"},{"location":"Changes/#exploreasl-v100","text":"This is the first release version.","title":"ExploreASL v1.0.0"},{"location":"Changes/#versions-included-software_7","text":"Versions included & used third-party tools (see /External/README_SPM.txt): SPM12 7219 CAT12 r1363 LST 2.0.15","title":"Versions included software"},{"location":"DataParTemplate/","text":"DataParTemplate Template for study-specific parameter tables This template provides an overview of the table of parameters used by ExploreASL, which is very specific to the study to be processed. Most of it is ASL quantification-related, some of it are image processing parameters also applicable to the structural module. It allows only for minimal pipeline modifications (e.g. x.settings.Quality , x.settings.DELETETEMP ) as most of the ExploreASL environment parameters are loaded through ExploreASL_Initialize.m . Here we list potential data parameters. Most are optional, and are ignored if not provided. For an example, see the DataPar*.json file(s) in the TestDataSet. For legacy reasons & ease of use, these can be set up in a DataPar*.m , which will be converted to the DataPar*.json per BIDS. The compiled version of ExploreASL only allows for JSON input. For the DataPar.json: Make sure that booleans are inputted as numbers (e.g. 1 or 0 ) and not as words (e.g. true or false ). Scalars can be inputted as scalars. For vectors/arrays of character arrays, we recommend to insert vectors of strings, e.g. [\"optionA\" \"optionB\"] instead of ['optionA', 'optionB'] . This is to allow for valid JSONs. The conversion is carried out internally. ENVIRONMENT PARAMETERS Description Defaults x.external.bAutomaticallyDetectFSL Boolean to automatically detect the FSL version if disabled, this function will try to use the system-initialized FSL and throw an error if FSL is not initialized. OPTIONAL, DEFAULT = disabled STUDY PARAMETERS Description Defaults x.D.ROOT Path to analysis root folder where data is stored, example: /home/hjmutsaerts/TestDataSet OPTIONAL, DEFAULT = pwd x.SESSIONS Use this to define sessions. Specific options: for FEAST: 1=crushed , 2=not crushed . This used to be other way around, but the crushed image registers better with the pGM image. Example ( '.json' file): [\"ASL_1\",\"ASL_2\"] OPTIONAL, DEFAULT = {'ASL_1'} x.session.options This is how the sessions will be called, example: {'baseline' 'drug'} . For FEAST, this should be {'non-crushed' 'crushed'} . OPTIONAL x.dataset.name String for the name of the study, example: AD-study OPTIONAL x.dataset.subjectRegexp String with regular expression for ExploreASL to find subjects by foldername, example: ^\\d{3}$ for three digits REQUIRED x.dataset.exclusion Cell with list of subjects to exclude, example: {'005' '018'} OPTIONAL, DEFAULT = empty x.dataset.ForceInclusionList Use this field if you want to use a selection of subjects rather than taking all available subjects from directories. Example: load(fullfile(x.D.ROOT,'LongitudinalList.mat') ). OPTIONAL, DEFAULT = use all subjects M0 PARAMETERS and OPTIONS Description Defaults x.Q.M0 Choose which M0 option to use: 'separate_scan' = for a separate M0 NIfTI (needs to be in the same folder called M0.nii ), 3.7394*10^6 = single M0 value to use, 'UseControlAsM0' = will copy the mean control image as M0.nii and process as if it was a separately acquired M0 image (taking TR etc from the ASL4D.nii ). Make sure that no background suppression was used, otherwise this option is invalid. REQUIRED x.modules.asl.M0_conventionalProcessing Boolean - use the conventional M0 processing (per consensus paper), options: 1 = standard processing, 0 = new image processing (improved masking & smoothing). OPTIONAL, DEFAULT = 0 x.modules.asl.M0_GMScaleFactor Add additional scale factor to multiply the M0 image by This can be useful when you have background suppression but no control/M0 image without background suppression. If you then know the M0 scalefactor for the GM, you can use the control image as M0 and use this parameter to scale back what was suppressed by background suppression. Note that there is no option for separate tissue scaling (e.g. WM & GM), because ExploreASL pragmatically smooths the M0 a lot, assuming that head motion and registration between M0 & ASL4D will differ between patients and controls. OPTIONAL, default = 1 x.modules.asl.M0PositionInASL4D A vector of integers that indicates the position of M0 in TimeSeries, if it is integrated by the Vendor in the DICOM export. Will move this from ASL4D.nii to M0.nii Note that the x.modules.asl.M0PositionInASL4D parameter is independent from the x.Q.M0 parameter choice. Example for Philips 3D GRASE = '[1 2]' (first control-label pair). Example for Siemens 3D GRASE = 1 first image. Example for GE 3D spiral = 2 where first image is PWI & last = M0. Empty vector should be given (= [] or = null (in JSON)) if no action is to be taken and nothing is removed. OPTIONAL, DEFAULT = [] (no M0 in timeseries) x.modules.asl.DummyScanPositionInASL4D A vector of integers that indicates the position of Dummy scans in TimeSeries if they are integrated by the Vendor in the DICOM export. This allows to remove the dummy scans or noise scans that are part of the Timeseries. A new ASL4D.nii is saved with dummy scans removed and the original is backed-up. Works in a similar way as M0PositionInASL4D, both can be entered at the same time and both indicate the original position in the Timeseries independend of each other. Example for Siemens 2D EPI = [79 80] Skip the control-label pair used for noise measurements. Example for certain Siemens 3D GRASE = 2 Skip the first dummy control image. Empty vector should be given (= [] or = null (in JSON)) if no action is to be taken and nothing is removed. OPTIONAL, DEFAULT = [] (no M0 in timeseries) SEQUENCE PARAMETERS Description Defaults x.Q.BackgroundSuppressionNumberPulses Used to estimate decrease of labeling efficiency. Options: 0 = (no background suppression), 2 = labeling efficiency factor 0.83 (e.g. Philips 2D EPI & Siemens 3D GRASE), 4 = labeling efficiency factor 0.81 (e.g. Philips 3D GRASE), 5 = labeling efficiency factor 0.75 (e.g. GE 3D spiral). REQUIRED x.Q.BackgroundSuppressionPulseTime Vector containing timing, in ms, of the background suppression pulses before the start of the readout (per BIDS). REQUIRED when x.Q.UseControlAsM0 & x.Q.BackgroundSuppressionNumberPulses>0 x.Q.PresaturationTime Time in ms before the start of the readout, scalar, when the slice has been saturated (90 degree flip) this has to come before all the bSup pulses, but doesn't need to be always specified. OPTIONAL, defaults to PLD (PASL) or PLD+LabDur ((P)CASL) x.Q.readoutDim String specifying the readout type. Options: '2D' for slice-wise readout, '3D' for volumetric readout. REQUIRED x.Q.Vendor String containing the Vendor used. This parameter is used to apply the Vendor-specific scale factors, options: 'GE_product', 'GE_WIP', 'Philips', 'Siemens'. REQUIRED for ASL x.Q.Sequence String containing the sequence used. Options: '3D_spiral', '3D_GRASE', '2D_EPI' . REQUIRED for ASL x.Q.LabelingType String containing the labeling strategy used. Options: 'PASL' (pulsed Q2-TIPS), 'CASL' (CASL/PCASL). Note: pulsed without Q2TIPS cannot be reliably quantified because the bolus width cannot be identified CASL & PCASL are both continuous ASL methods, identical quantification. REQUIRED for ASL x.Q.Initial_PLD Value of PLD (ms), for 3D this is fixed for whole brain, for 2D this is the PLD of first acquired slice, example: 1800. REQUIRED for ASL x.Q.LabelingDuration Value of labeling duration (ms), example: 1800. REQUIRED for ASL x.Q.SliceReadoutTime Value (ms) of time added to the PLD after reading out each slice, example: 31. Other option = 'shortestTR' ; shortest TR enabled gives each sequence the minimal TR. This enables calculating slice delay per subject. REQUIRED for 2D ASL sequences QUANTIFICATION PARAMETERS Description Defaults x.Q.bUseBasilQuantification True for using BASIL quantification in addition to ExploreASL's quantification. x.Q.Lambda Brain/blood water coefficient (mL 1H/ mL blood). Example: 0.32 (for GSP phantom). OPTIONAL, DEFAULT = 0.9 x.Q.T2art T2* of arterial blood at 3T, only used when no M0 image (ms). OPTIONAL, DEFAULT = 50 x.Q.BloodT1 T1 relaxation time of arterial blood (ms). Defaults (Alsop MRM 2014), 1800 for GSP phantom. OPTIONAL, DEFAULT = 1650 @ 3T, 1350 @ 1.5 T x.Q.TissueT1 T1 relaxation time of GM tissue (ms). Defaults (Alsop MRM 2014). OPTIONAL, DEFAULT=1240 @ 3T, 920 @ 1.5 T x.Q.nCompartments Number of modeled compartments for quantification. Options: 1 = a single-compartment quantification model (default by concensus paper), 2 = a dual-compartment quantification model. OPTIONAL, DEFAULT = 1) x.Q.ApplyQuantification A vector of 1x5 logical values specifying which types on quantified images should be calculated and saved. Fields: 1) Apply ScaleSlopes ASL4D (xASL_wrp_Quantify, future at dcm2niiX stage), 2) Apply ScaleSlopes M0 (xASL_quant_M0, future at dcm2niiX stage), 3) Convert PWI a.u. to label (xASL_wrp_Quantify, future at xASL_wrp_Reslice?), 4) Quantify M0 a.u. (xASL_quant_M0, corrects for incomplete T1 relaxation), 5) Perform division by M0. Examples: ASL4D is an already quantified CBF image, disable all quantification '[0 0 0 0 0]' . To compare label but not CBF (e.g. label in vessels or sinus vs tissue): [1 1 1 1 0]' . Note that the output always goes to CBF.nii. OPTIONAL, DEFAULT = '[1 1 1 1 1]' = all enabled x.Q.SaveCBF4D Boolean, true to also save 4D CBF timeseries, if ASL4D had timeseries. OPTIONAL, DEFAULT=false GENERAL PROCESSING PARAMETERS Description Defaults x.settings.Quality Boolean specifying on which quality the pipeline should be run, options: 1 = normal quality, 0 = lower quality, fewer iterations and lower resolution of processing for a fast try-out. OPTIONAL, DEFAULT = 1 x.settings.DELETETEMP Boolean for removing the temporary files. Options: 0 = keeping all files, 1 = delete temporary files created by the pipeline. OPTIONAL, DEFAULT = 1 x.settings.SkipIfNoFlair Boolean to skip processing of subjects that do not have a FLAIR image. These parameters can be useful when some data is still complete, but one would like to start image processing already. Options: 1 = skip processing of a subject that does not have a FLAIR image 0 = do not skip anything. OPTIONAL, DEFAULT = 0 x.settings.SkipIfNoASL Boolean to skip processing of subjects that do not have a ASL image. Options: 1 = skip processing of a subject that does not have a ASL image, 0 = do not skip anything. OPTIONAL, DEFAULT = 0 x.settings.SkipIfNoM0 Boolean to skip processing of subjects that do not have a M0 image. Options: 1 = skip processing of a subject that does not have a M0 image, 0 = do not skip anything. OPTIONAL, DEFAULT = 0 STRUCTURAL PROCESSING PARAMETERS Description Defaults x.modules.bRunLongReg Run longitudinal registration. OPTIONAL, DEFAULT = 0 x.modules.bRunDARTEL Run between-subject registration/create templates. OPTIONAL, DEFAULT = 0 x.modules.structural.bSegmentSPM12 Boolean to specify if SPM12 segmentation is run instead of CAT12. Options: 1 = run SPM12, 0 = run CAT12. OPTIONAL, DEFAULT = 0 x.modules.structural.bHammersCAT12 Boolean specifying if CAT12 should provide Hammers volumetric ROI results. OPTIONAL, DEFAULT = 0 x.modules.structural.bFixResolution Resample to a resolution that CAT12 accepts. OPTIONAL, DEFAULT=false ASL PROCESSING PARAMETERS Description Defaults x.modules.asl.motionCorrection Boolean to perform motion correction in case of timeseries. Options: 1 = on, 0 = off. OPTIONAL, DEFAULT = 1 x.modules.asl.SpikeRemovalThreshold Minimal t-stat improval needed to remove motion spikes. Examples: 1 = effectively disabling spike removal. OPTIONAL, DEFAULT = 0.01 x.modules.asl.bRegistrationContrast Specifies the image contrast used for registration: 0 = Control->T1w, 1 = CBF->pseudoCBF from template/pGM+pWM (skip if sCoV>0.667), 2 = automatic (mix of both), 3 = option 2 & force CBF->pseudoCBF irrespective of sCoV. OPTIONAL, DEFAULT = 2 x.modules.asl.bAffineRegistration Specifies if the ASL-T1w rigid-body registration is followed up by an affine registration: 0 = affine registration disabled, 1 = affine registration enabled, 2 = affine registration automatically chosen based on spatial CoV of PWI. OPTIONAL, DEFAULT = 0 x.modules.asl.bDCTRegistration Specifies if to include the DCT registration on top of Affine, all other requirements for affine are thus also taken into account the x.modules.asl.bAffineRegistration must be >0 for DCT to run: 0 = DCT registration disabled 1 = DCT registration enabled if affine enabled and conditions for affine passed, 2 = DCT enabled as above, but use PVC on top of it to get the local intensity scaling right. OPTIONAL, DEFAULT = 0 x.modules.asl.bRegisterM02ASL Boolean specifying whether M0 is registered to mean_control image (or T1w if no control image exists). It can be useful to disable M0 registration if the ASL registration is done based on the M0, and little motion is expected between the M0 and ASL acquisition. If no separate M0 image is available, this parameter will have no effect. This option is disabled automatically for 3D spiral: 0 = M0 registration disabled, 1 = M0 registration enabled (DEFAULT). OPTIONAL, DEFAULT = 0 x.modules.asl.bUseMNIasDummyStructural When structural (e.g. T1w) data is missing, copy population-average MNI templates as dummy structural templates. With this option, the ASL module copies the structural templates to fool the pipeline, resulting in ASL registration to these templates. While the rigid-body parameters might still be found somewhat correctly, with this option it is advised to enable affine registration for ASL as well, since ASL and these dummy structural images will differ geometrically. When disabled, an error will be issued instead when the structural image are missing. 1 = enabled, 0 = disabled. OPTIONAL, DEFAULT = 0 x.modules.asl.bPVCNativeSpace Performs partial volume correction (PVC) in ASL native space using the GM and WM maps obtained from previously segmented T1-weighted images. Skipped with warning when those maps do not exist and are not resampled to the ASL space. PVC can take several minutes for larger scans (e.g. 128x128x30), so it is deactivated by default. 1 = enabled, 0 = disabled. OPTIONAL, DEFAULT = 0 x.modules.asl.PVCNativeSpaceKernel Kernel size for the ASL native space PVC. This is ignored when x.modules.asl.bPVCNativeSpace is set to 0. Equal weighting of all voxels within the kernel is assumed. 3D kernel can be used, but any of the dimension can be also set to 1. Only odd number of voxels can be used in each dimension (e.g. [3 7 5] not [2 3 1] ). OPTIONAL, DEFAULT = [5 5 1] for bPVCGaussianMM==0, [10 10 4] for bPVCGaussianMM==1 x.modules.asl.bPVCGaussianMM If set to 1, PV-correction with a Gaussian weighting is used instead of the equal weights of all voxels in the kernel ('flat' kernel) as per Asllani's original method. Ignored when x.modules.asl.bPVCNativeSpace is set to 0. Unlike with the flat kernel when the size is defined in voxels, here the FWHM of the Gaussian in mm is defined in each dimension. The advantage is twofold - continuous values can be added and a single value can be entered which is valid for datasets with different voxel-sizes without having a kernel of different effective size. 1 = enabled, use Gaussian kernel with FWHM in mm given in PVCNativeSpaceKernel, 0 = disabled, use 'flat' kernel with voxels given in PVCNativeSpaceKernel. OPTIONAL, DEFAULT = 0 x.modules.asl.bMakeNIfTI4DICOM Boolean to output CBF native space maps resampled and/or registered to the original T1w/ASL, and contrast adapted and in 12 bit range allowing to convert the NIfTI to a DICOM file, e.g. for implementation in PACS or other DICOM archives. If set to true, an additional CBF image will be created with modifications that allow it to be easily implemented back into a DICOM for e.g. PACS: 1. Remove peak & valley signal, remove NaNs, rescale to 12 bit integers, apply original orientation (2 copies saved, with original ASL and T1w orientation). MASKING & ATLAS PARAMETERS Description Defaults x.S.bMasking Vector specifying if we should mask a ROI with a subject-specific mask (1 = yes, 0 = no): [1 0 0 0] = susceptibility mask (either population-or subject-wise), [0 1 0 0] = vascular mask (only subject-wise), [0 0 1 0] = subject-specific tissue-masking (e.g. pGM>0.5), [0 0 0 1] = WholeBrain masking (used as memory compression) [0 0 0 0] = no masking at all, [1 1 1 1] = apply all masks, Can also be used as boolean, where 1 = [1 1 1 1] , 0 = [0 0 0 0] . Can be useful for e.g. loading lesion masks outside the GM. OPTIONAL, DEFAULT=1 x.S.Atlases Vector specifying the atlases which should be used within the population module. Default definition within the Population Module: x.S.Atlases = {'TotalGM','DeepWM'} . Available atlases (please check the atlas NIfTI and accompanying files for more information): Free atlases : TotalGM : Mask of the entire GM './External/SPMmodified/MapsAdded/TotalGM.nii' , TotalWM : Mask of the entire WM './External/SPMmodified/MapsAdded/TotalWM.nii' , DeepWM : Mask of the deep WM './External/SPMmodified/MapsAdded/DeepWM.nii' , WholeBrain : Mask of the entire brain './External/SPMmodified/MapsAdded/WholeBrain.nii' , MNI_Structural : MNI cortical atlas ' ./External/SPMmodified/MapsAdded/MNI_Structural.nii' , Tatu_ACA_MCA_PCA : Original vascular territories by Tatu et al. './External/SPMmodified/MapsAdded/VascularTerritories/CortVascTerritoriesTatu.nii.nii' , Tatu_ICA_PCA : Tatu - only ICA and PCA './External/SPMmodified/MapsAdded/VascularTerritories/TatuICA_PCA.nii' , Tatu_ICA_L_ICA_R_PCA : './External/SPMmodified/MapsAdded/VascularTerritories/LabelingTerritories.nii' , Tatu_ACA_MCA_PCA_Prox_Med_Dist : Tatu separated to distal/medial/proximal of ACA/MCA/PCA './External/SPMmodified/MapsAdded/VascularTerritories/ATTbasedFlowTerritories.nii.nii' , Mindboggle_OASIS_DKT31_CMA : Mindboggle-101 cortical atlas './External/Atlases/Mindboggle_OASIS_DKT31_CMA.nii.gz' . Free for non-commercial use only : HOcort_CONN : Harvard-Oxford cortical atlas './External/Atlases/HOcort_CONN.nii.gz' , HOsub_CONN : Harvard-Oxford subcortical atlas './External/Atlases/HOsub_CONN.nii.gz' , Hammers : Alexander Hammers's brain atlas './External/Atlases/Hammers.nii.gz' , HammersCAT12 : Hammers atlas adapted to DARTEL template of IXI550 space './External/Atlases/HammersCAT12.nii' , Thalamus : Harvad-Oxford thalamus atlas './External/Atlases/Thalamus.nii.gz' . OPTIONAL, DEFAULT= {'TotalGM','DeepWM'} Matlab structure example To create the JSON file of this matlab structure, you can use spm_jsonwrite() . x.dataset.name = ExampleDataSet; x.dataset.subjectRegexp = '^Sub-\\d{3}$'; x.Q.readoutDim = '2D'; x.Q.Vendor = 'Philips'; x.Q.BackgroundSuppressionNumberPulses = 2; x.Q.LabelingType = 'CASL'; x.Q.Initial_PLD = 1525; x.Q.LabelingDuration = 1650; x.Q.SliceReadoutTime = 43.7647; x.Q.M0 = 'separate_scan'; x.settings.Quality = 0; x.settings.DELETETEMP = 1; x.modules.asl.M0PositionInASL4D = '[1 2]'; x.modules.asl.DummyScanPositionInASL4D = [];","title":"Parameter Descriptions"},{"location":"DataParTemplate/#datapartemplate","text":"Template for study-specific parameter tables This template provides an overview of the table of parameters used by ExploreASL, which is very specific to the study to be processed. Most of it is ASL quantification-related, some of it are image processing parameters also applicable to the structural module. It allows only for minimal pipeline modifications (e.g. x.settings.Quality , x.settings.DELETETEMP ) as most of the ExploreASL environment parameters are loaded through ExploreASL_Initialize.m . Here we list potential data parameters. Most are optional, and are ignored if not provided. For an example, see the DataPar*.json file(s) in the TestDataSet. For legacy reasons & ease of use, these can be set up in a DataPar*.m , which will be converted to the DataPar*.json per BIDS. The compiled version of ExploreASL only allows for JSON input. For the DataPar.json: Make sure that booleans are inputted as numbers (e.g. 1 or 0 ) and not as words (e.g. true or false ). Scalars can be inputted as scalars. For vectors/arrays of character arrays, we recommend to insert vectors of strings, e.g. [\"optionA\" \"optionB\"] instead of ['optionA', 'optionB'] . This is to allow for valid JSONs. The conversion is carried out internally.","title":"DataParTemplate"},{"location":"DataParTemplate/#environment-parameters","text":"Description Defaults x.external.bAutomaticallyDetectFSL Boolean to automatically detect the FSL version if disabled, this function will try to use the system-initialized FSL and throw an error if FSL is not initialized. OPTIONAL, DEFAULT = disabled","title":"ENVIRONMENT PARAMETERS"},{"location":"DataParTemplate/#study-parameters","text":"Description Defaults x.D.ROOT Path to analysis root folder where data is stored, example: /home/hjmutsaerts/TestDataSet OPTIONAL, DEFAULT = pwd x.SESSIONS Use this to define sessions. Specific options: for FEAST: 1=crushed , 2=not crushed . This used to be other way around, but the crushed image registers better with the pGM image. Example ( '.json' file): [\"ASL_1\",\"ASL_2\"] OPTIONAL, DEFAULT = {'ASL_1'} x.session.options This is how the sessions will be called, example: {'baseline' 'drug'} . For FEAST, this should be {'non-crushed' 'crushed'} . OPTIONAL x.dataset.name String for the name of the study, example: AD-study OPTIONAL x.dataset.subjectRegexp String with regular expression for ExploreASL to find subjects by foldername, example: ^\\d{3}$ for three digits REQUIRED x.dataset.exclusion Cell with list of subjects to exclude, example: {'005' '018'} OPTIONAL, DEFAULT = empty x.dataset.ForceInclusionList Use this field if you want to use a selection of subjects rather than taking all available subjects from directories. Example: load(fullfile(x.D.ROOT,'LongitudinalList.mat') ). OPTIONAL, DEFAULT = use all subjects","title":"STUDY PARAMETERS"},{"location":"DataParTemplate/#m0-parameters-and-options","text":"Description Defaults x.Q.M0 Choose which M0 option to use: 'separate_scan' = for a separate M0 NIfTI (needs to be in the same folder called M0.nii ), 3.7394*10^6 = single M0 value to use, 'UseControlAsM0' = will copy the mean control image as M0.nii and process as if it was a separately acquired M0 image (taking TR etc from the ASL4D.nii ). Make sure that no background suppression was used, otherwise this option is invalid. REQUIRED x.modules.asl.M0_conventionalProcessing Boolean - use the conventional M0 processing (per consensus paper), options: 1 = standard processing, 0 = new image processing (improved masking & smoothing). OPTIONAL, DEFAULT = 0 x.modules.asl.M0_GMScaleFactor Add additional scale factor to multiply the M0 image by This can be useful when you have background suppression but no control/M0 image without background suppression. If you then know the M0 scalefactor for the GM, you can use the control image as M0 and use this parameter to scale back what was suppressed by background suppression. Note that there is no option for separate tissue scaling (e.g. WM & GM), because ExploreASL pragmatically smooths the M0 a lot, assuming that head motion and registration between M0 & ASL4D will differ between patients and controls. OPTIONAL, default = 1 x.modules.asl.M0PositionInASL4D A vector of integers that indicates the position of M0 in TimeSeries, if it is integrated by the Vendor in the DICOM export. Will move this from ASL4D.nii to M0.nii Note that the x.modules.asl.M0PositionInASL4D parameter is independent from the x.Q.M0 parameter choice. Example for Philips 3D GRASE = '[1 2]' (first control-label pair). Example for Siemens 3D GRASE = 1 first image. Example for GE 3D spiral = 2 where first image is PWI & last = M0. Empty vector should be given (= [] or = null (in JSON)) if no action is to be taken and nothing is removed. OPTIONAL, DEFAULT = [] (no M0 in timeseries) x.modules.asl.DummyScanPositionInASL4D A vector of integers that indicates the position of Dummy scans in TimeSeries if they are integrated by the Vendor in the DICOM export. This allows to remove the dummy scans or noise scans that are part of the Timeseries. A new ASL4D.nii is saved with dummy scans removed and the original is backed-up. Works in a similar way as M0PositionInASL4D, both can be entered at the same time and both indicate the original position in the Timeseries independend of each other. Example for Siemens 2D EPI = [79 80] Skip the control-label pair used for noise measurements. Example for certain Siemens 3D GRASE = 2 Skip the first dummy control image. Empty vector should be given (= [] or = null (in JSON)) if no action is to be taken and nothing is removed. OPTIONAL, DEFAULT = [] (no M0 in timeseries)","title":"M0 PARAMETERS and OPTIONS"},{"location":"DataParTemplate/#sequence-parameters","text":"Description Defaults x.Q.BackgroundSuppressionNumberPulses Used to estimate decrease of labeling efficiency. Options: 0 = (no background suppression), 2 = labeling efficiency factor 0.83 (e.g. Philips 2D EPI & Siemens 3D GRASE), 4 = labeling efficiency factor 0.81 (e.g. Philips 3D GRASE), 5 = labeling efficiency factor 0.75 (e.g. GE 3D spiral). REQUIRED x.Q.BackgroundSuppressionPulseTime Vector containing timing, in ms, of the background suppression pulses before the start of the readout (per BIDS). REQUIRED when x.Q.UseControlAsM0 & x.Q.BackgroundSuppressionNumberPulses>0 x.Q.PresaturationTime Time in ms before the start of the readout, scalar, when the slice has been saturated (90 degree flip) this has to come before all the bSup pulses, but doesn't need to be always specified. OPTIONAL, defaults to PLD (PASL) or PLD+LabDur ((P)CASL) x.Q.readoutDim String specifying the readout type. Options: '2D' for slice-wise readout, '3D' for volumetric readout. REQUIRED x.Q.Vendor String containing the Vendor used. This parameter is used to apply the Vendor-specific scale factors, options: 'GE_product', 'GE_WIP', 'Philips', 'Siemens'. REQUIRED for ASL x.Q.Sequence String containing the sequence used. Options: '3D_spiral', '3D_GRASE', '2D_EPI' . REQUIRED for ASL x.Q.LabelingType String containing the labeling strategy used. Options: 'PASL' (pulsed Q2-TIPS), 'CASL' (CASL/PCASL). Note: pulsed without Q2TIPS cannot be reliably quantified because the bolus width cannot be identified CASL & PCASL are both continuous ASL methods, identical quantification. REQUIRED for ASL x.Q.Initial_PLD Value of PLD (ms), for 3D this is fixed for whole brain, for 2D this is the PLD of first acquired slice, example: 1800. REQUIRED for ASL x.Q.LabelingDuration Value of labeling duration (ms), example: 1800. REQUIRED for ASL x.Q.SliceReadoutTime Value (ms) of time added to the PLD after reading out each slice, example: 31. Other option = 'shortestTR' ; shortest TR enabled gives each sequence the minimal TR. This enables calculating slice delay per subject. REQUIRED for 2D ASL sequences","title":"SEQUENCE PARAMETERS"},{"location":"DataParTemplate/#quantification-parameters","text":"Description Defaults x.Q.bUseBasilQuantification True for using BASIL quantification in addition to ExploreASL's quantification. x.Q.Lambda Brain/blood water coefficient (mL 1H/ mL blood). Example: 0.32 (for GSP phantom). OPTIONAL, DEFAULT = 0.9 x.Q.T2art T2* of arterial blood at 3T, only used when no M0 image (ms). OPTIONAL, DEFAULT = 50 x.Q.BloodT1 T1 relaxation time of arterial blood (ms). Defaults (Alsop MRM 2014), 1800 for GSP phantom. OPTIONAL, DEFAULT = 1650 @ 3T, 1350 @ 1.5 T x.Q.TissueT1 T1 relaxation time of GM tissue (ms). Defaults (Alsop MRM 2014). OPTIONAL, DEFAULT=1240 @ 3T, 920 @ 1.5 T x.Q.nCompartments Number of modeled compartments for quantification. Options: 1 = a single-compartment quantification model (default by concensus paper), 2 = a dual-compartment quantification model. OPTIONAL, DEFAULT = 1) x.Q.ApplyQuantification A vector of 1x5 logical values specifying which types on quantified images should be calculated and saved. Fields: 1) Apply ScaleSlopes ASL4D (xASL_wrp_Quantify, future at dcm2niiX stage), 2) Apply ScaleSlopes M0 (xASL_quant_M0, future at dcm2niiX stage), 3) Convert PWI a.u. to label (xASL_wrp_Quantify, future at xASL_wrp_Reslice?), 4) Quantify M0 a.u. (xASL_quant_M0, corrects for incomplete T1 relaxation), 5) Perform division by M0. Examples: ASL4D is an already quantified CBF image, disable all quantification '[0 0 0 0 0]' . To compare label but not CBF (e.g. label in vessels or sinus vs tissue): [1 1 1 1 0]' . Note that the output always goes to CBF.nii. OPTIONAL, DEFAULT = '[1 1 1 1 1]' = all enabled x.Q.SaveCBF4D Boolean, true to also save 4D CBF timeseries, if ASL4D had timeseries. OPTIONAL, DEFAULT=false","title":"QUANTIFICATION PARAMETERS"},{"location":"DataParTemplate/#general-processing-parameters","text":"Description Defaults x.settings.Quality Boolean specifying on which quality the pipeline should be run, options: 1 = normal quality, 0 = lower quality, fewer iterations and lower resolution of processing for a fast try-out. OPTIONAL, DEFAULT = 1 x.settings.DELETETEMP Boolean for removing the temporary files. Options: 0 = keeping all files, 1 = delete temporary files created by the pipeline. OPTIONAL, DEFAULT = 1 x.settings.SkipIfNoFlair Boolean to skip processing of subjects that do not have a FLAIR image. These parameters can be useful when some data is still complete, but one would like to start image processing already. Options: 1 = skip processing of a subject that does not have a FLAIR image 0 = do not skip anything. OPTIONAL, DEFAULT = 0 x.settings.SkipIfNoASL Boolean to skip processing of subjects that do not have a ASL image. Options: 1 = skip processing of a subject that does not have a ASL image, 0 = do not skip anything. OPTIONAL, DEFAULT = 0 x.settings.SkipIfNoM0 Boolean to skip processing of subjects that do not have a M0 image. Options: 1 = skip processing of a subject that does not have a M0 image, 0 = do not skip anything. OPTIONAL, DEFAULT = 0","title":"GENERAL PROCESSING PARAMETERS"},{"location":"DataParTemplate/#structural-processing-parameters","text":"Description Defaults x.modules.bRunLongReg Run longitudinal registration. OPTIONAL, DEFAULT = 0 x.modules.bRunDARTEL Run between-subject registration/create templates. OPTIONAL, DEFAULT = 0 x.modules.structural.bSegmentSPM12 Boolean to specify if SPM12 segmentation is run instead of CAT12. Options: 1 = run SPM12, 0 = run CAT12. OPTIONAL, DEFAULT = 0 x.modules.structural.bHammersCAT12 Boolean specifying if CAT12 should provide Hammers volumetric ROI results. OPTIONAL, DEFAULT = 0 x.modules.structural.bFixResolution Resample to a resolution that CAT12 accepts. OPTIONAL, DEFAULT=false","title":"STRUCTURAL PROCESSING PARAMETERS"},{"location":"DataParTemplate/#asl-processing-parameters","text":"Description Defaults x.modules.asl.motionCorrection Boolean to perform motion correction in case of timeseries. Options: 1 = on, 0 = off. OPTIONAL, DEFAULT = 1 x.modules.asl.SpikeRemovalThreshold Minimal t-stat improval needed to remove motion spikes. Examples: 1 = effectively disabling spike removal. OPTIONAL, DEFAULT = 0.01 x.modules.asl.bRegistrationContrast Specifies the image contrast used for registration: 0 = Control->T1w, 1 = CBF->pseudoCBF from template/pGM+pWM (skip if sCoV>0.667), 2 = automatic (mix of both), 3 = option 2 & force CBF->pseudoCBF irrespective of sCoV. OPTIONAL, DEFAULT = 2 x.modules.asl.bAffineRegistration Specifies if the ASL-T1w rigid-body registration is followed up by an affine registration: 0 = affine registration disabled, 1 = affine registration enabled, 2 = affine registration automatically chosen based on spatial CoV of PWI. OPTIONAL, DEFAULT = 0 x.modules.asl.bDCTRegistration Specifies if to include the DCT registration on top of Affine, all other requirements for affine are thus also taken into account the x.modules.asl.bAffineRegistration must be >0 for DCT to run: 0 = DCT registration disabled 1 = DCT registration enabled if affine enabled and conditions for affine passed, 2 = DCT enabled as above, but use PVC on top of it to get the local intensity scaling right. OPTIONAL, DEFAULT = 0 x.modules.asl.bRegisterM02ASL Boolean specifying whether M0 is registered to mean_control image (or T1w if no control image exists). It can be useful to disable M0 registration if the ASL registration is done based on the M0, and little motion is expected between the M0 and ASL acquisition. If no separate M0 image is available, this parameter will have no effect. This option is disabled automatically for 3D spiral: 0 = M0 registration disabled, 1 = M0 registration enabled (DEFAULT). OPTIONAL, DEFAULT = 0 x.modules.asl.bUseMNIasDummyStructural When structural (e.g. T1w) data is missing, copy population-average MNI templates as dummy structural templates. With this option, the ASL module copies the structural templates to fool the pipeline, resulting in ASL registration to these templates. While the rigid-body parameters might still be found somewhat correctly, with this option it is advised to enable affine registration for ASL as well, since ASL and these dummy structural images will differ geometrically. When disabled, an error will be issued instead when the structural image are missing. 1 = enabled, 0 = disabled. OPTIONAL, DEFAULT = 0 x.modules.asl.bPVCNativeSpace Performs partial volume correction (PVC) in ASL native space using the GM and WM maps obtained from previously segmented T1-weighted images. Skipped with warning when those maps do not exist and are not resampled to the ASL space. PVC can take several minutes for larger scans (e.g. 128x128x30), so it is deactivated by default. 1 = enabled, 0 = disabled. OPTIONAL, DEFAULT = 0 x.modules.asl.PVCNativeSpaceKernel Kernel size for the ASL native space PVC. This is ignored when x.modules.asl.bPVCNativeSpace is set to 0. Equal weighting of all voxels within the kernel is assumed. 3D kernel can be used, but any of the dimension can be also set to 1. Only odd number of voxels can be used in each dimension (e.g. [3 7 5] not [2 3 1] ). OPTIONAL, DEFAULT = [5 5 1] for bPVCGaussianMM==0, [10 10 4] for bPVCGaussianMM==1 x.modules.asl.bPVCGaussianMM If set to 1, PV-correction with a Gaussian weighting is used instead of the equal weights of all voxels in the kernel ('flat' kernel) as per Asllani's original method. Ignored when x.modules.asl.bPVCNativeSpace is set to 0. Unlike with the flat kernel when the size is defined in voxels, here the FWHM of the Gaussian in mm is defined in each dimension. The advantage is twofold - continuous values can be added and a single value can be entered which is valid for datasets with different voxel-sizes without having a kernel of different effective size. 1 = enabled, use Gaussian kernel with FWHM in mm given in PVCNativeSpaceKernel, 0 = disabled, use 'flat' kernel with voxels given in PVCNativeSpaceKernel. OPTIONAL, DEFAULT = 0 x.modules.asl.bMakeNIfTI4DICOM Boolean to output CBF native space maps resampled and/or registered to the original T1w/ASL, and contrast adapted and in 12 bit range allowing to convert the NIfTI to a DICOM file, e.g. for implementation in PACS or other DICOM archives. If set to true, an additional CBF image will be created with modifications that allow it to be easily implemented back into a DICOM for e.g. PACS: 1. Remove peak & valley signal, remove NaNs, rescale to 12 bit integers, apply original orientation (2 copies saved, with original ASL and T1w orientation).","title":"ASL PROCESSING PARAMETERS"},{"location":"DataParTemplate/#masking-atlas-parameters","text":"Description Defaults x.S.bMasking Vector specifying if we should mask a ROI with a subject-specific mask (1 = yes, 0 = no): [1 0 0 0] = susceptibility mask (either population-or subject-wise), [0 1 0 0] = vascular mask (only subject-wise), [0 0 1 0] = subject-specific tissue-masking (e.g. pGM>0.5), [0 0 0 1] = WholeBrain masking (used as memory compression) [0 0 0 0] = no masking at all, [1 1 1 1] = apply all masks, Can also be used as boolean, where 1 = [1 1 1 1] , 0 = [0 0 0 0] . Can be useful for e.g. loading lesion masks outside the GM. OPTIONAL, DEFAULT=1 x.S.Atlases Vector specifying the atlases which should be used within the population module. Default definition within the Population Module: x.S.Atlases = {'TotalGM','DeepWM'} . Available atlases (please check the atlas NIfTI and accompanying files for more information): Free atlases : TotalGM : Mask of the entire GM './External/SPMmodified/MapsAdded/TotalGM.nii' , TotalWM : Mask of the entire WM './External/SPMmodified/MapsAdded/TotalWM.nii' , DeepWM : Mask of the deep WM './External/SPMmodified/MapsAdded/DeepWM.nii' , WholeBrain : Mask of the entire brain './External/SPMmodified/MapsAdded/WholeBrain.nii' , MNI_Structural : MNI cortical atlas ' ./External/SPMmodified/MapsAdded/MNI_Structural.nii' , Tatu_ACA_MCA_PCA : Original vascular territories by Tatu et al. './External/SPMmodified/MapsAdded/VascularTerritories/CortVascTerritoriesTatu.nii.nii' , Tatu_ICA_PCA : Tatu - only ICA and PCA './External/SPMmodified/MapsAdded/VascularTerritories/TatuICA_PCA.nii' , Tatu_ICA_L_ICA_R_PCA : './External/SPMmodified/MapsAdded/VascularTerritories/LabelingTerritories.nii' , Tatu_ACA_MCA_PCA_Prox_Med_Dist : Tatu separated to distal/medial/proximal of ACA/MCA/PCA './External/SPMmodified/MapsAdded/VascularTerritories/ATTbasedFlowTerritories.nii.nii' , Mindboggle_OASIS_DKT31_CMA : Mindboggle-101 cortical atlas './External/Atlases/Mindboggle_OASIS_DKT31_CMA.nii.gz' . Free for non-commercial use only : HOcort_CONN : Harvard-Oxford cortical atlas './External/Atlases/HOcort_CONN.nii.gz' , HOsub_CONN : Harvard-Oxford subcortical atlas './External/Atlases/HOsub_CONN.nii.gz' , Hammers : Alexander Hammers's brain atlas './External/Atlases/Hammers.nii.gz' , HammersCAT12 : Hammers atlas adapted to DARTEL template of IXI550 space './External/Atlases/HammersCAT12.nii' , Thalamus : Harvad-Oxford thalamus atlas './External/Atlases/Thalamus.nii.gz' . OPTIONAL, DEFAULT= {'TotalGM','DeepWM'}","title":"MASKING &amp; ATLAS PARAMETERS"},{"location":"DataParTemplate/#matlab-structure-example","text":"To create the JSON file of this matlab structure, you can use spm_jsonwrite() . x.dataset.name = ExampleDataSet; x.dataset.subjectRegexp = '^Sub-\\d{3}$'; x.Q.readoutDim = '2D'; x.Q.Vendor = 'Philips'; x.Q.BackgroundSuppressionNumberPulses = 2; x.Q.LabelingType = 'CASL'; x.Q.Initial_PLD = 1525; x.Q.LabelingDuration = 1650; x.Q.SliceReadoutTime = 43.7647; x.Q.M0 = 'separate_scan'; x.settings.Quality = 0; x.settings.DELETETEMP = 1; x.modules.asl.M0PositionInASL4D = '[1 2]'; x.modules.asl.DummyScanPositionInASL4D = [];","title":"Matlab structure example"},{"location":"FAQ/","text":"FAQ I am new to ASL-MRI and I do not know how to import and process data. Where should I start? We recommend to start with our ASL-BIDS and Basics tutorials. For more details on the BIDS data format in general, we recommend to read the BIDS documentation . I would like to use ExploreASL, but I do not have a Matlab license. Can you help me? ExploreASL is based on a variety of toolboxes that were written in Matlab. We are working on the ExploreASL GUI and the docker integration though, so that everyone can use ExploreASL without Matlab license fees. Doing x worked just fine in ExploreASL version a but doesn't work in version b . What should I do now? We recommend to check out the Change Log tab. Changes between different versions of ExploreASL are documented there. I developed a nice method/idea on how to process a specific kind of dataset. How can I support ExploreASL by adding my code to it? We always look forward to new methods and tools to improve ExploreASL. Please feel free to contact the developer team, we normally answer to e-mails pretty quickly. I was reprocessing a dataset with ExploreASL version b which was previously processes with version a . Now I get weird warnings. What should I do now? Parameters and settings can change between different versions of ExploreASL. We try to keep it to a minimum, but sometimes there is no way around it. Check the dataPar template and the Change Log tab, to find out if some of your x-structure variables have changed. I have a question that is not in the list above. What should I do now? Please feel free to contact the developer team, we normally answer to e-mails pretty quickly. There are also bi-weekly meetings of the developer team, so if you feel like you could contribute to our open-source project or you would like to ask a question in person, feel free to ask for an invite.","title":"FAQ"},{"location":"FAQ/#faq","text":"I am new to ASL-MRI and I do not know how to import and process data. Where should I start? We recommend to start with our ASL-BIDS and Basics tutorials. For more details on the BIDS data format in general, we recommend to read the BIDS documentation . I would like to use ExploreASL, but I do not have a Matlab license. Can you help me? ExploreASL is based on a variety of toolboxes that were written in Matlab. We are working on the ExploreASL GUI and the docker integration though, so that everyone can use ExploreASL without Matlab license fees. Doing x worked just fine in ExploreASL version a but doesn't work in version b . What should I do now? We recommend to check out the Change Log tab. Changes between different versions of ExploreASL are documented there. I developed a nice method/idea on how to process a specific kind of dataset. How can I support ExploreASL by adding my code to it? We always look forward to new methods and tools to improve ExploreASL. Please feel free to contact the developer team, we normally answer to e-mails pretty quickly. I was reprocessing a dataset with ExploreASL version b which was previously processes with version a . Now I get weird warnings. What should I do now? Parameters and settings can change between different versions of ExploreASL. We try to keep it to a minimum, but sometimes there is no way around it. Check the dataPar template and the Change Log tab, to find out if some of your x-structure variables have changed. I have a question that is not in the list above. What should I do now? Please feel free to contact the developer team, we normally answer to e-mails pretty quickly. There are also bi-weekly meetings of the developer team, so if you feel like you could contribute to our open-source project or you would like to ask a question in person, feel free to ask for an invite.","title":"FAQ"},{"location":"Functions/","text":"Functions General Functions xASL_Iteration.m Format: [bAborted, xOut] = xASL_Iteration(x, moduleName[, dryRun, stopAfterErrors]) Description: Parses the settings and runs the DatabaseLoop sub-function. Administration xASL_adm_CatchNumbersFromString.m Format: [OutputNumber] = xASL_adm_CatchNumbersFromString(InputString) Description: Extracts a number from a char array. xASL_adm_CheckFileCount.m Format: [result, files] = xASL_adm_CheckFileCount(path, expr[, mincount, failifmissing]) [result] = xASL_adm_CheckFileCount(...) Description: Checks the given PATH for files corresponding to the SPM_SELECT regular expression EXPR . Returns if the number of files is equal to or higher than MINCOUNT . If FAILIFMISSING is true and not enough files, then throw and error. If everything goes ok and second output argument is specified then return also the list of files. xASL_adm_CheckPermissions.m Format: [FilesList, FilesExeList, FoldersList] = xASL_adm_CheckPermissions(InputPath[, FilesExecutable]) Description: This function does a recursive search through the root folder & makes a list of the attributes of all files and folders. It tries to reset the attributes to what we desire, which is by default: 664 for files (meaning only reading & writing for users & group, & read-only for others) 775 for folders (meaning reading, writing & opening for current user & current group, & for others only reading & opening) For executable files we also want 775. Note that the permission to 'execute a folder' means opening them. DataOK checks data permissions. ExeOK checks executable permissions. DataOK also includes executable permissions for folders. This runs recursively (but currently skips the contents of the root-folder) . xASL_adm_CheckSPM.m Format: [spm_path, spm_version] = xASL_adm_CheckSPM([modality, proposed_spm_path, check_mode]) [spm_path] = xASL_adm_CheckSPM(...) xASL_adm_CheckSPM(...) Description: Checks if the spm function exists and if the reported version matches our development version ( SPM8 or SPM12 ). If the spm toolbox is not available yet, it will try the PROPOSED_SPM_PATH (if specified) or the user selected directory and add it to PATH . The function will fail if SPM cannot be found or if detecting an unsupported version. xASL_adm_CleanUpBeforeRerun.m Format: xASL_adm_CleanupBeforeCompleteRerun(AnalysisDir, iModule, bRemoveWMH, bAllSubjects, SubjectID) Description: This function (partly) reverts previous ExploreASL runs, deleting derivatives, while keeping raw data intact. if bAllSubjects==true, then all subjects and all module derivatives will be removed. This function performs the following steps: If a Population folder doesn't exist yet but dartel does, rename it Remove whole-study data files in AnalysisDir if bAllSubjects Remove lock files/folders for reprocessing Restore backupped _ORI (original) files Delete native space CAT12 temporary folders (always, independent of iModule) Remove native space files for iModule Remove standard space files for iModule Remove population module files Remove or clean up stored x-struct & QC file -> THIS HAS NO SESSION SUPPORT YET NB: still need to add xASL_module_func & xASL_module_dwi for EPAD xASL_adm_CompareDataSets.m Format: [RMS] = xASL_adm_CompareDataSets(RefAnalysisRoot,SourceAnalysisRoot,x,type,mutexState) Description: Compare data sets is used to ... type 0: Only save type 1: Save and evaluate type 2: Only evaluate xASL_adm_CompareLists.m Format: [NewList] = xASL_adm_CompareLists(list1, list2) Description: This script compares two single dimension lists. xASL_adm_ConvertDate2Nr.m Format: [Nr DayInYear] = xASL_adm_ConvertDate2Nr(TempDate) Description: Converts date to number input mmdd -> output mm (with days in fractions/floating point). Inverse from ConvertNrDate. xASL_adm_ConvertNr2Time.m Format: Time = xASL_adm_ConvertNr2Time(Nr) Description: Converts number to time input hh (with minutes in fractions/floating point) -> output hhmm. Inverse from xASL_adm_ConvertTime2Nr. xASL_adm_ConvertSubjSess2Subj_Sess.m Format: [iSubj iSess] = xASL_adm_ConvertSubjSess2Subj_Sess(nSessions, iSubjSess) Description: Converts combined SubjectSession index to subject & session indices. Useful for data lists in ExploreASL. xASL_adm_ConvertTime2Nr.m Format: Nr = xASL_adm_ConvertTime2Nr(Time) Description: Converts time to number input hhmm -> output hh (with minutes in fractions/floating point). Inverse from xASL_adm_ConvertNr2Time. xASL_adm_CopyMoveFileList.m Format: [List] = xASL_adm_CopyMoveFileList(OriDir, DstDir, StrRegExp, bMove[, bDir, bRecursive, bOverwrite, bVerbose]) Description: Moves a file to a file, a file to a directory, or a directory to a directory. It keeps the initial extensions, no unzipping or zipping after the move. But it makes sure that only one of .nii and .nii.gz exists in the destination directory. Useful to split a large database. xASL_adm_CorrectName.m Format: strOut = xASL_adm_CorrectName(strIn[, bOption, strExclude]) Description: Finds and replaces all non-word characters either by empty space or by an underscore. Optionally leaves in few selected special characters. Note that if '_' is excluded from replacement, but option 2 is on, then underscores are replaced anyway. xASL_adm_CreateFileReport.m Format: x = xASL_adm_CreateFileReport(x, bHasFLAIR, bHasMoCo, bHasM0, bHasLongitudinal) Description: Prints a summary of created files or the individual modules (i.e. Structural, Longiutudinal & ASL modules). Provides a quick check to see what has been skipped, an whether all files are present. This script iterates across: Native space 1) subject and 2) session files, Resampled 3) subject and 4) session files, 5) Lock files and 6) QC Figure files. For all we perform a: A) Count of the files present, summarized in FileReportSummary.csv B) List of the missing files in \"Missing*.csv\" files PM: Simplify/optimize this code, to make filename variable changing, search within subject-directories, etc. Combine the parts searching for missing & summarizing count. xASL_adm_DefineASLResolution.m Format: x = xASL_adm_DefineASLResolution(x) Description: If the parameters x.ResolutionEstimation == 1, it initializes the resolution with expected values per sequence type and then runs the procedure xASL_im_ResolutionEstim to estimate the resolution from the mismatch between ASL and structural data. For x.ResolutionEstimation == 0, xASL_init_DefaultEffectiveResolution the educated guess is used for the estimated resolution using previous data and analyzis. xASL_adm_DefineASLSequence.m Format: [x] = xASL_adm_DefineASLSequence(x) Description: This ExploreASL function tries to check what ASL sequence is being processed, if this was not already defined in x.Q.Sequence. It does so by checking known combinations of readout dimensionality (x.Q.readoutDim) and Vendor, knowing the product sequences of the Vendors. xASL_adm_DeleteFilePair.m Format: filepaths = xASL_adm_DeleteFilePair(path, ext1[, ext2 [, ext3 ...]]) xASL_adm_DeleteFilePair(path, ext1[, ext2 [, ext3 ...]]) Description: Delete the file given in PATH, and also deletes files with the same name, but with extension given in EXT1, and potentially also EXT2, EXT3... xASL_adm_Dicom2Parms.m Format: [parms pathDcmDictOut] = xASL_adm_Dicom2Parms(inp[, parmsfile, dcmExtFilter, bUseDCMTK, pathDcmDictIn]) Description: The function goes through the INP files, reads the DICOM or PAR/REC files and parses their headers. It extracts the DICOM parameters important for ASL, makes sure they are in the correct format, if missing then replaces with default value, it also checks if the parameters are consistent across DICOM files for a single sequence. xASL_adm_DocCrawler.m Format: xASL_adm_DocCrawler(inputPath) Description: This function checks each individual file header and extracts the information. The results is saved as a markdown file. If you want to use star symbols (*testFile.m e.g.) we recommend not to use them in the same line with bold text (which is written like this: bold text ). xASL_adm_DocInitialize.m Format: xASL_adm_DocInitialize Description: This function generates all markdown files, which are necessary for the mkdocs documentation. xASL_adm_FindByRegExp.m Format: xasl_adm_FindByRegExp(root, dirSpecs[, varargin]) Description: Recursively find files in the root directory according to the dirSpecs. xASL_adm_FindStrIndex.m Format: INDEX = xASL_adm_FindStrIndex(ARRAY, STRING) Description: Similar to find, but then for a cell array filled with strings. Only takes 4 dimensions. xASL_adm_GetDeprecatedFields.m Format: nameConversionTable = xASL_adm_GetDeprecatedFields() Description: This script is mainly used to improve backwards compatibility. Check the usage in both xASL_adm_LoadX and xASL_io_ReadDataPar. xASL_adm_GetFsList.m Format: RES = xASL_adm_GetFsList([strDirectory, strRegEx, bGetDirNames, bExcludeHidden, bIgnoreCase, nRequired]) Description: List files or directories from a given path. And optionally uses regular expressions to filter the result with options to exclude hidden files, ignore case, and set a minimal requirement on the number of results. Sorts the results at the end. xASL_adm_GetNumFromStr.m Format: num = xASL_adm_GetNumFromStr(str) Description: Obtains single number from string. CAVE there should only be one number! xASL_adm_GetPhilipsScaling.m Format: scaleFactor = xASL_adm_GetPhilipsScaling(pathParmsMat,pathNifti) Description: This script provides the correct scaling factors for a NIfTI file. It checks the header of the NIfTI that normally has the same scaling as RescaleSlope in DICOM, it checks if dcm2nii (by the info in JSON) has already converted the scale slopes to floating point. And if not, the derive the correct scaling factor to be applied. xASL_adm_GetPopulationSessions.m Format: [nSessions, bSessionsMissing] = xASL_adm_GetPopulationSessions(x) Description: This function looks for the maximum amount of sessions that are present in selected processed files present in the Population folder. Determine which files to look for in the Population folder Obtain list of session files in the Population folder Determine unique amount of session numbers present in list Set nSessions as highest unique session number Check and provide warning of number of sesssions differs per subject xASL_adm_GetUserName.m Format: UserName = xASL_adm_GetUserName() Description: Get the name of the current user. xASL_adm_Hex2Num.m Format: outNum = xASL_adm_hex2num(inStr) Description: Takes a hexadecimal string and converts it to number or string. Works also when the string contains escape characters, and for single-floats and for a little and big endian. If containing 8 and less characters than treat as float, if more than as double. xASL_adm_LesionResliceList.m Format: [INname, OUTname] = xASL_wrp_LesionResliceList(x,bLesion_T1,bLesion_FLAIR,bROI_T1,bROI_FLAIR) Description: Creates list of structural image paths to reslice. xASL_adm_LoadParms.m Format: [Parms, x] = xASL_adm_LoadParms(ParmsPath[, x, bVerbose]) Description: This function loads the internal memory x struct, any legacy *_parms.mat sidecar, any *.json BIDS sidecar, to use scan-specific parameters for image processing/quantification. Also, per BIDS inheritance, any x.S.SetsID parameters (from participants.tsv) are loaded as well. This function performs the following steps: Load .mat parameter file Load JSON file Deal with warnings Find fields with scan-specific data in x.S.Sets, and use this if possible (per BIDS inheritance) Sync Parms.* with x.(Q.)* (overwrite x/x.Q) Fix M0 parameter if not set xASL_adm_LoadX.m Format: [x[, IsLoaded]] = xASL_adm_LoadX(x[, Path_xASL, bOverwrite]) Description: This function loads x.Output & x.Output_im struct fields from the x.mat on the hard drive & adds them to the current x struct located in memory. If it didnt exist in the x.mat, it will set IsLoaded to false, which can be catched externally & a warning issued if managed so in the calling function. If it didnt exist in the memory x struct, or bOverwrite was requested, the contents of x.mat will be loaded to the memory x struct Admin Load X-struct from disc Look for and update deprecated fields Add fields from disc to the current x-struct xASL_adm_MakeStandalone.m Format: xASL_adm_MakeStandalone(outputPath, bCompileSPM, importDCM, markAsLatest); Description: This function creates an output folder including a standalone version of ExploreASL, which can be used with the Matlab Runtime outside of Matlab itself. A quick fix to solve path dependencies etc. is to first compile SPM (but this can be turned off for speed). This function performs the following steps: Manage ExploreASL and compiler code folders Capture version/date/time File management output folder & starting diary Handle SPM Specific Options Manage compilation paths Run SPM compilation Run ExploreASL compilation Print done xASL_adm_MergeStructs.m Format: mergedStruct = xASL_adm_MergeStructs(mainStruct, secondaryStruct) Description: It merges two structures. It takes everything from the mainStruct and keep it as it is. It adds all fields from the secondaryStructure to the main structure while checking for duplicates. It is not overwriting anything, all duplicit content is taken from mainStruct. It works iteratively by correctly merging also the substructs. xASL_adm_OrderFields.m Format: outStruct = xASL_adm_OrderFields(inStruct,orderStruct) Description: Order fields in the structure inStruct to match orderStruct , unmatching fields in inStruct are copied as they are at the end, unmatching fields in orderStruct are ignored. This is just a cosmetic change and no values are edited. xASL_adm_OtherListSPM.m Format: [OtherListSPM, OtherListOut] = xASL_adm_OtherListSPM(OtherList, bList4D) Description: bPadComma1 is to add the ,1 to the end of the pathstring, which SPM uses to assign the first image of a 4D image array (OPTIONAL, DEFAULT = true) bList4D: boolean, true for listing multiple 4D volumes separately in the list (OPTIONAL, DEFAULT=true). xASL_adm_ParReadHeader.m Format: info =xASL_adm_ParReadHeader(filename) Description: Function for reading the header of a Philips Par / Rec MR V4.* file. xASL_adm_RemoveDirectories.m Format: xASL_adm_RemoveDirectories(root) Description: Script to remove all ExploreASL related paths. xASL_adm_RemoveLogFilesForRerun.m Format: xASL_adm_RemoveLogFilesForRerun(rootDir); Description: Removes all log files from any directory containing .log files. xASL_adm_Remove_1_SPM.m Format: [OtherList] = xASL_adm_Remove_1_SPM(OtherList) Description: Remove ,1 at end of OtherLists, if exists. These are appended in CoregInit, OldNormalizeWrapper etc, since this should allow 4rd dim (e.g. as in ASL4D). xASL_adm_ReplaceSymbols.m Format: strOut = xASL_adm_ReplaceSymbols(strIn, symbolTable[, bracketLeft, bracketRight]) Description: It takes the STRIN on input, then looks for symbols between BRACKETLEFT and BRACKETRIGHT and replaces these symbols in in the string by the values provided in the SYMBOLTABLE as SYMBOLTABLE.SYMBOL, SYMBOLTABLE.D.SYMBOL, or SYMBOLTABLE.P.SYMBOL xASL_adm_ResetVisualizationSlices.m Format: [x] = xASL_adm_ResetVisualizationSlices(x) Description: Removes any predefined slices that should be visualized, allowing to show the default slices. Comes in handy when different pipeline visualization parts are repeated. xASL_adm_SaveX.m Format: xASL_adm_SaveX(x[, Path_xASL, bOverwrite]) Description: This function saves the x.mat either to the predefined path or the the subject x.mat xASL_adm_UnzipOrCopy.m Format: unpackedFiles = xASL_adm_UnzipOrCopy(srcDir, wildCard, destDir [, bOverwrite]) Description: This is a simple wrapper function to (g)unzip one or more files to the specified destination directory. Existing files or directories will not be overwritten, unless forced with bOverwrite. A regular file-copy will be used if the source files don't have gz or zip filename extensions. xASL_adm_Voxel2RealWorldCoordinates.m Format: [X Y Z] = xASL_adm_Voxel2RealWorldCoordinates(X,Y,Z,VoxelSize) Description: Converts MNI coordinates from voxel coordinates/indices. Assumes X Y Z = LR LeftRight AP AnteriorPosterior IS InferiorSuperior. VoxelSize should be [1 3]-sized input. xASL_adm_ZipFileList.m Format: filepaths = xASL_adm_ZipFileList(strDirectory, strRegExp[, bRecurse, bUseGzip, nRequired]) xASL_adm_ZipFileList(strDirectory, strRegExp[, bRecurse, bUseGzip, nRequired]) Description: Zip the files that match regular expression STRREGEXP in the given directory STRDIRECTORY. Zips recursively if specified in BRECURSE. Zips all files unless the number is specified by NREQUIRED, if the number is not met, then does not zip anything and throws an error. xASL_adm_uiGetInput.m Format: [Parms] = xASL_adm_uiGetInput(Parms) Description: Checks whether input fields are present, or requests them. BIDS xASL_bids_Add2ParticipantsTSV.m Format: xASL_bids_Add2ParticipantsTSV(DataIn, DataName, x, bOverwrite) Description: This function adds metadata/statistical variables to the participants.tsv in the root/analysis folder, by the following steps. This function will iterate over Data provided at DataIn and fill them in the participants.tsv, overwriting if allowed. Empty data is filled in as 'n/a', and the first column \"participants_id\" is sorted for participants. This function runs the following steps: Admin - Validate that there are not too many columns Admin - Detect nSubjectsSessions Admin - Load pre-existing participants.tsv or create one Admin - Get column number of data Add data to CellArray Sort rows on subjects Fill empty cells Write data to participants.tsv xASL_bids_BIDSifyASLJSON.m Format: jsonOut = xASL_bids_BIDSifyASLJSON(jsonIn) Description: It makes all the conversions to a proper BIDS structure, checks the existence of all BIDS fields, removes superfluous fields, checks all the conditions and orderes the structure on the output. It works according to the normal BIDS, or ASL-BIDS definition Obtain the dimensions of the ASL data Take all the manually predefined fields from studyPar Extract the scaling factors from the JSON header Convert certain DICOM fields Prioritize DICOM fields over the manually provided studyPar fields Field check and name conversion Check for time encoded sequence Merge data from the Phoenix protocol Background suppression check SliceTiming check Check if length of vector fields match the number of volumes Reformat ASLcontext field Verify TotalAcquiredPairs against ASLContext Final field check xASL_bids_BIDSifyASLNII.m Format: jsonOut = xASL_bids_BIDSifyASLNII(jsonIn, bidsPar, pathIn, pathOutPrefix) Description: It modifies the NIfTI file to take into account several BIDS specifics. Specifically, it applies the previously calculated scalings, and it saves the ASLcontext.tsv file, xASL_bids_BIDSifyAnatJSON.m Format: jsonOut = xASL_bids_BIDSifyAnatJSON(jsonIn) Description: It makes all the conversions to a proper BIDS structure, checks the existence of all BIDS fields, removes superfluous fields, checks all the conditions and orderes the structure on the output. It works according to the normal BIDS, or ASL-BIDS definition xASL_bids_BIDSifyCheckTimeEncoded.m Format: [jsonOut,bTimeEncoded,bTimeEncodedFME] = xASL_bids_BIDSifyCheckTimeEncoded(jsonIn,jsonOut) Description: Check for time encoded sequence. xASL_bids_BIDSifyM0.m Format: [jsonOutM0, jsonOutASL] = xASL_bids_BIDSifyM0(jsonIn, jsonASL, studyPar, pathM0In, pathM0Out, headerASL) Description: % It makes all the conversions to a proper BIDS structure, checks the existence of all BIDS fields, removes superfluous fields, checks all the conditions and orderes the structure on the output. It works according to the normal BIDS, or ASL-BIDS definitionIt modifies the NIfTI file to take into account several BIDS specifics. Specifically, it applies the previously calculated scalings. Check the scaling in DICOMs Check the JSON parameters Save or move the NII to the correct location xASL_bids_CheckDatasetDescription.m Format: [bImportedExploreASL, bImportedSameVersion, versionExploreASLBIDS, bImportedBETA] = xASL_bids_CheckDatasetDescription(datasetDescription, versionExploreASL) Description: Check the dataset_description.json field contents with special regard to the import version. xASL_bids_CompareStructures.m Format: [identical,results] = xASL_bids_CompareStructures(pathDatasetA,pathDatasetB,[bPrintReport,threshRmseNii]); Description: Function that compares two BIDS folders with several subfolders and studies and prints the differences. We recommend to set bPrintReport to true, because you otherwise can't see significant file content differences. xASL_bids_Config.m Format: bidsPar = xASL_bids_Config() Description: Creates several structures necessary for configuring the DICOM to BIDS conversion and saving of BIDS JSON files and NII structure. xASL_bids_CreateDatasetDescriptionTemplate.m Format: [json] = xASL_bids_CreateDatasetDescriptionTemplate(draft, versionExploreASL) Description: This script creates a JSON structure which can be saved using spm_jsonwrite to get a dataset_description.json template. Missing fields that are required are added. BIDSVersion checked against the current configured version. Remaining fields will be validated. Other fields not belonging to dataset_description.json are ignored. xASL_bids_DRO2BIDS.m Format: xASL_bids_DRO2BIDS(droTestPatient,[droSubject]) Description: Prepare DRO test patient for BIDS2RAW conversion. This script uses the output of the asldro python script and converts it into a bids structure that can be read by our xASL_bids_BIDS2Legacy script. An exemplary usage is shown in the unit test called xASL_ut_UnitTest_function_BIDS2Legacy. xASL_bids_Dicom2JSON.m Format: [parms pathDcmDictOut] = xASL_bids_Dicom2Parms(imPar, pathIn[, pathJSON, dcmExtFilter, bUseDCMTK, pathDcmDictIn]) Description: The function goes through the pathIn files, reads the DICOM or PAR/REC files and parses their headers. It extracts the DICOM parameters important for ASL, makes sure they are in the correct format, if missing then replaces with default value, it also checks if the parameters are consistent across DICOM files for a single sequence. Admin Set up the default values Recreate the parameter file from raw data xASL_bids_GetPhoenixProtocol.m Format: [xasl,parameters,parameterList,phoenixProtocol] = xASL_bids_GetPhoenixProtocol(pathData,bUseDCMTK) Description: Function that reads raw DICOM data (\".dcm\" or \".IMA\") and extracts the phoenix protocol parameters. Only works for Siemens DICOM data with phoenix protocol (tag = [0x29,0x1020]). xASL_bids_JsonCheck.m Format: jsonOut = xASL_bids_JsonCheck(jsonIn,fileType) Description: It checks the existence of all BIDS fields, removes superfluous fields, checks all the conditions and orderes the structure on the output. It works according to the normal BIDS, or ASL-BIDS definition xASL_bids_MergeNifti.m Format: NiftiPaths = xASL_bids_MergeNifti(NiftiPaths, seqType[, niiTable]) Description: This function takes a list of M0 or ASL4D files and concatenates them together in a longer 4D volume if possible following certain patterns: works only with 3D and 4D files; all files in the list must have the same size of the first three dimensions; files are generarily sorted according to the last number in the filename and outputted to M0.nii or ASL4D.nii; first JSON is taken and renamed, all other JSONs and NIIs are deleted after merging; M0*_parms.m or ASL*_parms.mat is renamed to M0_parms.m or ASL4D_parms.m; M0 files are checked if the field PhaseEncodingAxis is consistent through all the volumes, if not the nothing is merged; this is applied to a generic case and 3 other specific Siemens scenarios are implemented: i) All NII files have two volumes, then simply concatenate according to the last number. ii) Two files with a single volume each are merged according to the last number in the file name. iii) Multiple files with each containing a single volume are sorted to tags ASL4D_x_x_Y and controls ASL4D_Y and merged in the order of the last number in the filename (Y) alternating the tags and controls This function performs the following steps in subfunctions: xASL_bids_MergeNifti_M0Files Generic merging of M0 files xASL_bids_MergeNifti_GEASLFiles Merge GE ASL files and extract scan order from DICOM tags xASL_bids_MergeNifti_SeriesNumber Merge ASL files by SeriesNumber if different xASL_bids_MergeNifti_SiemensASLFiles Merge Siemens ASL files with specific filename pattern xASL_bids_MergeNifti_AllASLFiles Merge any ASL files xASL_bids_MergeNifti_Merge Merge NiftiPaths & save to pathMerged xASL_bids_MergeNifti_Delete Delete NiftiPaths and associated JSONs xASL_bids_MergeNifti_RenameParms Find *_parms.m files in directory and shorten to provided name xASL_bids_MergeNifti_Delete.m Format: xASL_bids_MergeNifti_Delete(NiftiPaths); Description: Delete NiftiPaths and associated JSONs. xASL_bids_MergeNifti_Merge.m Format: pathOut = xASL_bids_MergeNifti_Merge(NiftiPaths,indexSortedFile,nameMerged,bAlternatingControlLabel) Description: Merge NiftiPaths & save to pathOut. xASL_bids_MergeNifti_RenameParms.m Format: xASL_bids_MergeNifti_RenameParms(Fpath,Fname); Description: Find *_parms.m files in directory and shorten to provided name. xASL_bids_MergeNifti_SeriesNumber.m Format: pathOut = xASL_bids_MergeNifti_SeriesNumber(NiftiPaths, niiTable) Description: Take a list of NIfTI files and concatenates 3D/4D files into a 4D sequence if possible according to SeriesNumber for niiTable xASL_bids_MergeNifti_SiemensASLFiles.m Format: pathOut = xASL_bids_MergeNifti_SiemensASLFiles(NiftiPaths) Description: Take a list of NIfTI files and concatenates 3D/4D files into a 4D sequence if possible (Siemens). xASL_bids_MergeStudyPar.m Format: jsonIn = xASL_bids_MergeStudyPar(jsonIn,studyPar,bidsModality); Description: Check if required fields exist in studyPar but not in jsonIn or if we can find them in other ways. The BIDSification of JSON metadata requires at least some basic fields. If dcm2niix can't extract fields like Manufacturer from the DICOM data (strict anonymization), we need to be able to read them from the studyPar JSON (manually inserted). Alternatively we can check other DICOM tags for information. This function can potentially be enhanced in future release to fix other fields besides the Manufacturer as well. To enable this functionality for different modalities, we introduced the bidsModality parameter. This function is called by: xASL\\_bids\\_BIDSifyM0 xASL\\_bids\\_BIDSifyASLJSON xASL\\_bids\\_BIDSifyAnatJSON xASL_bids_Par2JSON.m Format: parms = xASL_bids_Par2JSON(pathPar, pathJSON) Description: Opens the Philips PAR file. Reads the relevant DICOM headers and saves them to JSON sidecar in a BIDS format. The JSON file is created automatically by the dcm2nii readout, so it always looks for this JSON file and add the same time reads the PAR file and adds further parameters to the JSON that were not identified by the dcm2nii tool. xASL_bids_PhoenixProtocolAnalyzer.m Format: [bidsPar,sourcePar] = xASL_bids_PhoenixProtocolAnalyzer(parameterList); Description: This function analyzes the parameter list of the phoenix protocol (tag = [0x29,0x1020]). This function is usually called from xASL_bids_GetPhoenixProtocol. xASL_bids_PhoenixProtocolReader.m Format: [parameterList,phoenixProtocol] = xASL_bids_PhoenixProtocolReader(rawPhoenixProtocol) Description: Function to parse the raw phoenix protocol. This function is usually called from xASL_bids_GetPhoenixProtocol. xASL_bids_VendorFieldCheck.m Format: jsonOut = xASL_bids_VendorFieldCheck(jsonIn,bIsASL) Description: It checks all the JSON fields, make sure that they are renamed from vendor specific names to common BIDS names xASL_bids_determineImageTypeGE.m Format: imageType = xASL_bids_determineImageTypeGE(jsonPar) Description: Determine the image type of a GE DICOM. xASL_bids_parms2BIDS.m Format: outBids = xASL_bids_parms2BIDS(inXasl[, inBids, bOutBids, priorityBids]) Description: This functions takes two parameter structures and merges them. At the same time, renames all fields according to the output type (note that only some fields have two standardised names different between the two formats. In case of duplicities, takes the field value from the preferred format. Also takes into account that the units in BIDS are s, but in xASL ms. This function performs the following steps: Define field names that need to be convert/renamed/merged Convert XASL fields to the output format (BIDS or XASL) Convert BIDS fields to the output format (BIDS or XASL) Merge the BIDS and XASL fields, convert field values xASL_bids_parseM0.m Format: xASL_bids_parseM0(pathASLNifti) Description: Check the .JSON and aslContext.tsv sidecards of an ASL file in BIDS format and find the specified M0 possibilities. Then it converts the ASL file to ExploreASL legacy format including splitting of ASL and M0 NIFTIes if needed. Note that the sidecars are in BIDS, but the file-structure is already expected to be in Legacy format FSL xASL_fsl_RunFSL.m Format: [x] = xASL_adm_RunFSL(FSLCommand, x[, OutputZipping]) Description: This function runs an FSL command from ExploreASL: Checking the FSL dir Manage CUDA/CPU parallelization (currently disabled, WIP) Setting up FSL environment Running the command Supports .nii & .nii.gz, Linux, MacOS & Windows (WSL) xASL_fsl_SetFSLdir.m Format: [FSLdir[, x, RootWSLdir]] = xASL_adm_SetFSLdir(x, bUseLatestVersion) Description: This function finds the FSLdir & puts it out, also in x.FSLdir to allow repeating this function without having to repeat searching. If the FSLdir & RootFSLdir are already defined in x.FSLdir & x.RootFSLdir, this function is skipped. Supports Linux, MacOS & Windows (WSL), & several different default installation folders for different Linux distributions xASL_fsl_TopUp.m Format: xASL_fsl_TopUp(InDir[, ScanType], x) Description: This function runs FSL TopUp. It assumes that there are 2 TopUp images, i.e. 1 blip up & 1 blip down. Admin: manage ScanType, NIfTI paths, create TopUp parameter file for image to apply TopUp to & for the TopUp NIfTIs, delete files from previous run, define the image with the same acquisition parameters as TopUp (does the image we apply TopUp to, have the Blip up or down?) Register images to image that we apply TopUp to (registration between blip up/down images is performed by TopUp) Run TopUp estimate (i.e. estimate the geometric distortion field from B0 NIfTI & parameters file), this takes quite long. Also has a x.settings.Quality=0 option that is very fast but inaccurate, to try out this pipeline part. Before TopUp, NaNs (e.g. from resampling) are removed from the images TopUp is run with default settings Apply TopUp Imaging xASL_im_BilateralFilter.m Format: [ovol] = xASL_im_BilateralFilter(volIM, mask, VoxelSize, x) Description: This function runs a spatial lowpass temporally highpass filter, and removes outliers within this signal, and adapts the time-series accordingly. xASL_im_CenterOfMass.m Format: xASL_im_CenterOfMass(PathNIfTI, OtherList, AllowedDistance) Description: This function estimates the center of mass of the image matrix, and if this is too far off the current orientation matrix center, the center will be reset. This fixes any incorrect orientation outputted by the scanner. The realignment is only applied when any of the X/Y/Z dimensions have a higher offset than AllowedDistance. xASL_im_CleanupWMHnoise.m Format: xASL_im_CleanupWMHnoise(InputPath, OutputPath, MinLesionVolume, pThresh) Description: Threshold white matter lesions, acknowledging the fact that they may be confluent with subresolution connection through a dilation. This part is executed conservatively, as FLAIR hyperintensities inside the GM can be erroneously segmented as WMH, and should not be lesion-filled (otherwise these cannot be fixed later in the Structural module). Note that LST lesion filling expects a probability map, doesnt work nicely with binary mask xASL_im_ClipExtremes.m Format: [NewIM] = xASL_im_ClipExtremes(InputIm[, ThreshHigh, ThreshLow, bVerbose, bNormalize]) Description: This function clips an image to a given percentile. The percentile is found using non-zeros sorted intensities, so both isfinite & non-zeros. This function performs the following steps: Constrain clippable intensities Clip high intensities Clip low intensities Normalize to 4096 (12 bit, 12^2) Save as NIfTI if the input was a NIfTI xASL_im_Column2IM.m Format: [ImageOut] = xASL_im_Column2IM(ColumnIn, BrainMask) Description: This function \"decompresses\" an image matrix (or multiple matrices) from a single-dimensional column, by reconstructing the image matrix from the voxel positions within the BrainMask. NB: Important to use the same BrainMask as used for converting the image matrix to the column! See also: xASL_im_IM2Column.m The mask mostly used for xASL_im_IM2Column is x.S.masks.WBmask, which completely engulfes pGM, pWM & pCSF. xASL_im_CompareNIfTIResolutionXYZ.m Format: [IsEqualResolution] = xASL_im_CompareNIfTIResolutionXYZ(PathNIfTI1, PathNIfTI2) Description: This function checks whether the X, Y and Z resolution of a NIfTI with any number of dimensions is equal. It rounds for 2 floating points, for both NIfTIs, to ensure that the same precision is compared. xASL_im_CompareNiftis.m Format: [identical,RMSE] = xASL_im_CompareNiftis(pathA,pathB) Description: Compare two niftis. Untouched comparison based on copies. xASL_im_ComputeDice.m Format: [DiceCoeff] = xASL_im_ComputeDice(imA, imB) Description: This function calculates the Dice coefficient of image overlap. xASL_im_CreateASLDeformationField.m Format: xASL_im_CreateASLDeformationField(x, bOverwrite, EstimatedResolution) Description: This function smooths a transformation flow field to a lower resolution. Usually, we use a high resolution anatomical image (e.g. 3D T1w ) to obtain the flowfields from native space to standard space, and apply these to the lower resolution ASL images. Because of the resolution differences, the flowfields need to be downsampled/smoothed, to avoid deformation effects that are crispier than the functional image that is investigated. This function performs the following steps: Obtain resolutions Fill NaNs at edges y_T1.nii flowfield to prevent interpolation artifact Smooth flowfield Fill NaNs at edges y_ASL.nii Note that if the resolution of ASL is not significantly (i.e. >0.5 mm in any dimension) lower than T1w, the y_T1.nii is copied to y_ASL.nii xASL_im_CreatePseudoCBF.m Format: xASL_im_CreatePseudoCBF(x, spatialCoV[, bPVC]) Description: This function creates a pseudo-CBF image from mean CBF template, arterial transit time (ATT) bias field & vascular artifacts, weighted through spatial CoV The first part of this code puts templates in the native space and creates a pseudoCBF image from a downsampled pGM & pWM tissue (PseudoTissue). The latter is used for registration but also as reference for the template registration, to speed this up. The second part of this code computes a pseudoCBF image based on the pseudoTissue & the CBF templates of CBF, ATT biasfield and vascular peaks, based on spatial CoV. This submodule performs the following steps: Create the pseudoTissue CBF reference image, if it doesnt exist already Create the native space copies of ASL templates, if they dont exist already Spatial CoV input argument check Load native space copies of templates Create pseudoTissue from segmentations, mix this with the mean CBF template depending on spatial CoV Create pseudoCBF reference image used for CBF-based registration Scale mean_PWI_Clipped source image to the same range as PseudoCBF xASL_im_CreateSliceGradient.m Format: xASL_im_CreateSliceGradient(x) Description: Create slice gradient in same space as input file Reslice slice gradient to MNI (using existing ASL matrix changes from e.g. registration to MNI, motion correction, registration to GM) Creating average slice gradient xASL_im_DecomposeAffineTransformation.m Format: [M, P] = xASL_im_DecomposeAffineTransformation(Mtransformation) Description: This function splits a transformation matrix into individual components, which can be useful to guide the SPM reslicing. The components are the same as in spm_(i)matrix.m, except for the shearing: these are included in the rotations, and the 90 degree rotations, these are separated. Reason for the separation of the 90 degree rotations, is that these indicate if orientations (transversal, coronal & sagittal) have been switched in the NIfTI. This can be useful to correct for any erroneous 90degree rotations from registration, or to put two images in the same orientation order or voxelsize without applying their subtle realignment (e.g. for manipulating registration references) THEORY 90 degree rotations: Any rotation will always swap the other dims (X rotation swaps Y/Z, Y rotation swaps X/Z etc.) because they are perpendicular (haaks) Dims X Y Z care for LR, AP and IS translation. - X-rotation will rotate the transverse slice (LR <-> AP) swapping Y (coronal) & Z (saggital) - Y-rotation will rotate the coronal slice (IS <-> LR) slice, swapping X (transversal) and Z (sagittal) - Z-rotation will rotate the sagittal slice (AP <-> IS) swapping X (transversal) and Y (sagittal) E.g., MPRAGE is acquired in sagittal slices, and ASL/fMRI/BOLD in transversal slices. This is an Y rotation (you look into the coronal plane, rotate this, which will swap the sagittal slices into transversal) This function performs the following steps: Start with an output P and M struct Obtain translations Obtain zoom Obtain 90degree rotations Obtain subtle rotations & shearing Check the rounding errors of the decomposition xASL_im_DetermineFlip.m Format: [LR_flip_YesNo] = xASL_im_DetermineFlip(PathOrientationResults) Description: This functions check determinants before and after image processing (nii.mat0 vs nii.mat, respectively) to find any potential left-right processing. This function performs the following steps: 1. Determine correct row, differs between Matlab versions 2. If units are printed as second row, the data starts on the third row 3. Determine column indices 4. Find left-right flips xASL_im_DilateErodeFull.m Format: imOut = xASL_im_DilateErodeFull(imIn, type, kernel) Description: Runs dilation or erosion on a binary imIn in full three dimensions. It uses its own dilate_erode function and crops the image so that it contains only the mask. The size of all three dimensions of the kernel needs to be an odd number. xASL_im_DilateErodeSeparable.m Format: imOut = xASL_im_DilateErodeSeparable(imIn, type, kernel_x, kernel_y, kernel_z) Description: Runs dilation or erosion on a binary imIn separably in three dimensions. Dilation/erosion in each dimension is done by using the specified kernels. It uses its own dilate_erode function and crops the image so that it contains only the mask. Works only with odd sized kernels xASL_im_DilateErodeSphere.m Format: el = xASL_im_DilateErodeSphere(R) Description: Creates a 3D structuring element (binary) sphere with the given diameter (R) and size 2*R+1 xASL_im_DummyOrientationNIfTI.m Format: xASL_im_DummyOrientationNIfTI(PathSrc, PathRef, PathDummyOut[, bApplyRotationMinor, bApplyRotation90, bApplyZoom, bApplyTranslation]) Description: This function creates a dummy image as reference for xASL_spm_reslice, allowing to only apply specific parts of the transformation between the two images. E.g. only the rotation, or only the zooming. This can be useful to correct for any erroneous rotations from registration, or to put two images in the same space without applying their realignment. This function performs the following steps: Load orientations & calculate transformation Calculate the desired transformation Calculate new orientation matrix Calculate the new image size Save the dummy NIfTI xASL_im_EstimateResolution.m Format: [resFWHM, resSigma, resErr, imSmo, imMask] = xASL_im_EstimateResolution(imCBF, imGM, imWM[, imMaskOrig, PSFtype, maxIter]) Description: Creates a high-resolution pseudo-CBF image based on segmented GM and WM maps and iteratively adjusts its resolution by smoothing until reaching a perfect fit with the CBF image thus obtaining the resolution difference between the GM and CBF image and uses this to calculate the estimated effective resolution of hte CBF. Note that all the calculations are done using voxels as measures and not mm, so the output resolution is also in voxels and has to be transfered to mm by using the knowledge about the voxel size. It is assumed that for imGM and imWM, the voxel size equals the resolution, and the imCBF is upsampled to the smaller voxels of imGM. xASL_im_Flip.m Format: [MatrixOut] = xASL_im_Flip(MatrixIn, varargin) Description: Backwards compatibility for flipping left-right in standard space (NB: this can be different than in native space!). xASL_im_FlipNifti.m Format: xASL_im_FlipNifti(pathInput[, flipAxis, bOverwrite]) Description: This function allows correcting an inappropriate flip in the image matrix. It will not change the orientation matrix in the header but the image itself. So any NifTI program will not be aware of this flip! This function runs the following steps: 1. Manage if we overwrite the new NIfTI 2. Manage if we zip the new NIfTI 3. Load image from NIfTI 4. Flip image 5. Save image to NIfTI xASL_im_HausdorffDist.m Format: xASL_im_HausdorffDist(imIn1,imIn2) Description: Calculate Hausdorff and modified Hausdorff distance between two ROIs in volumes imIn1, imIn2. Input images are binarized as 0 and non-0 xASL_im_IM2Column.m Format: [ColumnOut] = xASL_im_IM2Column(ImageIn, BrainMask[, ApplyShiftDim]) Description: This function \"compresses\" an image matrix (or multiple matrices) for optimization of memory and CPU resources. The output column only includes voxels that lie within the BrainMask. This excludes extracranial zero-information voxels from computations and memory use. NB: Important to use the same BrainMask for converting the column back to an image matrix! See also: xASL\\_im\\_Column2IM.m The mask mostly used for xASL_im_IM2Column is x.S.masks.WBmask , which completely engulfes pGM, pWM & pCSF xASL_im_JointHist.m Format: imHist = xASL_im_JointHist(imA,imB[,imMask,minA,maxA,minB,maxB,nBins]) Description: It calculates a joint histogram of two images of any dimensions over a mask of the same size. The boundaries and number of bins can either be given or min and max values are used. Values outside of the bins are counted to the first/last bin. xASL_im_Lesion2CAT.m Format: LesionPathOut = xASL_im_Lesion2CAT (PathIn) Description: For all lesion masks in the anatomical directory, load them, merge them and save them for the CAT segmentation. If there are no lesions found, the images are untouched. xASL_im_Lesion2Mask.m Format: LesionIM = xASL_im_Lesion2Mask(LesionPath, x) Description: This function takes a mask and adds several ROIs, to be used as custom \"atlas\", e.g. when computing region-average CBF values. The mask % can be an ROI or lesion, if we assume it is a lesion, the following masks are created: Intralesional Perilesional (15 mm rim around the lesion) Hemisphere (ipsilateral to lesion) Contralateral version of 1 4a First create separate masks 4b Check if they are mutually exclusive 4c Save NIfTI file Contralateral version of 2 Contralateral version of 3 All these masks are masked by a brainmask (pGM+pWM)>0.5 This function performs the following steps: If lesion is empty, skip this & delete the file BrainMasking Create hemispheres Save mutually exclusive masks Create tsv-sidecar containing the names of the ROIs Visual QC xASL_im_M0ErodeSmoothExtrapolate.m Format: [ImOut] = xASL_im_M0ErodeSmoothExtrapolate(ImIn, x) Description: This function erodes, smooths & extrapolates M0 in standard space. It assumes that the M0 image is in standard space & that the GM & WM probability maps are aligned. Here, we mask the M0, to remove high CSF signal and low extracranial signal, enabling us to smooth the image without inserting wrong signal. See also the ExploreASL manuscript for a more extensive explanation. This function performs the following steps: Mask: Load segmentations, create structural mask Mask: Create intensity-based mask to remove extracranial signal Mask: Erode the combined masks Mask: Determine any odd borders Smoothing Extrapolating only Scale back to the GM M0 Print visual QC figure A visual QC figure is created, showing the M0 image processing steps for a single transversal slice (slice 53 in 1.5 mm MNI standard space) OutputFile = fullfile(x.D.M0regASLdir,['M0\\_im\\_proc\\_' x.P.SubjectID '.jpg']); The original M0 image (a) is masked with a (pGM+pWM)>50% mask (b) eroded with a two-voxel sphere to limit the influence of the ventricular and extracranial signal (c) and thresholded to exclude significantly high (i.e. median + 3*mean absolute deviation (MAD)) border region values (d) This masked M0 image is smoothed with a 16x16x16 mm full- width-half-maximum Gaussian filter (Mutsaerts et al., 2018) (e) after which the signal at the border is smoothly extrapolated until the full image is filled (f). Whereas the masking avoids mixing with cerebrospinal fluid or extracranial signal, the extrapolation avoids M0 division artifacts xASL_im_MaskNegativeVascularSignal.m Format: [NegativeMask, TreatedPWI] = xASL_quant_DetectNegativeVascularSignal(x) Description: This function segments clusters with significant negative ASL signal. This can be tricky as there is also the negative tail of Gaussian noise from the ASL subtraction. The image feature we use here, is that negative vascular signal will be a relatively large region with significant median negative value, whereas noise will be regions with relatively small negative signal. Negative signal from wrong background suppression timing (e.g. in the first slice with **2D EPI**) can be masked out with this as well. The procedure works as follows: Obtain mask of negative voxels within pGM>0.5 mask Obtain distribution of subzero clusters Define the negative threshold Create mask by thresholding whole image Note that the definition of the threshold is obtained within the GM only, but that this threshold is applied to the full image. Note that instead of the PWI path input, a CBF image should work equally well, as we don't expect a smooth M0 biasfield to change the distribution of negative clusters xASL_im_MaskPeakVascularSignal.m Format: [MaskIM, CBF] = xASL_quant_VascularContrast(PathPWI, Path_M0, CompressionRate, ClipThresholdValue, bClip) Description: This function searches for an acceptable high threshold as definition of high intra-vascular ASL signal. It also allows to compress the values here (when bClip==true). Compression retains some variability, but limits their outlying influence on statistics. The procedure works as follows: Segment GM on ASL image at 80th percentile of CBF image distribution For PWI & CBF images, select voxels higher than median + ClipThresholdValue MAD Vascular artifacts will have a high intensity in both images, whereas errors by division by M0 will only have a high intensity on the M0 image, and high values due to a biasfield will only be noticeable on the PWI image Combine the two created masks Obtain average clipping value from selected voxels from the combined masks Apply compression if requested. If not, output image will have NaNs for intra-vascular voxels. Note that the definition of the threshold is obtained within the GM only, but that this threshold is applied to the full image to also remove extracranial extreme values. Note that the performance may change when using this script with or without M0, as this will change the distribution that determines where the threshold for extremes lies. xASL_im_Modulation.m Format: xASL_im_Modulation(x) Description: Combines the transformations to create Jacobians, & multiplies the standard space segmentations with these to create volumetric images for volumetric analyses. xASL_im_NormalizeLabelingTerritories.m Format: image_out = xASL_im_NormalizeLabelingTerritories( imageIN, GMmask, x) Description: Normalizes per perfusion territory mask should be GM mask. xASL_im_PCA.m Format: [pc, score, eigenvalues, tsquare, loadings, Xmean] = xASL_im_PCA(dataIn) Description: Perform a Principal Component Analysis. xASL_im_PVCbspline.m Format: [imPVEC,imCBFrec,imResidual,FWHM] = xASL_im_PVCbspline(imCBF,imPV[,bsplineNum]) Description: PVC of ASL data using prior GM-,WM-partial volume maps. Follows the principles of the PVEc algorithm by I. Asllani (MRM, 2008). The PV-corrected CBF_GM and CBF_WM maps are approximated using an uniformly sampled cubic B-splines. REFERENCES: -Asllani I, Borogovac A, Brown TR. Regression algorithm correcting for partial volume effects in arterial spin labeling MRI. Magnetic Resonance in Medicine. 2008 Dec 1;60(6):1362-71. -Petr J, Mutsaerts HJ, De Vita E, Steketee RM, Smits M, Nederveen AJ, Hofheinz F, van den Hoff J, Asllani I. Effects of systematic partial volume errors on the estimation of gray matter cerebral blood flow with arterial spin labeling MRI. MAGMA 2018. DOI:10.1007/s10334-018-0691-y xASL_im_PVCkernel.m Format: [imPVC,imCBFrec,imResidual] = xASL_im_PVCkernel(imCBF, imPV [,kernel,mode]) Description: Partial volume correction (PVC) of ASL data using prior GM-,WM-partial volume maps. Follows the principles of the PVC algorithm by I. Asllani (MRM, 2008). xASL_im_PreSmooth.m Format: pathOut = xASL_im_PreSmooth(pathRef,pathSrc[,pathSmo,resRef,resSrc,srcAffinePath, bInvAffine]) Description: It assumes that the FWHM is equal to voxel size, unless the real resolution is given. Then takes into account the voxel sizes and orientation difference between the volumes, but performs the smoothing according to the given real resolution (it is possible to supply the resolution for just one image) - this should be helpful primarily when the It creates a Gaussian covariance matrix for the reference, transforms it according to the difference between the two images a produces the Gaussian covariance matrix of the pre-smoothing in the source space. Then it performs the smoothing. The following steps are performed: Obtain the voxel size Skip this function if reference resolution is equal to, or lower than source resolution Deal with affine transformation Obtain the transformation matrix from the Reference to the Source space Apply the smoothing filter on the source image(s) Save the smoothed image xASL_im_ProcessM0Conventional.m Format: [Corr_M0] = xASL_im_ProcessM0Conventional(ImIn, x) Description: This function uses the conventional M0 masking, and only a little smoothing, following what Philips uses for its 3D {{GRASE}}. Advantages of the newer M0 processing in ExploreASL are the lack of use of M0 threshold-based masking, the removal of high CSF values and higher SNR for ASL division. xASL_im_ProjectLabelsOverData.m Format: OutputIM = xASL_im_ProjectLabelsOverData(DataIM,LabelIM,x,ScaleFactorData,ScaleFactorLabel) Description: This script projects labels over an image, but works only in 2D. Make sure to make a 2D image from a 3D or 4D image using xASL_vis_TransformData2View.m can be used in combination with xASL_vis_Imwrite.m xASL_im_ReplaceLabel.m Format: xASL_im_ReplaceLabel(pathNifti, LabelNumbersOld, LabelNumbersNew, pathNewNifti) Description: This function replaces label values/numbers inside a NIfTI image, by the following steps: Load NIfTI Replace numbers Save NIfTI xASL_im_ResampleLinearFair.m Format: [output_res]=xASL_im_ResampleLinearFair(im_input,newsize) Description: Downsample (or upsample, works similarly) old_res image to low_res image, trilinear. We recommend using \"xASL_spm_Resample\" instead, because of better performance. NB: new_res should fit exactly integer fold in old_res NB: all dimensions of new_res should have equal size xASL_im_RestoreOrientation.m Format: xASL_im_RestoreOrientation(PathNIfTI) Description: This function reverts the NIfTI header orientation matrix to the original orientation from the scanner/dcm2nii conversion. xASL_im_SkullStrip.m Format: xASL_im_SkullStrip(InPath, PathMNIMask, x, OutPath) Description: Creates skull-stripped T1w image based on MNI -> native space registration from segmentation. xASL_im_Smooth3D.m Format: [imSmo, imGaussX, imGaussY, imGaussZ] = xASL_im_Smooth3D(imIn, sigma[, PSFtype]) Description: It smooths the 3D image with a 3D kernels that has defined the shape and SD of the smoothing separably in three dimension. xASL_im_SplitImageLabels.m Format: xASL_im_SplitImageLabels(ImagePaths, LabelTable[, OutputFolder, bOverwrite, ResampleDir, SubRegExp]) Description: This function allows extracting of labels from a NIfTI file containing multiple labels, into single NIfTI files each containing a single label. Not all existing labels need to be extracted. The following steps are performed: Load TSV file Process images xASL_im_Upsample.m Format: xASL_im_Upsample(PathOrig, PathDest, NewVoxelSize, LeaveEmpty, PaddingDim, Kernel) Description: Upsamples an ASL image, without changing the orientation matrix, which can be used e.g. for PVEc in higher resolution but same space. xASL_im_ZeroEdges.m Format: [IM] = xASL_im_ZeroEdges(IM[, EdgeThicknessPerc]) Description: Resampling can sometimes give some strange errors near image edges. These should be NaNs, but sometimes can be zeros or ones, or even weird numbers. For resampling, NaNs should be set to 0 (this is done in another function) as they can influence the resampling (depending on the transformation matrix). To be sure that the edges are nicely fixed, this function sets a border at the image matrix edges to zero. xASL_im_dilateROI.m Format: xASL_im_dilateROI(PathIn, [PathOut, minVolume]) Description: The function loads a binary image from PathIn and if smaller than the defined volume (40 mL by default) it dilates it with a 3x3 sphere element until a minimal volume is reached. When it is small enough, it is saved to PathOut. 40 mm^3 is equal to 3 voxels in all directions in DARTEL space, or around the highest obtainable ASL effective resolution (3x3x4 mm). xASL_im_rotate.m Format: rotated = xASL_im_rotate(im, angle) Description: Simple rotation of the first two dimension of a ND image by 0, 90, 180, 270 degrees. Initialization xASL_init_DataLoading.m Format: [x] = xASL_init_DataLoading(x) Description: Load dataset by adding relevant fields to xASL x struct. xASL_init_DefaultEffectiveResolution.m Format: [EffectiveResolution] = xASL_init_DefaultEffectiveResolution(PathASL, x) Description: This ExploreASL module provides an educated guess on the effective spatial resolution of ASL. This may depend on the combination of acquisition PSF, reconstruction filter, head motion. Note that the derived/processed images may have a lower effective resolution because of smoothing effects from interpolation. Note that this remains an educated-guess, the actual FWHM may still differ, especially for 3D GRASE sequences, where e.g. the choice of number of segments can affect the smoothness. This function conducts the following steps: Educated-guess FWHM Attempt accounting for in-plane interpolation in reconstruction Calculate and report effective spatial resolution xASL_init_DefineDataDependentSettings.m Format: [x] = xASL_init_DefineDataDependentSettings(x) Description: Define ExploreASL environment parameters, dependent of loaded data. xASL_init_DefineIndependentSettings.m Format: [x] = xASL_init_DefineIndependentSettings(x) Description: Define ExploreASL environment parameters, independent of loaded data. xASL_init_DefinePaths.m Format: [x] = xASL_init_DefinePaths(x) Description: Define paths used by ExploreASL. xASL_init_DefineStudyData.m Format: [x] = xASL_init_DefineStudyData(x) Description: This initialization wrapper initializes the parameters for this pipeline run, i.e. subjects, sessions (runs), timepoints (visits), exclusions, sites, cohorts etc. Note that ASL sessions are defined here as what BIDS calls \"runs\". The \"longitudinal_Registration functions here manage different TimePoints, which is what BIDS calls \"visits\". With different structural scans, from the same participant. This is managed by subject name suffixes _1 _2 _n, and can be used for comparing visits in the population module, or running SPM's longitudinal within-subject registration. Parallelization is allowed here by calling ExploreASL different times, where it divides the subjects/images for processing across the nWorkers, using iWorker as the reference for the part that the current ExploreASL call will process. This requires having a Matlab license that can be started multiple times on a server, or alternatively running the ExploreASL compilation, and doesn't require the Matlab parallel toolbox. This function exists from the following parts: Manage included & excluded subjects Create dummy defaults (exclusion list, ASL sessions) Create list of total baseline & follow-up subjects, before exclusions Create TimePoint data-lists Manage exclusions Add sessions as statistical variable, if they exist Parallelization: If running parallel, select cases for this worker Add Longitudinal TimePoints (different T1 volumes) as covariate/set, after excluding Load & add statistical variables Make x.S.SetsOptions horizontal if vertical by transposing Create single site dummy, if there were no sites specified Check for time points sets Create list of baseline & follow-up subjects (i.e. after exclusion) Check what excluded from which TimePoints xASL_init_DetermineRequiredPaths.m Format: [x] = xASL_init_DetermineRequiredPaths(x) Description: Check the BIDS dataset root for the metadata JSON files. xASL_init_FileSystem.m Format: [x] = xASL_init_FileSystem(x) Description: This function initializes the file system used throughout ExploreASL, for processing a single dataset/scan. It is repeated for each scan, and runs the following parts: Create folders Subject/session definitions Add prefixes & suffixes Add Subject-specific prefixes Add sidecars Add atlas paths xASL_init_InitializeMutex.m Format: [x] = xASL_init_InitializeMutex(x, ModuleName) Description: This function initializes the mutex/lock system of ExploreASL for a module. Mutex (for mutual exclusion) is a synchronization mechanism for enforcing limits of access to data (here a module for a single scan) to allow parallelization. It also allows stopping and continuing of ExploreASL. This function runs the following steps: Lock folder management Initialize mutex object xASL_init_LoadDataParameterFile.m Format: [x] = xASL_init_LoadDataParameterFile(x, DataParPath, SelectParFile) Description: Load data parameter file. xASL_init_LoadMetadata.m Format: [x] = xASL_init_LoadMetadata(x) Description: This function loads all metadata used in the study, either statistical covariates (age, MMSE) or groups to compare between (site, sequence, cohort), or parameters to be used in quantification/image processing These parameters should be provided in .mat files in the root analysis folder. Each .mat file should contain a single type of metadata, and the filename should equal the variable name. Metadata content should be a cell array with subjects as first column and metadata as last column. Sessions (runs) can be included as second column. Metadata can be in any string or numerical format. participants.tsv is now added per BIDS. It looks for metadata in participants.tsv first, before going through the mat-files This function iterates through the following steps for each variable: Admin (what nOptions do we call ordinal, convert subject numeric to string, remove white spaces from data) Get unique list of data options & check for missing data Deal with data format (correct NaNs, deal with numeric vs strings) Distinguish continous data (e.g. age) or ordinal data (groups to compare, e.g. cohort) Check if data is complete for all subjects Include complete data in x.S.SETS xASL_init_LongitudinalRegistration.m Format: [SubjectNlist, TimePoint, IsSubject, SubjectID_FirstVolume] = xASL_init_LongitudinalRegistration(x) Description: This function initializes the longitudinal registration for ExploreASL, which implements the SPM longitudinal registration. This function recognizes and defines visits (i.e. multiple scans per subject) in the initialization of ExploreASL, based on the suffixes _1 _2 _n in the subject names (identified as foldernames). Specifically, this function is called in the registration modules LongReg and DARTEL, the first carrying out within-subject registration and the second between-subject registration, based on the first time point only. For the first function, we specify here a list of visits/timepoints that should be registered longitudinally, for the second function we specify a list of first visits only, as the between-subject registration in ExploreASL is based on the first scan (as opposed to the average subject's scan). This function runs the following steps: Get TimePoint-list (list of visits) Find subject IDs xASL_init_PrintCheckSettings.m Format: x = xASL_init_PrintCheckSettings(x) Description: Check whether pre-defined settings existed in dataPar.json . Prints these on the screen as the start of the pipeline. Runs following steps: Set default settings if not defined Print data/study specific settings Print warnings xASL_init_PrintUserFeedback.m Format: xASL_init_PrintUserFeedback(x) Description: Print user feedback. xASL_init_RemoveLockDirs.m Format: [x] = xASL_init_RemoveLockDirs(x) Description: Remove 'lock-dir' if present from aborted previous run, for current subjects only. xASL_init_SubStructs.m Format: [x] = xASL_init_SubStructs(x) Description: Initialize the ExploreASL x structure substructs/fields. Only fields which do not exist so far are added. This script is supposed to help with the overall modularity of ExploreASL. This script is identical to the function ExploreASL_Initialize_SubStructs within ExploreASL_Initialize. We can not call this script from ExploreASL_Initialize, since the paths are not initialized at that part of the script yet. xASL_init_Toolboxes.m Format: x = xASL_init_Toolboxes(x) Description: Check & load ancillary toolboxes, versions and paths. xASL_init_VisualizationSettings.m Format: [x] = xASL_init_VisualizationSettings(x) Description: This function defines several visualization settings are used throughout ExploreASL's pipeline and tools, assuming a [121 145 121] matrix with 1.5 mm isotropic resolution in MNI space. xASL_init_checkDatasetRoot.m Format: [x] = xASL_init_checkDatasetRoot(x) Description: Check the ExploreASL parameter \"DatasetRoot\". xASL_init_checkDatasetRoot_invalid_starting_2_0.m Format: [x] = xASL_init_checkDatasetRoot_invalid_starting_2_0(x) Description: Script for backwards compatibility. This functionality allows loading JSON files instead of the BIDS dataset root. xASL_init_printSettings.m Format: xASL_init_printSettings(x) Description: Print chosen settings. Input and Output xASL_io_CheckDeprecatedFieldsX.m Format: x = xASL_io_CheckDeprecatedFieldsX(x) Description: Check deprecated fields of x and fix them based on a conversion table. This table is used within: xASL_bids_parms2BIDS xASL_io_ReadDataPar xASL_adm_LoadParms xASL_adm_LoadX It is not only used to convert deprecated x structure fields to fields within up-to-date substructures of x, but also to rename fields and to move them back and forwards for the comparison with BIDS parameters within xASL_bids_parms2BIDS e.g., which is why it is important to make sure that if a row within the table is used to move & rename, that there is also another row where the new fieldname is moved to the same substructure. xASL_io_CreateNifti.m Format: xASL_io_CreateNifti(pathNewNifti, imNew, resMat, nBits, bGZip) Description: This function creates a new NIfTI file, using the SPM \"nifti\" functionality, with the parameters specified as input arguments. This function performs the following steps: Initialize NIfTI Choose datatype (bit resolution) Create scale slopes Create orientation matrix Write the new NIfTI, image matrix & scale slopes Zip and deal with zipping (.nii vs. .nii.gz) xASL_io_DcmtkRead.m Format: header = xASL_io_DcmtkRead(filepath, bPixel) Description: SHORT Reads DICOM headers using DCMTK FORMAT: header = xASL_io_DcmtkRead(filepath, bPixel) INPUT: filepath (string) - full path to the DICOM file bPixel (bool) - read pixel data, default 0 OUTPUT: header (structure) - structure containing parsed DICOM header Calls the MEX function that uses DCMTK library to read the DICOM header. To change which parameters are read and their names - the MEX file needs to be edited. This function also corrects formating of certain parameters. xASL_io_ExportVTK.m Format: xASL_io_ExportVTK(nifti, [mask, exportPath]) Description: Export a VTK image file based on a 3D NIFTI or a 3D/4D image matrix. 4D images will be exported as a VTK time series (export-1.vtk, export-2.vtk, etc.). This script uses vtkwrite (MIT License, Copyright 2016, Joe Yeh). xASL_io_MakeNifti4DICOM.m Format: xASL_io_MakeNifti4DICOM(PathIn, x) Description: This function converts a NIfTI file to one that is ready to convert to DICOM for PACS visualization purposes: For scaling/visualization: Remove peak signal Remove valley signal Remove NaNs Rescale to 12 bit integers Save NIfTI. We also zip the NIfTI as this NIfTI won't be opened by ExploreASL Manage scale slope/datatype Apply original orientation Zip NIfTI xASL_io_PairwiseSubtraction.m Format: xASL_io_PairwiseSubtraction(InputFile,outputPath,do_mask,switch_sign) Description: Subtracts controls from labels and takes mean. Creates new perfusion-weighted delta_M file, prefaced with 's'. Converts into single precision floating point values (32 bit), removes scale slope. Only runs if ['s' input_file_ASL] doesn't exist. Remember to consider motion correction/ SPM realign (isotropically). Alternative to this function is robust fit (Camille Maumet). xASL_io_ReadDataPar.m Format: [x] = xASL_io_ReadDataPar(pathDataPar[,bStudyPar]) Description: This function reads the data-parameter file, which is a file containing settings specific to processing a certain dataset or study (abbreviated as DataPar) and creates the x-structure out of it. The file can be in .json or .m format. The input file name pathDataPar is given as a string or character array. The output is the x structure. It only loads the data, removes the x-prefixes, but keeps all the field names and units. It doesn't do any conversions to or from BIDS. The only added value to normal json-read is that it detects invalid entries (numbers in strings, and weird arrays), converts them correctly and reports this incorrect entries so that they can be manually fixed. Also, if an .m file is provided, it converts and saves it to a JSON file (doesn't overwrite) and reports that you should stop using .m files. xASL_io_ReadTheDicom.m Format: [Info] = xASL_io_ReadTheDicom(bUseDCMTK, DicomPath) Description: This function tries to read a DICOM and throws a warning if it fails to xASL_io_SplitASL.m Format: xASL_io_SplitASL(inPath[, iM0, iDummy]) Description: This function splits ASL4D & M0 & Dummy images if they were in the same sequence. If dcm2niiX has already splitted the ASL4D NIfTI, this is reconstructed first. If no M0 exists, or only ASL splitting is desired, leave iM0 empty ([]). The dummy scans can be excluded from the ASL sequence during the splitting. Both iM0 and iDummy are the absolute positions of both in the original time series Vendor product sequence examples: GE 3D spiral sometimes puts the M0 at the last volume of the series -> iM0 = [2]; Philips 3D GRASE puts the M0 as control-label volume pair -> iM0 = [1 2]; Siemens 3D GRASE puts the M0 as the first volume -> iM0 = 1; Some Siemens 3D GRASE puts a second Dummy control image -> iDummy = 2; Input parameter admin Prepare paths First concatenate NIfTIs Save M0 NIfTI Determine ASL indices Save ASL4D NIfTI Split relevant JSON parameters/arrays Split ASL4D_aslContext.tsv Modify JSON fields Copy sidecars xASL_io_dcm2nii.m Format: [niifiles, ScanNameOut, usedinput, msg] = xASL_io_dcm2nii(inpath, destdir, series_name, varargin) Description: Convert DICOM NIfTI/BIDS format using the dcm2nii command line utility. Initial settings Parse parameters Locate dcm2nii executable Set default arguments dcm2nii Set dcm2niiX initialization loading Check if we are reading a DICOM folder Check for existing targets Create temporary subfolder for converting Run dcm2nii and move files to final destination using specified series name Cleanup temp Optionally return the used input file xASL_num2str.m Format: [DataOut] = xASL_num2str(DataIn[, f, bConcatenate, strDelimiter]) Description: When the provided data is numeric, this function will convert the number to string/characters, rewriting NaN into 'n/a' (BIDS convention) but otherwise preserving the Matlab builtin functionality, also for the second argument \"f\". If non-numeric data is provided, it is bypassed (avoiding any issues \"num2str\" will have with non-numeric data). It can concatenate an array/matrix of strings, taking first the columns in the first row, and then going across the rows. See builtin num2str for more details QC xASL_qc_AddLoggingInfo.m Format: [x] = xASL_qc_AddLoggingInfo(x, loggingEntry) Description: Logging of errors and warnings within the x structure. xASL_qc_AsymmetryIndex.m Format: [AI_perc] = xASL_qc_AsymmetryIndex(ImageIn) Description: Extract voxel-wise asymmetry index for QC purposes. xASL_qc_CAT12_IQR.m Format: [QA_Output] = xASL_qc_CAT12_IQR(InputImage, InputC1, InputC2, InputC3, bFLAIR) Description: Prepare and run CAT12s QC parameters (also for other images). xASL_qc_CheckValidityJSON.m Format: [IsValid] = xASL_qc_CheckValidityJSON(PathJSON) Description: This function loads a QC JSON (simply JSON file, won't take any exotic files) and simply check whether there is any empty value after a key. If this is the case, it will throw a warning, which will skip reading this JSON by the compiled spm_jsonread, avoiding the crash that this may result in. xASL_qc_CollectParameters.m Format: x = xASL_qc_CollectParameters(x, iSubject, ScanType, CollectQCFunction) Description: This function collects QC parameters for a module. xASL_qc_CollectQC_ASL.m Format: [x] = xASL_qc_CollectQC_ASL(x, iSubject) Description: This functions collects QC parameters for the ASL module These are stored in x.Output.ASL: ID - SubjectName ASL_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 SPM realign (too much motion is suspicious) MotionMean_mm - mean motion MotionExcl_Perc - percentage of excluded outliers MotionMax_mm - max motion MotionSD_mm - SD motion ASL quantification (strange average CBF, or strange GM-WM contrast) ASL acquisition parameters (should be fairly consistent over subjects/scans): TE - echo time TR - repetition time RescaleSlope - Philips Scaleslope - Philips Matrix X Y Z - matrix size Matrix Z - number of slices VoxelSize X Y - in plane resolution VoxelSize Z - slice thickness RigidBody2Anat_mm - Net Displacement Vector (RMS) from ASL to T1w image (mm) from registration xASL_qc_CollectQC_Structural.m Format: [x] = xASL_qc_CollectQC_Structural(x, iSubject) Description: This functions collects QC parameters for the structural module These are stored in x.Output.Structural: ID - SubjectName T1w_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 LST output: WMH_vol_mL - WMH volume WMH_n - WMH number of lesions CAT12 output: T1w_IQR_Perc - CAT12 IQR quality parameter for T1w volumetric: GM_vol_mL, WM_vol_mL, CSF_vol_mL, ICV_vol_mL, GM_ICV_Ratio xASL_qc_CollectQC_func.m Format: [x] = xASL_qc_CollectQC_func(x, iSubject) Description: This functions collects QC parameters for the func module These are stored in x.Output.func: ID - SubjectName func_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 SPM realign (too much motion is suspicious) MotionMean_mm - mean motion MotionExcl_Perc - percentage of excluded outliers MotionMax_mm - max motion MotionSD_mm - SD motion func quantification (strange average CBF, or strange GM-WM contrast) CBF_GM_Median_mL100gmin - median GM CBF CBF_WM_Median_mL100gmin - median WM CBF SpatialCoV_GM_Perc - GM spatial CoV SpatialCoV_WM_Perc - WM spatial CoV CBF_GM_WM_Ratio - GM-WM CBF ratio func acquisition parameters (should be fairly consistent over subjects/scans): TE - echo time TR - repetition time RescaleSlope - Philips Scaleslope - Philips Matrix X Y Z - matrix size Matrix Z - number of slices VoxelSize X Y - in plane resolution VoxelSize Z - slice thickness RigidBody2Anat_mm - Net Displacement Vector (RMS) from func to T1w image (mm) from registration xASL_qc_CollectSoftwareVersions.m Format: [x] = xASL_qc_CollectSoftwareVersions(x) Description: This functions collects software versions for Matlab, SPM, CAT, LST & ExploreASL If FSL is installed, it will obtain its version as well. These are stored in x.Output.Software. xASL_qc_CompareTemplate.m Format: [QC] = xASL_qc_CompareTemplate(x, ModPrefix, iSubjectSession) Description: This function computes several advanced template-based QC parameters: RMSE_Perc - Root Mean Square Error between image and template (%) nRMSE_Perc - Same but then normalized AI_Perc - Asymmetry Index between image and template (%) Mean_SSIM_Perc - mean structural similarity index -> xASL_stat_MeanSSIM.m PeakSNR_Ratio - peak signal-to-noise ratio -> xASL_stat_PSNR.m xASL_qc_ComputeFoVCoverage.m Format: [CoveragePerc] = xASL_qc_ComputeFoVCoverage(InputPath, x) Description: This function computes the intersection/overlap between brainmask on field-of-view (FoV) of low resolution image (native space) & the same brainmask with expanded FoV. It uses the pGM+pWM+pCSF as brainmask This assumes that the structural reference image has full brain coverage, and was properly segmented into GM, WM and CSF Also, we assume that the InputPath contains a single 3D volume xASL_qc_ComputeNiftiOrientation.m Format: [structOut] = xASL_qc_ComputeNiftiOrientation(PathNIfTI[, structIn]) Description: It loads the input Nifti, finds its dimension, voxel size and a net vector distance from its original position before registration. Adds all these information into an output structure structOut while copying all from structIn and keeping it intact. xASL_qc_CreatePDF.m Format: xASL_qc_CreatePDF(x[, DoSubject]) Description: This function iterates over all values in x.Output and all images in x.Output_im, and prints them in a PDF file. x.Output & x.Output_im should contain the QC/result output of all ExploreASL pipeline steps. Further code explanation: Below, using the Matlab & SPM Figure tools we create an image, which is then printed to a PDF file fg = the main Figure handle ax = \"axes\" handles, these are objects containing either 1) text or 2) images, with fg as \"parent\" (1) & (2) images have ax as \"parent\" Positions are calculated in such a way that 4 categories can be printed, which will be the first 4 fields found in x.Output then allowing 8 single slice images, and 15 text lines (name & value columns) xASL_qc_FA_Outliers.m Format: [FA_Outliers_mL] = xASL_qc_FA_Outliers(InputFA) Description: Extract the number of FA outliers, i.e. values of FA above 1 or below 0, from a FA image. xASL_qc_ObtainQCCategoriesFromJPG.m Format: xASL_qc_ObtainQCCategoriesFromJPG(x) Description: This function obtains QC categories as covariant/set, based on the JPGs in //Population/ASLCheck. These are initially sorted by spatial CoV, and should be visually checked & put in the correct folder. xASL_qc_PCPStructural.m Format: [anatQA] = xASL_qc_PCPStructural(PathT1, Pathc1T1, Pathc2T1, x, PopPathT1) Description: This function computes several anatomical QC parameters as proposed in SPM Univariate Plus: WM_ref_vol_mL - volume of the WM reference region (mL) WMref_vol_Perc - same but as percentage of total WM volume SNR_GM - GM signal-to-Noise Ratio (SNR), ie the mean intensity within GM divided by SD of WM reference region. Higher = better. CNR_GM_WM - GM-WM Contrast-to-Noise Ratio (CNR), i.e. the mean of GM - mean of WM divided by the SD of the WM reference region. Higher = better. FBER_WMref_Ratio - Foreground to Background Energy Ratio (FBER), i.e. the variance of voxels within the brain (in pGM+pWM mask) divided by the variance of voxels in the WM reference region. Higher = better. EFC_bits - Shannon Entropy Focus Criterion (EFC), i.e. the entropy of voxel intensities proportional to the maximum possibly entropy for a similarly sized image. Indicates ghosting and head motion-induced blurring. Lower = better. Mean_AI_Perc - mean relative voxel-wise absolute Asymmetry Index (AI) within the brain (pGM+pWM mask) (%) SD - same but SD (%) REFERENCES: Preprocessed Connectome Project Quality Assurance Protocol (QAP): http://preprocessed-connectomes-project.org/quality-assessment-protocol/ http://ieeexplore.ieee.org/document/650886/ xASL_qc_PrintOrientation.m Format: xASL_qc_PrintOrientation(niftiList, outputDir, outputFile); Description: This function lists NifTI orientation matrices before and after image processing, respectively nii.mat0 and nii.mat. In ExploreASL this is used for QC to detect accidental left-right flips, as these can occur unnoticed as the brain structure appears relatively symmetrical. This can be detected by negative determinants. Also, this can be used to detect any significant differences in acquisition or image processing. So orientation parameters and determinants should be similar across all scans from single scanner/coil, and registration should not give a relatively negative determinant. Results are saved in a TSV file This functions performs the following steps: 1. Print the header 2. Load the data 3. Print original orientation matrix 4. Print current orientation matrix 5. Print registration transformation matrix 6. Print FileName 7. Get statistics (mean & SD) xASL_qc_ReportLeftRightFlips.m Format: xASL_qc_ReportLeftRightFlips(dirRoot [, bZip]) Description: This function identifies and reports illegal left-right flips for image matrices within a NIfTI. This can be useful as these are not readily observed by the human eye, as the left and right hemispheres are too symmetrical by default. All NifTIs are found recursively (i.e. in the folder and its subfolders), irregardless of them being .nii or .nii.gz. xASL_qc_TanimotoCoeff.m Format: TC = xASL_qc_TanimotoCoeff(Image1, Image2[, imMask, type]) Description: Compares images Image1 and Image2 within the mask imMask. TYPE specifies the input data type. RATIONALE: Note that the Tanimoto Coefficient is a measure of image overlap/intersection, similar to the Dice coefficient. With the option type 3, this is a fuzzy coefficient, which doesn't require to convert the two images to a binary mask. The TC can be interpreted as a stringent Kappa, ranging from 0 (completely dissimilar) to 100% (identical images). Assuming that perfect registration should not lead to identical images but still retain physiological differences, TC>70% can be regarded as excellent image agreement. The TC will be overestimated when smoothing, but this may lead to more stable artifact detection. xASL_qc_WADQCDC.m Format: xASL_qc_WADQCDC(x, iSubject[, ScanType]) Description: This QC function runs WAD-QC specific Python script to zip QC information & incorporate this into a DICOM field for analysis on the WAD-QC server, by the following: Define QCDC script: this is the Python script written by Gaspare, edited by Joost Kuijer & copied to the EPAD CustomScripts folder of ExploreASL Python installation location is checked, with several known locations, for several servers. If we cannot find it, the QCDC is not ran Previous QCDC results are cleaned. QCDC stores all its results in a separate folder (Something like 2 layers up from the current folder, here referred to as QCDCDir = [x.D.ROOT 'qcdc_output']) from these result files, only the filled DICOM file is interesting, all the rest are copies of the QC results that we embedded into the DICOM Run QCDC (if Python installation detected) The following files need to be set as executable: ('QCDC', 'src', 'qc_data_collector.py') ('QCDC', 'src', 'bash', 'create_dcm_only_wadqc.sh') ('QCDC', 'src', 'bash', 'sendwadqc.sh') Clean up new QCDC results (as above) & move the filled DICOM to ['qcdc_' DummyFile] within the current ScanType folder Sending the DICOM to the WAD-QC server using storescu xASL_qc_WADQC_GenerateDescriptor.m Format: xASL_qc_WADQC_GenerateDescriptor(x, iSubject) Description: This QC function generates a JSON descriptor for Gaspare' QCDC script, by the following steps: a) include information about where to find the dummy DICOM (i.e. placeholder DICOM) b) For ExploreASL' QC fields (as passed through in x.Output), here we note all these QC fields for each ScanType, as the x.Output should have been collected equally in the QC file 'QC_collection_SubjectName.json' by function xASL_qc_CollectParameters c) Subfunction xASL_qc_WADQC_images - Includes visual standard space QC images, by searching them on prescribed paths within the Population folder (where currently all derivatives reside) d) Insert the PDF report; this PDF report is subject-specific, not scan-specific. For completeness it is added to each QCDC descriptor e) Add WAD-QC server details (i.e. IP address etc) f) Save the Descriptor JSON file. xASL_qc_temporalSNR.m Format: tSNR = xASL_qc_temporalSNR(pathIm4D,pathImTissueProb) Description: This function computes several temporal SNR QC parameters as proposed in SPM Univariate Plus: tSNR.tSNR_GM_Ratio : mean GM signal / std GM over time tSNR.tSNR.tSNR_WM_Ratio : mean WM signal / std WM over time tSNR.tSNR.tSNR_CSF_Ratio: mean CSF signal / std CSF over time tSNR.tSNR_WMref_Ratio : mean signal/std over time in eroded deep WM tSNR.tSNR_GMWM_Ratio : mean (GM+WM) signal / sqrt(std(GM+WM)^2+std(WMref)^2) tSNR.tSNR_GMWM_WMref_Ratio: mean (GM+WM) signal / std WMref over time tSNR.tSNR_Physio2Thermal_Ratio: sqrt((tSNR(GM+WM)/tSNR_GMWM_WMref_Ratio))^2-1) tSNR.tSNR_Slope_Corr: Differences to the SPM U+ suggestion: eroded WM is used for estimating background noise Brainmask is determined in the same way as the structural anatQC, CSF is determined from the pGM&pWM maps; REFERENCES: 1. Thomas Liu (2016). Noise contributions to the fMRI signal: An overview NeuroImage, 343, 141-151 http://dx.doi.org/10.1016/j.neuroimage.2016.09.008 2. Cesar Caballero-Gaudes and Richard C. Reynolds (2016). Methods For Cleaning The BOLD fMRI Signal. NeuroImage, 154,128-149 3. Lawrence Wald and Jonathan R Polimeni (2016). Impacting the effect of fMRI noise through hardware and acquisition choices ??? Implications for controlling false positive rates. NeuroImage, 154,15-22 4. SPM Utility + toolbox. Cyril Pernet. https://osf.io/wn3h8/ Quantization xASL_quant_AgeSex2Hct.m Format: [Hematocrit] = xASL_quant_AgeSex2Hct([age, sex]) Description: This function estimates a participants hematocrit, based on literature-based values for age and sex. It performs the following steps: Warning unknown age/sex Imputing unknown age/sex Define hematocrit per age for unknown sex Define Hematocrit per age for males Define Hematocrit per age for females xASL_quant_BSupCalculation.m Format: signalPercentage = xASL_quant_BSupCalculation(BackgroundSuppressionPulseTime, ReadoutTime[, PresaturationTime, T1Time, SliceTime, PathGraph]) Description: This function computes the tissue signal percentage that remains after background suppression pulses are played in the ASL acquisition. It assumes that the signal is, at first, optionally saturated by a 90 degree flip at PresaturationTime before readout. Then follows a series of BSup pulses (times before readout are given) that do a 180 degree flip. The observed tissue relaxes with time T1time and the signal attenuation is calculated for several slices acquired at times relative to the readout. xASL_quant_Basil.m Format: [CBF_nocalib] = xASL_quant_Basil(PWI, x) Description: This script performs quantification of the PWI using the FSL Basil pipeline. Final calibration to physiological units is performed by dividing the quantified PWI by the M0 image/value. This function performs the following steps: 1. Define paths 2. Delete previous BASIL output 3. Write the PWI as Nifti file for Basil to read as input 4. Create option_file that contains options which are passed to Fabber 5. Run Basil and retrieve CBF output 6. Scaling to physiological units 7. Householding xASL_quant_FEAST.m Format: xASL_quant_FEAST(x) Description: This function quantifies ATT using the FEAST equations, using crushed and non-crushed sessions, of which the ratio is proportional to ATT. Note that the order of sessions should be 1) crushed 2) non-crushed This function runs the following steps: Skip this function if no FEAST data available Admin Load data & correct for timing differences (PLD etc) Smooth and clip CBF maps & FEAST ratio Compute TT maps xASL_quant_GetControlLabelOrder.m Format: [ControlIM, LabelIM, OrderContLabl] = xASL_quant_GetControlLabelOrder(FramesIn, x) Description: This function automatically checks (and corrects if required) the control and label order of ASL timeseries based on the larger signal in control volumes. It supposes that data is acquired in pairs. xASL_quant_Hct2BloodT1.m Format: BloodT1 = xASL_quant_Hct2BloodT1(Hematocrit, Y, B0, bVerbose) Description: This function converts hematocrit to blood T1, according to calculations defined by Patrick Hales. With courtesy and thanks! Note that we assume a venous O2 saturation of 68% (Yv=0.68) This function performs the following steps: Check fraction vs percentage hematocrit & Y, should be between 0 and 1 Specify defaults (Hb, Fe) Perform calculation Convert s to ms Print what we did xASL_quant_M0.m Format: [M0IM] = xASL_quant_M0(inputM0, x) Description: This function quantifies the M0, except for the difference in voxel size between the M0 and ASL source data (which is scaled in xASL_wrp_ProcessM0.m). This function runs the following steps: Correct scale slopes, if Philips Convert control image with background suppression to pseudo-M0 Skip M0 quantification if ~x.Q.ApplyQuantification(4) Set TR specifically for GE Check for correct TR values Quantify the M0, either for single 3D volume or slice-wise Apply custom scalefactor if requested (x.modules.asl.M0_GMScaleFactor) xASL_quant_SinglePLD.m Format: [ScaleImage[, CBF]] = xASL_quant_SinglePLD(PWI, M0_im, imSliceNumber, x) Description: This script performs a multi-step quantification, by initializing a ScaleImage that travels through this script & gets changed by the following quantification factors: PLD scalefactor (gradient if 2D multi-slice) (if x.Q.ApplyQuantification(3)) Label decay scale factor for single (blood T1) - or dual-compartment (blood+tissue T1) model, CASL or PASL Single-compartment model: Alsop MRM 2014 Dual-compartment model: Wang MRM 2002: Gevers JMRI 2012 (if x.Q.ApplyQuantification(3)) Scaling to physiological units [ml/gr/ms =>ml/100gr/min =>(60,000 ms=>min)(1 gr=>100gr)] (if x.Q.ApplyQuantification(3)) Manufacturer-specific scalefactor (if x.Q.ApplyQuantification(1) -> future move to dcm2niiX stage) Finally, we: Divide PWI/M0 (if x.Q.ApplyQuantification(5)) Print parameters used Note that the output always goes to the CBF image (in the future this could go to different stages, e.g. dcm2niiX or PWI stage) Note that BASIL is also implemented, but it doesn't allow a standard space quantification yet (it would need to use imSliceNumber) xASL_quant_SliceTiming.m Format: SliceTiming = xASL_quant_SliceTiming(x, inputIm) Description: This function takes the x.Q.SliceReadoutTime and returns the SliceTiming parameter. The function creates a vector (of the relatives timings for each slices) out of it with the correct length corresponding to the number of slices in the inputIm corresponding to the BIDS definition. It also checks the x.Q.readoutDim, and for 3D readouts it returns 0. It loads the image from inputIm and calculates the SliceTiming according to the number of slices in the third dimension If a path is given, it also checks if it can find a JSON sidecar, then it loads the JSON sidecar, and looks for SliceTiming inside it. If SliceTiming/SliceReadoutTime is found in the JSON sidecar, it prioritize it over the value in the x-struct For reference, we use these terms: SliceTiming (the BIDS parameter) - it is a vector with the same length as the number of slices and contains the timing of the start of the readout of each slice relative to the first slice SliceReadoutTime - Legacy xASL parameter that will be phased out. It contains either a vector matching the BIDS definition of SliceTiming or a scalar with difference in readout times between the consecutives slices (i.e. the xASL legacy definition of SliceTiming) SliceTimingDiff - Internal parameter in this function for calculating the time difference between consecutive slices. Admin ShortestTR Assign the vector value and check for vector consistency xASL_quant_SliceTiming_ShortestTR.m Format: [x] = xASL_quant_SliceTiming_ShortestTR(x) Description: When the TR is set to \"shortestTR\" in the ASL acquisition, each ASL scan will have its unique TR. As this is shortest, there won't be a delay between the readout of the last slice and the end of the TR. Therefore, the time to read out all slices is TR - InitialPostLabelDelay - LabelingDuration, and dividing this by the number of slices gives the SliceReadoutTime SPM xASL_spm_BiasfieldCorrection.m Format: xASL_spm_BiasfieldCorrection(PathIn, SPMdir, Quality, MaskName, PathOut) Description: This function is a wrapper around the SPM \"old segment\" function, for biasfield removal. It is tested for M0 and mean control images. It conducts the following steps: Create implicit mask Define SPM 'old segmentation' settings Run SPM 'old segmentation' Delete temporary files Rename temporary SPM file into output file xASL_spm_affine.m Format: xASL_spm_affine(srcPath, refPath, fwhmSrc, fwhmRef[,otherList, bDCT, bQuality]) Description: This SPM wrapper runs SPM's old normalize-estimate function, which calculates the affine transformation (i.e. linear + zooming and shearing) that is required to align the source image with the reference image. By default it does not estimate the low-degree Discrete Cosine Transform (DCT) to have a simple affine transformation but this can be enabled in this wrapper. Also note that this affine transformation uses a correlation cost function, hence it requires the source and reference images to have similar contrasts and resolution - or provide the resolution estimates so the smoothing can be done. This function does not change the orientation header by default, but it allows to change those of others through the otherList. If bDCT is used or no otherList given, it stores its estimated affine transformation as orientation difference matrix in a file with the same path but _sn.mat extension. For the provided smoothing FWHM, note that smoothnesses combine with Pythagoras' rule (i.e. square summing). xASL_spm_coreg.m Format: xASL_spm_coreg(refPath, srcPath[, OtherList, x, sep, FastReg]) Description: This SPM wrapper runs SPMs coregister-estimate function, which calculates the 6 parameter rigid-body transformation (a.k.a. linear) that is required to align the source image with the reference image. This 6 parameter transformation (i.e. 3 XYZ translations and 3 rotations) is applied to the orientation header of the source NIfTI image, and also to the images provided in OtherList (optional). Note that this SPM registration function uses a normalized mutual information (NMI) by default, enabling registration between two images with different contrast. Note that this algorithm will use the first volume of a multi-volume NIfTI xASL_spm_deface.m Format: xASL_spm_deface(PathIn, bReplace) Description: This function removes the face from an anatomical NIfTI image, e.g. T1w or FLAIR, for disidentification/privacy purposes. When this script is run after the ExploreASL structural module, it does a pretty good job even for 2D images. However, note that this can always fail, strip part of the brain, or change the output of pipelines. So best not to compare results from defaced and non-defaced images. Also, note that defacing makes it difficult to ensure that the FLAIR and T1w are from the same subject. xASL_spm_deformations.m Format: xASL_spm_deformations([x,] PathIn, PathOut[, Interpolation, InverseSpace, AffineTrans, DeformationPath]) Description: This ExploreASL wrapper manages the SPM deformation tool. It takes multiple (ExploreASL pipeline) transformations and combines/concatenates them into a single transformation prior to applying it to the input images. This allows to apply multiple transformations with a single interpolation, avoiding propagation of undesired interpolation effects. Mainly used to get native space images into standard space, or vice versa. Best to combine as many files as possible within this function, since the deformation calculation (which is the most computation intensive part) needs to be performed once for multi-file resampling This function runs the following steps: Statistics xASL_stat_AtlasForStats.m Format: [x] = xASL_stat_AtlasForStats(x) Description: This function loads atlases, checks them, and their ROI names, for later use as ROI definition in xASL_stat_GetROIstatistics Note that the atlases should be integer values, or different 4rd dimensions (i.e. multiple images), that are mutually exclusive. This function takes the following steps: Load atlas ROI names There should be a TSV sidecar to the atlas NIfTI file, as explained above. deal with memory mapping Resample atlas 50 1.5 mm^3 MNI Converted atlas with integers to 4D binary image Convert/compress masks into Columns Print atlas overview image xASL_stat_ComputeDifferCoV.m Format: diffCoV = xASL_stat_ComputeDifferCoV(imCBF) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask,bPVC,imGM,imWM) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask,bPVC,imGM,imWM,b3D) Description: It calculates the spatial DiffCoV value on finite part of imCBF. Optionally a mask IMMASK is provide, and PVC is done for bPVC==2 using imGM and imWM masks and constructing pseudoCoV from pseudoCBF image. For bPVC~=2, imGM and imWM are ignored. It is calculated in 2D or assuming also 3D edges based on B3D. Calculate derivate spatial CoV, by summing up differences in CBF between neighbors. The derivative uses Sobels filter. xASL_stat_ComputeMean.m Format: [CBF_GM CBF_WM] = xASL_stat_ComputeMean(imCBF[, imMask, nMinSize, bPVC, bParametric, imGM, imWM]) Description: It calculates mean or median of CBF over the mask imMask if the mask volume exceeds nMinSize. It calculates either a mean, a median, or a mean after PVC, depending on the settings of bPVC. For the PVC options, it needs also imGM and imWM and returns the separate PV-corrected values calculated over the entire ROI. Admin Mask calculations Calculate the ROI statistics 3a. No PVC and simple mean 3b. No PVC and median 3c. Simple PVC 3d. Full PVC on a region xASL_stat_ComputeSpatialCoV.m Format: sCov = xASL_stat_ComputeSpatialCoV(imCBF[, imMask, nMinSize, bPVC, bParametric, imGM, imWM]) Description: It calculates the spatial CoV value on finite part of imCBF. Optionally a mask IMMASK is provide, ROIs of size < NMINSIZE are ignored, and PVC is done for bPVC==2 using imGM and imWM masks and constructing pseudoCoV from pseudoCBF image. For bPVC~=2, imGM and imWM are ignored Admin Create masks sCoV computation xASL_stat_EqualVariancesTest.m Format: [resTest, P] = xASL_stat_EqualVariancesTest(X[, alpha, type]) Description: Brown-Forsythe or Levene's test for equality of variances. The response variable is transformed (yij = abs(xij - median(xj)) for Brown-Forsythe and yij = abs(xij - mean(xj)) for Levene's test). And then runs a one-way ANOVA F-test to check if the variances are equal. xASL_stat_GetROIstatistics.m Format: [x] = xASL_stat_GetROIstatistics(x) Description: This function computes mean and spatial CoV for each ROI, in a [1.5 1.5 1.5] mm MNI space, with several ASL-specific adaptions: Skip ROI masks that are smaller than 1 mL as this would be too noisy for ASL (ignored when x.S.IsASL==false) Expand each ROI mask such that it has sufficient WM content (skipped when IsASL==false) Create for each ROI mask a left, right and bilateral copy Iterate over all subjects: a) Load partial volume maps b) Correct for WMH SEGM -> IS THIS STILL REQUIRED??? c) Load data d) Show ROIs projected on ASL image e) Actual data computations Partial Volume Correction (PVC) options: PVC==0 -> perform masking only, no regression PVC==1 -> single compartment regression, for pGM PVC==2 -> dual compartment regression for pGM & pWM (i.e. normal PVC) Here we mask out susceptibility artifacts (including outside FoV) for all ASL computations, and also mask out vascular artifacts for computing the mean. While other artifacts/FoV can be masked out on population level (i.e. >0.95 subjects need to have a valid signal in a certain voxel), vascular artifacts differ too much in their location between subjects, so we mask this on subject-level. Note that the words \"mask\" and \"ROI\" are used interchangeably throughout this function, where they can have a different or the same meaning PM: WE COULD CHANGE THIS, INTO MASK BEING USED TO EXCLUDE VOXELS AND ROI FOR INCLUDING VOXELS xASL_stat_MadNan.m Format: y = xASL_stat_MadNan(x[,flag, dim]) Description: Calculates a Median/Mean Absolute deviation, but ignoring NaNs in the calculation. xASL_stat_MadNan(X) or xASL_stat_MadNan(X,0) computes xASL_stat_MeanNan(ABS(X-xASL_stat_MeanNan(X)) xASL_stat_MadNan(X,1) computes xASL_stat_MedianNan(ABS(X-xASL_st_MedianNan(X)). xASL_stat_MeanSSIM.m Format: mssim=xASL_stat_MeanSSIM(imRef,imSrc[,dynRange]) Description: Calculates the similarity index according to Want et al. xASL_stat_MultipleLinReg.m Format: [b,CI,pval,stats] = xASL_stat_MultipleLinReg(X,Y[,bIntercept]) Description: Performs a multiple linear regression Y=b*X+a and provides the intercept and regression coefficients beta including their significance and confidence intervals. It calculates additionally the goodness of the fit. xASL_stat_PSNR.m Format: PSNR=xASL_stat_PSNR(imRef,imSrc) Description: Calculates the PSNR, needs two input arguments - 3D images of the same size. Uses 95% percentile instead of MAX. xASL_stat_PairwiseDice.m Format: [DiceCoeff] = xASL_stat_PairwiseDice(GroupA, GroupB) Description: This function obtains for two lists of images Dice coefficients, for all possible permutations of both lists, by the following steps: 1. Admin (check cell, image exist etc) 2. Obtain matrix of pair-wise permutations 3. Obtain DICE scores PM: Allow entering one group only PM: could extend with xASL_qc_TanimotoCoeff xASL_stat_PrintStats.m Format: [x] = xASL_stat_PrintStats(x) Description: This function prints an overview of statistics from data that were acquired per ROI, in a TSV file. It starts by printing covariates (called \"Sets\"). Rows will be subjects/sessions, columns will be the sets and ROI-statistics. Any missing data will be skipped (setting them to NaN should have happened in a previous function). This function performs the following steps: First remove previous TSV-file, if already existed printing to a TSV file can be tricky if it is opened by Excel. Make sure to close previous versions first, otherwise this part will crash. Print overview of sets to TSV as explained above. Uses subfunction xASL_stat_CreateLegend to put legends. Aim is to create a single TSV file that has a proper overview of the data, & is self-explanatory to those reading/using it. Define number of ASL sessions, force to 1 in case of TT or volume metrics Print the overview xASL_stat_QuantileNan.m Format: y = xASL_stat_QuantileNan(x[,quant, dim]) Description: Calculates a quantile, but ignoring NaNs in the calculation xASL_stat_RobustMean.m Format: [NoOutliers, iOutliers, ThresholdDeviation] = xASL_stat_RobustMean(IM, ParameterFunction) Description: This function detects outlier images, that can be used to create a robust average, e.g. for template or biasfield creation. This is based either on the sum-of-squares with the mean image (SoS), or on the average relative asymmetry index (AI). Images that are median+/-3 mad off are defined as outliers. MAD = median/mean absolute difference xASL_stat_ShapiroWilk.m Format: [H, P, W] = xASL_stat_ShapiroWilk(x[, alpha]) Description: Performs the statistical test of normality - null hypothesis is that the sample is from normal distribution with unspecified mean and variance. Based on the sample kurtosis it performs either Shapiro-Wilk (for platykurtic) or Shapiro-Francia test (for leptokurtic). xASL_stat_StdNan.m Format: y = xASL_stat_StdNan(x[,w,dim]) Description: It behaves in a similar way as VAR - it directly passes all arguments to xASL_stat_VarNan. xASL_stat_SumNan.m Format: y = xASL_stat_SumNan(x[,dim]) Description: It uses the function SUM, but it sets all the NaNs to zero before calling it. xASL_stat_UniquePairwisePermutations.m Format: [PermutationList] = xASL_stat_UniquePairwisePermutations(GroupA, GroupB) Description: This function lists for one or two samples of indices all possible permutations of indices, performing the following steps: One sample permutations Two sample permutations Print conclusion PM: Allow entering one group only PM: could extend with xASL_qc_TanimotoCoeff xASL_stat_VarNan.m Format: y = xASL_stat_VarNan(x[,w,dim]) Description: It behaves in a similar way as VAR. xASL_stat_fcdf.m Format: F = xASL_stat_fcdf(F,M,N) Description: Calculates the cumulative distribution function of the F-distribution for degrees of freedom M,N at value F. xASL_stat_tcdf.m Format: F = xASL_stat_tcdf(T,nu) Description: Calculates the cumulative distribution function of the Student's t-distribution for degrees of freedom nu at value T. xASL_stat_ticdf.m Format: T = xASL_stat_ticdf(P,nu) Description: Calculates the inverse of cumulative distribution function of the Student's t-distribution for degrees of freedom nu at value P. xASL_stat_ttest.m Format: [H,P,CI,stats] = xASL_stat_ttest(X[,M,alpha,tail,dim]) Description: Performs a t-test that the distribution of the input data X has a mean different from 0 (or from a given mean M, or that the distributions X and Y have different means). A normal distribution of the data with an unknown variance is assumed. xASL_stat_ttest2.m Format: [H,P,CI,stats] = xASL_stat_ttest2(X,Y[,alpha,tail,vartype,dim]) Description: Performs a unpaired t-test that the distribution of the input data X has a mean different from that of Y. A normal distribution of the data with an unknown variance is assumed. xASL_str2num.m Format: [DataOut] = xASL_str2num(DataIn[, bKeepCell, bReplaceNonNumerical]) Description: str2num wrapper, which only converts strings to numbers, and allows inputting cells. Also, it replaces 'n/a' with NaN (BIDS convention). And it has some other functionality as described in bKeepCell & bReplaceNonNumerical above. xASL_test_Flavors.m Format: xASL_test_Flavors(pathExploreASL, pathTest[, bTest, x]) Description: Runs the full testing on import and processing of the FlavorsDatabase. The testing directory path has to be provided with the FlavorsDatabase subdirectory containig the Flavors - this subdirectory is read, but not modified. New directories are created for that inside the test directory. xASL_test_Flavors_DCM2BIDS.m Format: xASL_test_Flavors_DCM2BIDS(baseDirImport) Description: Runs the DICOM to ASL-BIDS import for all data in the baseDirImport directory. Study directories are supposed to be in, containing a 'sourcedata' folder - this folder can contain subject directories and also sourceStructure.json and studyPar.json specifying the directory structure and the additional study parameters, respectively. The import creates first the 'temp' subfolder with data after dcm2nii and with all tags read and saved to JSON. Then it assembles everything with the studyParameters and makes sure all is in BIDS format and saves it correctly in the 'rawdata' subdirectory. This function runs the following sections: 1. Initialization 2. DICOM -> NII+JSON (i.e. dcm2niiX) 3. Manual curation for certain flavors 3a. Siemens_PCASL_3DGRASE_VD13D_2 3b. Philips_PCASL_3DGRASE_5.4.1.0_TopUp_1 3c. Siemens_PCASL_3DGRASE_VB17A_TopUp_1 3d. Siemens_PCASL_3DGRASE_VB17A_multiPLD_1 4. Convert NII+JSON -> BIDS xASL_test_GetLogContent.m Format: [logContent] = xASL_test_GetLogContent(rootDir, [printContent], [storeRelativePath], [exportTable]) Description: Get warnings and errors from log files. Input check Load all log files Iterate over log files Optional: Print log content Optional: Export (0 = no export, 1 = TSV export, 2 = XLSX export) Visualization xASL_vis_AddIM2QC.m Format: [x] = xASL_vis_AddIM2QC(x,parms); Description: Checks which images already are loaded, and adds new image. xASL_vis_CreateVisualFig.m Format: [ImOut, FileName] = xASL_vis_CreateVisualFig(x, ImIn[, DirOut, IntScale, NamePrefix, ColorMap, bClip, MaskIn, bWhite, MaxWindow, bTransparancy, bVerbose, bContour]) Description: This function creates a visualization Figure by merging flexibly rearranging NIfTI slices, input matrix or path, managing colormaps for different merged image layers. Current use is for visual QC figures and overview in papers. Function is structured as: Admin, deal with input arguments Process image layers separately * xASL_im_TransformData2View: Reshapes image data into visualization figure * xASL_im_ClipExtremes: Clips image to given percentile also we scale for peak intensity, we make sure that there is no visible clipping/distortion * Convert to colors, using any input colormaps combine image layers, using input argument IntScale print figure This function assumes that the first image is a grayscale background image (e.g. for transparancy reasons), if there are multiple images xASL_vis_CropParmsAcquire.m Format: [xmin xmax ymin ymax] = xASL_vis_CropParmsAcquire(temp_image) Description: Goes from outside to inside to acquire crop settings. Works with grayscale images (2 dimensions per slice). Image position information (2D matrix) should be first 2 dimensions. Could include colordimension later on. xASL_vis_CropParmsApply.m Format: ImageOut = xASL_vis_CropParmsApply(ImageIn,CropParameters) Description: This function crops 2D image matrices. xASL_vis_Imwrite.m Format: [ImOut] = xASL_vis_Imwrite(ImIn, PathOut[, ColorMap, bRescale]) Description: This functions takes an input image matrix, interpolates it to HD resolution (1920x1080) for visibility, and saves the image as jpg. This function avoids the graphic interface of Matlab, for running from CLI Careful: this function overwrites any existing PathOut. xASL_vis_OverlapT1_ASL.m Format: xASL_vis_OverlapT1_ASL( x, ASL) Description: Part of ExploreASL. Shows spatial agreement ASL and probability maps. xASL_vis_TileImages.m Format: [ImOut] = xASL_vis_TileImages(ImIn, nColumns) Description: Merges selected slices (3D) into one single 2D picture. Plots all slices in one figure with specified rows and columns, aiming for a square tile. PM: can be extended to multiple slices xASL_vis_TransformData2View.m Format: FigureOut = xASL_vis_TransformData2View(ImagesIn, x) Description: This function changes the dimensionality and reshapes the input images in such a way that they are nicely tiled in a mosaic for visualization purposes. Reshaping a series of images with this function can be useful for visualization of SPM/voxel-based analyses. xASL_vis_VisualQC_TopUp.m Format: [MeanAI_PreTopUp_Perc, MeanAI_PostTopUp_Perc] = xASL_vis_VisualQC_TopUp(PathPopB0, PathPopUnwarped, x, iSubject, CheckDir) Description: This function creates a Figure that showes the effect of TopUp with 6 images with axial slices: the NormPE, RevPE and their difference image in colorscale, and this before (upper row) & after (lower row) TopUp. xASL_vis_VisualizeROIs.m Format: xASL_vis_VisualizeROIs(x, ROI_list) Description: Creates for each subject a JPEG image containing the original T1w, WMH_SEGM and T1w after lesion-filling. xASL_wrp_LinearReg_Others2T1w.m Format: xASL_wrp_LinearReg_Others2T1w(x[, bAutoACPC]) Description: This submodule registers T1c and T2 linearly to the T1w","title":"Functions"},{"location":"Functions/#functions","text":"","title":"Functions"},{"location":"Functions/#general-functions","text":"","title":"General Functions"},{"location":"Functions/#xasl_iterationm","text":"Format: [bAborted, xOut] = xASL_Iteration(x, moduleName[, dryRun, stopAfterErrors]) Description: Parses the settings and runs the DatabaseLoop sub-function.","title":"xASL_Iteration.m"},{"location":"Functions/#administration","text":"","title":"Administration"},{"location":"Functions/#xasl_adm_catchnumbersfromstringm","text":"Format: [OutputNumber] = xASL_adm_CatchNumbersFromString(InputString) Description: Extracts a number from a char array.","title":"xASL_adm_CatchNumbersFromString.m"},{"location":"Functions/#xasl_adm_checkfilecountm","text":"Format: [result, files] = xASL_adm_CheckFileCount(path, expr[, mincount, failifmissing]) [result] = xASL_adm_CheckFileCount(...) Description: Checks the given PATH for files corresponding to the SPM_SELECT regular expression EXPR . Returns if the number of files is equal to or higher than MINCOUNT . If FAILIFMISSING is true and not enough files, then throw and error. If everything goes ok and second output argument is specified then return also the list of files.","title":"xASL_adm_CheckFileCount.m"},{"location":"Functions/#xasl_adm_checkpermissionsm","text":"Format: [FilesList, FilesExeList, FoldersList] = xASL_adm_CheckPermissions(InputPath[, FilesExecutable]) Description: This function does a recursive search through the root folder & makes a list of the attributes of all files and folders. It tries to reset the attributes to what we desire, which is by default: 664 for files (meaning only reading & writing for users & group, & read-only for others) 775 for folders (meaning reading, writing & opening for current user & current group, & for others only reading & opening) For executable files we also want 775. Note that the permission to 'execute a folder' means opening them. DataOK checks data permissions. ExeOK checks executable permissions. DataOK also includes executable permissions for folders. This runs recursively (but currently skips the contents of the root-folder) .","title":"xASL_adm_CheckPermissions.m"},{"location":"Functions/#xasl_adm_checkspmm","text":"Format: [spm_path, spm_version] = xASL_adm_CheckSPM([modality, proposed_spm_path, check_mode]) [spm_path] = xASL_adm_CheckSPM(...) xASL_adm_CheckSPM(...) Description: Checks if the spm function exists and if the reported version matches our development version ( SPM8 or SPM12 ). If the spm toolbox is not available yet, it will try the PROPOSED_SPM_PATH (if specified) or the user selected directory and add it to PATH . The function will fail if SPM cannot be found or if detecting an unsupported version.","title":"xASL_adm_CheckSPM.m"},{"location":"Functions/#xasl_adm_cleanupbeforererunm","text":"Format: xASL_adm_CleanupBeforeCompleteRerun(AnalysisDir, iModule, bRemoveWMH, bAllSubjects, SubjectID) Description: This function (partly) reverts previous ExploreASL runs, deleting derivatives, while keeping raw data intact. if bAllSubjects==true, then all subjects and all module derivatives will be removed. This function performs the following steps: If a Population folder doesn't exist yet but dartel does, rename it Remove whole-study data files in AnalysisDir if bAllSubjects Remove lock files/folders for reprocessing Restore backupped _ORI (original) files Delete native space CAT12 temporary folders (always, independent of iModule) Remove native space files for iModule Remove standard space files for iModule Remove population module files Remove or clean up stored x-struct & QC file -> THIS HAS NO SESSION SUPPORT YET NB: still need to add xASL_module_func & xASL_module_dwi for EPAD","title":"xASL_adm_CleanUpBeforeRerun.m"},{"location":"Functions/#xasl_adm_comparedatasetsm","text":"Format: [RMS] = xASL_adm_CompareDataSets(RefAnalysisRoot,SourceAnalysisRoot,x,type,mutexState) Description: Compare data sets is used to ... type 0: Only save type 1: Save and evaluate type 2: Only evaluate","title":"xASL_adm_CompareDataSets.m"},{"location":"Functions/#xasl_adm_comparelistsm","text":"Format: [NewList] = xASL_adm_CompareLists(list1, list2) Description: This script compares two single dimension lists.","title":"xASL_adm_CompareLists.m"},{"location":"Functions/#xasl_adm_convertdate2nrm","text":"Format: [Nr DayInYear] = xASL_adm_ConvertDate2Nr(TempDate) Description: Converts date to number input mmdd -> output mm (with days in fractions/floating point). Inverse from ConvertNrDate.","title":"xASL_adm_ConvertDate2Nr.m"},{"location":"Functions/#xasl_adm_convertnr2timem","text":"Format: Time = xASL_adm_ConvertNr2Time(Nr) Description: Converts number to time input hh (with minutes in fractions/floating point) -> output hhmm. Inverse from xASL_adm_ConvertTime2Nr.","title":"xASL_adm_ConvertNr2Time.m"},{"location":"Functions/#xasl_adm_convertsubjsess2subj_sessm","text":"Format: [iSubj iSess] = xASL_adm_ConvertSubjSess2Subj_Sess(nSessions, iSubjSess) Description: Converts combined SubjectSession index to subject & session indices. Useful for data lists in ExploreASL.","title":"xASL_adm_ConvertSubjSess2Subj_Sess.m"},{"location":"Functions/#xasl_adm_converttime2nrm","text":"Format: Nr = xASL_adm_ConvertTime2Nr(Time) Description: Converts time to number input hhmm -> output hh (with minutes in fractions/floating point). Inverse from xASL_adm_ConvertNr2Time.","title":"xASL_adm_ConvertTime2Nr.m"},{"location":"Functions/#xasl_adm_copymovefilelistm","text":"Format: [List] = xASL_adm_CopyMoveFileList(OriDir, DstDir, StrRegExp, bMove[, bDir, bRecursive, bOverwrite, bVerbose]) Description: Moves a file to a file, a file to a directory, or a directory to a directory. It keeps the initial extensions, no unzipping or zipping after the move. But it makes sure that only one of .nii and .nii.gz exists in the destination directory. Useful to split a large database.","title":"xASL_adm_CopyMoveFileList.m"},{"location":"Functions/#xasl_adm_correctnamem","text":"Format: strOut = xASL_adm_CorrectName(strIn[, bOption, strExclude]) Description: Finds and replaces all non-word characters either by empty space or by an underscore. Optionally leaves in few selected special characters. Note that if '_' is excluded from replacement, but option 2 is on, then underscores are replaced anyway.","title":"xASL_adm_CorrectName.m"},{"location":"Functions/#xasl_adm_createfilereportm","text":"Format: x = xASL_adm_CreateFileReport(x, bHasFLAIR, bHasMoCo, bHasM0, bHasLongitudinal) Description: Prints a summary of created files or the individual modules (i.e. Structural, Longiutudinal & ASL modules). Provides a quick check to see what has been skipped, an whether all files are present. This script iterates across: Native space 1) subject and 2) session files, Resampled 3) subject and 4) session files, 5) Lock files and 6) QC Figure files. For all we perform a: A) Count of the files present, summarized in FileReportSummary.csv B) List of the missing files in \"Missing*.csv\" files PM: Simplify/optimize this code, to make filename variable changing, search within subject-directories, etc. Combine the parts searching for missing & summarizing count.","title":"xASL_adm_CreateFileReport.m"},{"location":"Functions/#xasl_adm_defineaslresolutionm","text":"Format: x = xASL_adm_DefineASLResolution(x) Description: If the parameters x.ResolutionEstimation == 1, it initializes the resolution with expected values per sequence type and then runs the procedure xASL_im_ResolutionEstim to estimate the resolution from the mismatch between ASL and structural data. For x.ResolutionEstimation == 0, xASL_init_DefaultEffectiveResolution the educated guess is used for the estimated resolution using previous data and analyzis.","title":"xASL_adm_DefineASLResolution.m"},{"location":"Functions/#xasl_adm_defineaslsequencem","text":"Format: [x] = xASL_adm_DefineASLSequence(x) Description: This ExploreASL function tries to check what ASL sequence is being processed, if this was not already defined in x.Q.Sequence. It does so by checking known combinations of readout dimensionality (x.Q.readoutDim) and Vendor, knowing the product sequences of the Vendors.","title":"xASL_adm_DefineASLSequence.m"},{"location":"Functions/#xasl_adm_deletefilepairm","text":"Format: filepaths = xASL_adm_DeleteFilePair(path, ext1[, ext2 [, ext3 ...]]) xASL_adm_DeleteFilePair(path, ext1[, ext2 [, ext3 ...]]) Description: Delete the file given in PATH, and also deletes files with the same name, but with extension given in EXT1, and potentially also EXT2, EXT3...","title":"xASL_adm_DeleteFilePair.m"},{"location":"Functions/#xasl_adm_dicom2parmsm","text":"Format: [parms pathDcmDictOut] = xASL_adm_Dicom2Parms(inp[, parmsfile, dcmExtFilter, bUseDCMTK, pathDcmDictIn]) Description: The function goes through the INP files, reads the DICOM or PAR/REC files and parses their headers. It extracts the DICOM parameters important for ASL, makes sure they are in the correct format, if missing then replaces with default value, it also checks if the parameters are consistent across DICOM files for a single sequence.","title":"xASL_adm_Dicom2Parms.m"},{"location":"Functions/#xasl_adm_doccrawlerm","text":"Format: xASL_adm_DocCrawler(inputPath) Description: This function checks each individual file header and extracts the information. The results is saved as a markdown file. If you want to use star symbols (*testFile.m e.g.) we recommend not to use them in the same line with bold text (which is written like this: bold text ).","title":"xASL_adm_DocCrawler.m"},{"location":"Functions/#xasl_adm_docinitializem","text":"Format: xASL_adm_DocInitialize Description: This function generates all markdown files, which are necessary for the mkdocs documentation.","title":"xASL_adm_DocInitialize.m"},{"location":"Functions/#xasl_adm_findbyregexpm","text":"Format: xasl_adm_FindByRegExp(root, dirSpecs[, varargin]) Description: Recursively find files in the root directory according to the dirSpecs.","title":"xASL_adm_FindByRegExp.m"},{"location":"Functions/#xasl_adm_findstrindexm","text":"Format: INDEX = xASL_adm_FindStrIndex(ARRAY, STRING) Description: Similar to find, but then for a cell array filled with strings. Only takes 4 dimensions.","title":"xASL_adm_FindStrIndex.m"},{"location":"Functions/#xasl_adm_getdeprecatedfieldsm","text":"Format: nameConversionTable = xASL_adm_GetDeprecatedFields() Description: This script is mainly used to improve backwards compatibility. Check the usage in both xASL_adm_LoadX and xASL_io_ReadDataPar.","title":"xASL_adm_GetDeprecatedFields.m"},{"location":"Functions/#xasl_adm_getfslistm","text":"Format: RES = xASL_adm_GetFsList([strDirectory, strRegEx, bGetDirNames, bExcludeHidden, bIgnoreCase, nRequired]) Description: List files or directories from a given path. And optionally uses regular expressions to filter the result with options to exclude hidden files, ignore case, and set a minimal requirement on the number of results. Sorts the results at the end.","title":"xASL_adm_GetFsList.m"},{"location":"Functions/#xasl_adm_getnumfromstrm","text":"Format: num = xASL_adm_GetNumFromStr(str) Description: Obtains single number from string. CAVE there should only be one number!","title":"xASL_adm_GetNumFromStr.m"},{"location":"Functions/#xasl_adm_getphilipsscalingm","text":"Format: scaleFactor = xASL_adm_GetPhilipsScaling(pathParmsMat,pathNifti) Description: This script provides the correct scaling factors for a NIfTI file. It checks the header of the NIfTI that normally has the same scaling as RescaleSlope in DICOM, it checks if dcm2nii (by the info in JSON) has already converted the scale slopes to floating point. And if not, the derive the correct scaling factor to be applied.","title":"xASL_adm_GetPhilipsScaling.m"},{"location":"Functions/#xasl_adm_getpopulationsessionsm","text":"Format: [nSessions, bSessionsMissing] = xASL_adm_GetPopulationSessions(x) Description: This function looks for the maximum amount of sessions that are present in selected processed files present in the Population folder. Determine which files to look for in the Population folder Obtain list of session files in the Population folder Determine unique amount of session numbers present in list Set nSessions as highest unique session number Check and provide warning of number of sesssions differs per subject","title":"xASL_adm_GetPopulationSessions.m"},{"location":"Functions/#xasl_adm_getusernamem","text":"Format: UserName = xASL_adm_GetUserName() Description: Get the name of the current user.","title":"xASL_adm_GetUserName.m"},{"location":"Functions/#xasl_adm_hex2numm","text":"Format: outNum = xASL_adm_hex2num(inStr) Description: Takes a hexadecimal string and converts it to number or string. Works also when the string contains escape characters, and for single-floats and for a little and big endian. If containing 8 and less characters than treat as float, if more than as double.","title":"xASL_adm_Hex2Num.m"},{"location":"Functions/#xasl_adm_lesionreslicelistm","text":"Format: [INname, OUTname] = xASL_wrp_LesionResliceList(x,bLesion_T1,bLesion_FLAIR,bROI_T1,bROI_FLAIR) Description: Creates list of structural image paths to reslice.","title":"xASL_adm_LesionResliceList.m"},{"location":"Functions/#xasl_adm_loadparmsm","text":"Format: [Parms, x] = xASL_adm_LoadParms(ParmsPath[, x, bVerbose]) Description: This function loads the internal memory x struct, any legacy *_parms.mat sidecar, any *.json BIDS sidecar, to use scan-specific parameters for image processing/quantification. Also, per BIDS inheritance, any x.S.SetsID parameters (from participants.tsv) are loaded as well. This function performs the following steps: Load .mat parameter file Load JSON file Deal with warnings Find fields with scan-specific data in x.S.Sets, and use this if possible (per BIDS inheritance) Sync Parms.* with x.(Q.)* (overwrite x/x.Q) Fix M0 parameter if not set","title":"xASL_adm_LoadParms.m"},{"location":"Functions/#xasl_adm_loadxm","text":"Format: [x[, IsLoaded]] = xASL_adm_LoadX(x[, Path_xASL, bOverwrite]) Description: This function loads x.Output & x.Output_im struct fields from the x.mat on the hard drive & adds them to the current x struct located in memory. If it didnt exist in the x.mat, it will set IsLoaded to false, which can be catched externally & a warning issued if managed so in the calling function. If it didnt exist in the memory x struct, or bOverwrite was requested, the contents of x.mat will be loaded to the memory x struct Admin Load X-struct from disc Look for and update deprecated fields Add fields from disc to the current x-struct","title":"xASL_adm_LoadX.m"},{"location":"Functions/#xasl_adm_makestandalonem","text":"Format: xASL_adm_MakeStandalone(outputPath, bCompileSPM, importDCM, markAsLatest); Description: This function creates an output folder including a standalone version of ExploreASL, which can be used with the Matlab Runtime outside of Matlab itself. A quick fix to solve path dependencies etc. is to first compile SPM (but this can be turned off for speed). This function performs the following steps: Manage ExploreASL and compiler code folders Capture version/date/time File management output folder & starting diary Handle SPM Specific Options Manage compilation paths Run SPM compilation Run ExploreASL compilation Print done","title":"xASL_adm_MakeStandalone.m"},{"location":"Functions/#xasl_adm_mergestructsm","text":"Format: mergedStruct = xASL_adm_MergeStructs(mainStruct, secondaryStruct) Description: It merges two structures. It takes everything from the mainStruct and keep it as it is. It adds all fields from the secondaryStructure to the main structure while checking for duplicates. It is not overwriting anything, all duplicit content is taken from mainStruct. It works iteratively by correctly merging also the substructs.","title":"xASL_adm_MergeStructs.m"},{"location":"Functions/#xasl_adm_orderfieldsm","text":"Format: outStruct = xASL_adm_OrderFields(inStruct,orderStruct) Description: Order fields in the structure inStruct to match orderStruct , unmatching fields in inStruct are copied as they are at the end, unmatching fields in orderStruct are ignored. This is just a cosmetic change and no values are edited.","title":"xASL_adm_OrderFields.m"},{"location":"Functions/#xasl_adm_otherlistspmm","text":"Format: [OtherListSPM, OtherListOut] = xASL_adm_OtherListSPM(OtherList, bList4D) Description: bPadComma1 is to add the ,1 to the end of the pathstring, which SPM uses to assign the first image of a 4D image array (OPTIONAL, DEFAULT = true) bList4D: boolean, true for listing multiple 4D volumes separately in the list (OPTIONAL, DEFAULT=true).","title":"xASL_adm_OtherListSPM.m"},{"location":"Functions/#xasl_adm_parreadheaderm","text":"Format: info =xASL_adm_ParReadHeader(filename) Description: Function for reading the header of a Philips Par / Rec MR V4.* file.","title":"xASL_adm_ParReadHeader.m"},{"location":"Functions/#xasl_adm_removedirectoriesm","text":"Format: xASL_adm_RemoveDirectories(root) Description: Script to remove all ExploreASL related paths.","title":"xASL_adm_RemoveDirectories.m"},{"location":"Functions/#xasl_adm_removelogfilesforrerunm","text":"Format: xASL_adm_RemoveLogFilesForRerun(rootDir); Description: Removes all log files from any directory containing .log files.","title":"xASL_adm_RemoveLogFilesForRerun.m"},{"location":"Functions/#xasl_adm_remove_1_spmm","text":"Format: [OtherList] = xASL_adm_Remove_1_SPM(OtherList) Description: Remove ,1 at end of OtherLists, if exists. These are appended in CoregInit, OldNormalizeWrapper etc, since this should allow 4rd dim (e.g. as in ASL4D).","title":"xASL_adm_Remove_1_SPM.m"},{"location":"Functions/#xasl_adm_replacesymbolsm","text":"Format: strOut = xASL_adm_ReplaceSymbols(strIn, symbolTable[, bracketLeft, bracketRight]) Description: It takes the STRIN on input, then looks for symbols between BRACKETLEFT and BRACKETRIGHT and replaces these symbols in in the string by the values provided in the SYMBOLTABLE as SYMBOLTABLE.SYMBOL, SYMBOLTABLE.D.SYMBOL, or SYMBOLTABLE.P.SYMBOL","title":"xASL_adm_ReplaceSymbols.m"},{"location":"Functions/#xasl_adm_resetvisualizationslicesm","text":"Format: [x] = xASL_adm_ResetVisualizationSlices(x) Description: Removes any predefined slices that should be visualized, allowing to show the default slices. Comes in handy when different pipeline visualization parts are repeated.","title":"xASL_adm_ResetVisualizationSlices.m"},{"location":"Functions/#xasl_adm_savexm","text":"Format: xASL_adm_SaveX(x[, Path_xASL, bOverwrite]) Description: This function saves the x.mat either to the predefined path or the the subject x.mat","title":"xASL_adm_SaveX.m"},{"location":"Functions/#xasl_adm_unziporcopym","text":"Format: unpackedFiles = xASL_adm_UnzipOrCopy(srcDir, wildCard, destDir [, bOverwrite]) Description: This is a simple wrapper function to (g)unzip one or more files to the specified destination directory. Existing files or directories will not be overwritten, unless forced with bOverwrite. A regular file-copy will be used if the source files don't have gz or zip filename extensions.","title":"xASL_adm_UnzipOrCopy.m"},{"location":"Functions/#xasl_adm_voxel2realworldcoordinatesm","text":"Format: [X Y Z] = xASL_adm_Voxel2RealWorldCoordinates(X,Y,Z,VoxelSize) Description: Converts MNI coordinates from voxel coordinates/indices. Assumes X Y Z = LR LeftRight AP AnteriorPosterior IS InferiorSuperior. VoxelSize should be [1 3]-sized input.","title":"xASL_adm_Voxel2RealWorldCoordinates.m"},{"location":"Functions/#xasl_adm_zipfilelistm","text":"Format: filepaths = xASL_adm_ZipFileList(strDirectory, strRegExp[, bRecurse, bUseGzip, nRequired]) xASL_adm_ZipFileList(strDirectory, strRegExp[, bRecurse, bUseGzip, nRequired]) Description: Zip the files that match regular expression STRREGEXP in the given directory STRDIRECTORY. Zips recursively if specified in BRECURSE. Zips all files unless the number is specified by NREQUIRED, if the number is not met, then does not zip anything and throws an error.","title":"xASL_adm_ZipFileList.m"},{"location":"Functions/#xasl_adm_uigetinputm","text":"Format: [Parms] = xASL_adm_uiGetInput(Parms) Description: Checks whether input fields are present, or requests them.","title":"xASL_adm_uiGetInput.m"},{"location":"Functions/#bids","text":"","title":"BIDS"},{"location":"Functions/#xasl_bids_add2participantstsvm","text":"Format: xASL_bids_Add2ParticipantsTSV(DataIn, DataName, x, bOverwrite) Description: This function adds metadata/statistical variables to the participants.tsv in the root/analysis folder, by the following steps. This function will iterate over Data provided at DataIn and fill them in the participants.tsv, overwriting if allowed. Empty data is filled in as 'n/a', and the first column \"participants_id\" is sorted for participants. This function runs the following steps: Admin - Validate that there are not too many columns Admin - Detect nSubjectsSessions Admin - Load pre-existing participants.tsv or create one Admin - Get column number of data Add data to CellArray Sort rows on subjects Fill empty cells Write data to participants.tsv","title":"xASL_bids_Add2ParticipantsTSV.m"},{"location":"Functions/#xasl_bids_bidsifyasljsonm","text":"Format: jsonOut = xASL_bids_BIDSifyASLJSON(jsonIn) Description: It makes all the conversions to a proper BIDS structure, checks the existence of all BIDS fields, removes superfluous fields, checks all the conditions and orderes the structure on the output. It works according to the normal BIDS, or ASL-BIDS definition Obtain the dimensions of the ASL data Take all the manually predefined fields from studyPar Extract the scaling factors from the JSON header Convert certain DICOM fields Prioritize DICOM fields over the manually provided studyPar fields Field check and name conversion Check for time encoded sequence Merge data from the Phoenix protocol Background suppression check SliceTiming check Check if length of vector fields match the number of volumes Reformat ASLcontext field Verify TotalAcquiredPairs against ASLContext Final field check","title":"xASL_bids_BIDSifyASLJSON.m"},{"location":"Functions/#xasl_bids_bidsifyaslniim","text":"Format: jsonOut = xASL_bids_BIDSifyASLNII(jsonIn, bidsPar, pathIn, pathOutPrefix) Description: It modifies the NIfTI file to take into account several BIDS specifics. Specifically, it applies the previously calculated scalings, and it saves the ASLcontext.tsv file,","title":"xASL_bids_BIDSifyASLNII.m"},{"location":"Functions/#xasl_bids_bidsifyanatjsonm","text":"Format: jsonOut = xASL_bids_BIDSifyAnatJSON(jsonIn) Description: It makes all the conversions to a proper BIDS structure, checks the existence of all BIDS fields, removes superfluous fields, checks all the conditions and orderes the structure on the output. It works according to the normal BIDS, or ASL-BIDS definition","title":"xASL_bids_BIDSifyAnatJSON.m"},{"location":"Functions/#xasl_bids_bidsifychecktimeencodedm","text":"Format: [jsonOut,bTimeEncoded,bTimeEncodedFME] = xASL_bids_BIDSifyCheckTimeEncoded(jsonIn,jsonOut) Description: Check for time encoded sequence.","title":"xASL_bids_BIDSifyCheckTimeEncoded.m"},{"location":"Functions/#xasl_bids_bidsifym0m","text":"Format: [jsonOutM0, jsonOutASL] = xASL_bids_BIDSifyM0(jsonIn, jsonASL, studyPar, pathM0In, pathM0Out, headerASL) Description: % It makes all the conversions to a proper BIDS structure, checks the existence of all BIDS fields, removes superfluous fields, checks all the conditions and orderes the structure on the output. It works according to the normal BIDS, or ASL-BIDS definitionIt modifies the NIfTI file to take into account several BIDS specifics. Specifically, it applies the previously calculated scalings. Check the scaling in DICOMs Check the JSON parameters Save or move the NII to the correct location","title":"xASL_bids_BIDSifyM0.m"},{"location":"Functions/#xasl_bids_checkdatasetdescriptionm","text":"Format: [bImportedExploreASL, bImportedSameVersion, versionExploreASLBIDS, bImportedBETA] = xASL_bids_CheckDatasetDescription(datasetDescription, versionExploreASL) Description: Check the dataset_description.json field contents with special regard to the import version.","title":"xASL_bids_CheckDatasetDescription.m"},{"location":"Functions/#xasl_bids_comparestructuresm","text":"Format: [identical,results] = xASL_bids_CompareStructures(pathDatasetA,pathDatasetB,[bPrintReport,threshRmseNii]); Description: Function that compares two BIDS folders with several subfolders and studies and prints the differences. We recommend to set bPrintReport to true, because you otherwise can't see significant file content differences.","title":"xASL_bids_CompareStructures.m"},{"location":"Functions/#xasl_bids_configm","text":"Format: bidsPar = xASL_bids_Config() Description: Creates several structures necessary for configuring the DICOM to BIDS conversion and saving of BIDS JSON files and NII structure.","title":"xASL_bids_Config.m"},{"location":"Functions/#xasl_bids_createdatasetdescriptiontemplatem","text":"Format: [json] = xASL_bids_CreateDatasetDescriptionTemplate(draft, versionExploreASL) Description: This script creates a JSON structure which can be saved using spm_jsonwrite to get a dataset_description.json template. Missing fields that are required are added. BIDSVersion checked against the current configured version. Remaining fields will be validated. Other fields not belonging to dataset_description.json are ignored.","title":"xASL_bids_CreateDatasetDescriptionTemplate.m"},{"location":"Functions/#xasl_bids_dro2bidsm","text":"Format: xASL_bids_DRO2BIDS(droTestPatient,[droSubject]) Description: Prepare DRO test patient for BIDS2RAW conversion. This script uses the output of the asldro python script and converts it into a bids structure that can be read by our xASL_bids_BIDS2Legacy script. An exemplary usage is shown in the unit test called xASL_ut_UnitTest_function_BIDS2Legacy.","title":"xASL_bids_DRO2BIDS.m"},{"location":"Functions/#xasl_bids_dicom2jsonm","text":"Format: [parms pathDcmDictOut] = xASL_bids_Dicom2Parms(imPar, pathIn[, pathJSON, dcmExtFilter, bUseDCMTK, pathDcmDictIn]) Description: The function goes through the pathIn files, reads the DICOM or PAR/REC files and parses their headers. It extracts the DICOM parameters important for ASL, makes sure they are in the correct format, if missing then replaces with default value, it also checks if the parameters are consistent across DICOM files for a single sequence. Admin Set up the default values Recreate the parameter file from raw data","title":"xASL_bids_Dicom2JSON.m"},{"location":"Functions/#xasl_bids_getphoenixprotocolm","text":"Format: [xasl,parameters,parameterList,phoenixProtocol] = xASL_bids_GetPhoenixProtocol(pathData,bUseDCMTK) Description: Function that reads raw DICOM data (\".dcm\" or \".IMA\") and extracts the phoenix protocol parameters. Only works for Siemens DICOM data with phoenix protocol (tag = [0x29,0x1020]).","title":"xASL_bids_GetPhoenixProtocol.m"},{"location":"Functions/#xasl_bids_jsoncheckm","text":"Format: jsonOut = xASL_bids_JsonCheck(jsonIn,fileType) Description: It checks the existence of all BIDS fields, removes superfluous fields, checks all the conditions and orderes the structure on the output. It works according to the normal BIDS, or ASL-BIDS definition","title":"xASL_bids_JsonCheck.m"},{"location":"Functions/#xasl_bids_mergeniftim","text":"Format: NiftiPaths = xASL_bids_MergeNifti(NiftiPaths, seqType[, niiTable]) Description: This function takes a list of M0 or ASL4D files and concatenates them together in a longer 4D volume if possible following certain patterns: works only with 3D and 4D files; all files in the list must have the same size of the first three dimensions; files are generarily sorted according to the last number in the filename and outputted to M0.nii or ASL4D.nii; first JSON is taken and renamed, all other JSONs and NIIs are deleted after merging; M0*_parms.m or ASL*_parms.mat is renamed to M0_parms.m or ASL4D_parms.m; M0 files are checked if the field PhaseEncodingAxis is consistent through all the volumes, if not the nothing is merged; this is applied to a generic case and 3 other specific Siemens scenarios are implemented: i) All NII files have two volumes, then simply concatenate according to the last number. ii) Two files with a single volume each are merged according to the last number in the file name. iii) Multiple files with each containing a single volume are sorted to tags ASL4D_x_x_Y and controls ASL4D_Y and merged in the order of the last number in the filename (Y) alternating the tags and controls This function performs the following steps in subfunctions: xASL_bids_MergeNifti_M0Files Generic merging of M0 files xASL_bids_MergeNifti_GEASLFiles Merge GE ASL files and extract scan order from DICOM tags xASL_bids_MergeNifti_SeriesNumber Merge ASL files by SeriesNumber if different xASL_bids_MergeNifti_SiemensASLFiles Merge Siemens ASL files with specific filename pattern xASL_bids_MergeNifti_AllASLFiles Merge any ASL files xASL_bids_MergeNifti_Merge Merge NiftiPaths & save to pathMerged xASL_bids_MergeNifti_Delete Delete NiftiPaths and associated JSONs xASL_bids_MergeNifti_RenameParms Find *_parms.m files in directory and shorten to provided name","title":"xASL_bids_MergeNifti.m"},{"location":"Functions/#xasl_bids_mergenifti_deletem","text":"Format: xASL_bids_MergeNifti_Delete(NiftiPaths); Description: Delete NiftiPaths and associated JSONs.","title":"xASL_bids_MergeNifti_Delete.m"},{"location":"Functions/#xasl_bids_mergenifti_mergem","text":"Format: pathOut = xASL_bids_MergeNifti_Merge(NiftiPaths,indexSortedFile,nameMerged,bAlternatingControlLabel) Description: Merge NiftiPaths & save to pathOut.","title":"xASL_bids_MergeNifti_Merge.m"},{"location":"Functions/#xasl_bids_mergenifti_renameparmsm","text":"Format: xASL_bids_MergeNifti_RenameParms(Fpath,Fname); Description: Find *_parms.m files in directory and shorten to provided name.","title":"xASL_bids_MergeNifti_RenameParms.m"},{"location":"Functions/#xasl_bids_mergenifti_seriesnumberm","text":"Format: pathOut = xASL_bids_MergeNifti_SeriesNumber(NiftiPaths, niiTable) Description: Take a list of NIfTI files and concatenates 3D/4D files into a 4D sequence if possible according to SeriesNumber for niiTable","title":"xASL_bids_MergeNifti_SeriesNumber.m"},{"location":"Functions/#xasl_bids_mergenifti_siemensaslfilesm","text":"Format: pathOut = xASL_bids_MergeNifti_SiemensASLFiles(NiftiPaths) Description: Take a list of NIfTI files and concatenates 3D/4D files into a 4D sequence if possible (Siemens).","title":"xASL_bids_MergeNifti_SiemensASLFiles.m"},{"location":"Functions/#xasl_bids_mergestudyparm","text":"Format: jsonIn = xASL_bids_MergeStudyPar(jsonIn,studyPar,bidsModality); Description: Check if required fields exist in studyPar but not in jsonIn or if we can find them in other ways. The BIDSification of JSON metadata requires at least some basic fields. If dcm2niix can't extract fields like Manufacturer from the DICOM data (strict anonymization), we need to be able to read them from the studyPar JSON (manually inserted). Alternatively we can check other DICOM tags for information. This function can potentially be enhanced in future release to fix other fields besides the Manufacturer as well. To enable this functionality for different modalities, we introduced the bidsModality parameter. This function is called by: xASL\\_bids\\_BIDSifyM0 xASL\\_bids\\_BIDSifyASLJSON xASL\\_bids\\_BIDSifyAnatJSON","title":"xASL_bids_MergeStudyPar.m"},{"location":"Functions/#xasl_bids_par2jsonm","text":"Format: parms = xASL_bids_Par2JSON(pathPar, pathJSON) Description: Opens the Philips PAR file. Reads the relevant DICOM headers and saves them to JSON sidecar in a BIDS format. The JSON file is created automatically by the dcm2nii readout, so it always looks for this JSON file and add the same time reads the PAR file and adds further parameters to the JSON that were not identified by the dcm2nii tool.","title":"xASL_bids_Par2JSON.m"},{"location":"Functions/#xasl_bids_phoenixprotocolanalyzerm","text":"Format: [bidsPar,sourcePar] = xASL_bids_PhoenixProtocolAnalyzer(parameterList); Description: This function analyzes the parameter list of the phoenix protocol (tag = [0x29,0x1020]). This function is usually called from xASL_bids_GetPhoenixProtocol.","title":"xASL_bids_PhoenixProtocolAnalyzer.m"},{"location":"Functions/#xasl_bids_phoenixprotocolreaderm","text":"Format: [parameterList,phoenixProtocol] = xASL_bids_PhoenixProtocolReader(rawPhoenixProtocol) Description: Function to parse the raw phoenix protocol. This function is usually called from xASL_bids_GetPhoenixProtocol.","title":"xASL_bids_PhoenixProtocolReader.m"},{"location":"Functions/#xasl_bids_vendorfieldcheckm","text":"Format: jsonOut = xASL_bids_VendorFieldCheck(jsonIn,bIsASL) Description: It checks all the JSON fields, make sure that they are renamed from vendor specific names to common BIDS names","title":"xASL_bids_VendorFieldCheck.m"},{"location":"Functions/#xasl_bids_determineimagetypegem","text":"Format: imageType = xASL_bids_determineImageTypeGE(jsonPar) Description: Determine the image type of a GE DICOM.","title":"xASL_bids_determineImageTypeGE.m"},{"location":"Functions/#xasl_bids_parms2bidsm","text":"Format: outBids = xASL_bids_parms2BIDS(inXasl[, inBids, bOutBids, priorityBids]) Description: This functions takes two parameter structures and merges them. At the same time, renames all fields according to the output type (note that only some fields have two standardised names different between the two formats. In case of duplicities, takes the field value from the preferred format. Also takes into account that the units in BIDS are s, but in xASL ms. This function performs the following steps: Define field names that need to be convert/renamed/merged Convert XASL fields to the output format (BIDS or XASL) Convert BIDS fields to the output format (BIDS or XASL) Merge the BIDS and XASL fields, convert field values","title":"xASL_bids_parms2BIDS.m"},{"location":"Functions/#xasl_bids_parsem0m","text":"Format: xASL_bids_parseM0(pathASLNifti) Description: Check the .JSON and aslContext.tsv sidecards of an ASL file in BIDS format and find the specified M0 possibilities. Then it converts the ASL file to ExploreASL legacy format including splitting of ASL and M0 NIFTIes if needed. Note that the sidecars are in BIDS, but the file-structure is already expected to be in Legacy format","title":"xASL_bids_parseM0.m"},{"location":"Functions/#fsl","text":"","title":"FSL"},{"location":"Functions/#xasl_fsl_runfslm","text":"Format: [x] = xASL_adm_RunFSL(FSLCommand, x[, OutputZipping]) Description: This function runs an FSL command from ExploreASL: Checking the FSL dir Manage CUDA/CPU parallelization (currently disabled, WIP) Setting up FSL environment Running the command Supports .nii & .nii.gz, Linux, MacOS & Windows (WSL)","title":"xASL_fsl_RunFSL.m"},{"location":"Functions/#xasl_fsl_setfsldirm","text":"Format: [FSLdir[, x, RootWSLdir]] = xASL_adm_SetFSLdir(x, bUseLatestVersion) Description: This function finds the FSLdir & puts it out, also in x.FSLdir to allow repeating this function without having to repeat searching. If the FSLdir & RootFSLdir are already defined in x.FSLdir & x.RootFSLdir, this function is skipped. Supports Linux, MacOS & Windows (WSL), & several different default installation folders for different Linux distributions","title":"xASL_fsl_SetFSLdir.m"},{"location":"Functions/#xasl_fsl_topupm","text":"Format: xASL_fsl_TopUp(InDir[, ScanType], x) Description: This function runs FSL TopUp. It assumes that there are 2 TopUp images, i.e. 1 blip up & 1 blip down. Admin: manage ScanType, NIfTI paths, create TopUp parameter file for image to apply TopUp to & for the TopUp NIfTIs, delete files from previous run, define the image with the same acquisition parameters as TopUp (does the image we apply TopUp to, have the Blip up or down?) Register images to image that we apply TopUp to (registration between blip up/down images is performed by TopUp) Run TopUp estimate (i.e. estimate the geometric distortion field from B0 NIfTI & parameters file), this takes quite long. Also has a x.settings.Quality=0 option that is very fast but inaccurate, to try out this pipeline part. Before TopUp, NaNs (e.g. from resampling) are removed from the images TopUp is run with default settings Apply TopUp","title":"xASL_fsl_TopUp.m"},{"location":"Functions/#imaging","text":"","title":"Imaging"},{"location":"Functions/#xasl_im_bilateralfilterm","text":"Format: [ovol] = xASL_im_BilateralFilter(volIM, mask, VoxelSize, x) Description: This function runs a spatial lowpass temporally highpass filter, and removes outliers within this signal, and adapts the time-series accordingly.","title":"xASL_im_BilateralFilter.m"},{"location":"Functions/#xasl_im_centerofmassm","text":"Format: xASL_im_CenterOfMass(PathNIfTI, OtherList, AllowedDistance) Description: This function estimates the center of mass of the image matrix, and if this is too far off the current orientation matrix center, the center will be reset. This fixes any incorrect orientation outputted by the scanner. The realignment is only applied when any of the X/Y/Z dimensions have a higher offset than AllowedDistance.","title":"xASL_im_CenterOfMass.m"},{"location":"Functions/#xasl_im_cleanupwmhnoisem","text":"Format: xASL_im_CleanupWMHnoise(InputPath, OutputPath, MinLesionVolume, pThresh) Description: Threshold white matter lesions, acknowledging the fact that they may be confluent with subresolution connection through a dilation. This part is executed conservatively, as FLAIR hyperintensities inside the GM can be erroneously segmented as WMH, and should not be lesion-filled (otherwise these cannot be fixed later in the Structural module). Note that LST lesion filling expects a probability map, doesnt work nicely with binary mask","title":"xASL_im_CleanupWMHnoise.m"},{"location":"Functions/#xasl_im_clipextremesm","text":"Format: [NewIM] = xASL_im_ClipExtremes(InputIm[, ThreshHigh, ThreshLow, bVerbose, bNormalize]) Description: This function clips an image to a given percentile. The percentile is found using non-zeros sorted intensities, so both isfinite & non-zeros. This function performs the following steps: Constrain clippable intensities Clip high intensities Clip low intensities Normalize to 4096 (12 bit, 12^2) Save as NIfTI if the input was a NIfTI","title":"xASL_im_ClipExtremes.m"},{"location":"Functions/#xasl_im_column2imm","text":"Format: [ImageOut] = xASL_im_Column2IM(ColumnIn, BrainMask) Description: This function \"decompresses\" an image matrix (or multiple matrices) from a single-dimensional column, by reconstructing the image matrix from the voxel positions within the BrainMask. NB: Important to use the same BrainMask as used for converting the image matrix to the column! See also: xASL_im_IM2Column.m The mask mostly used for xASL_im_IM2Column is x.S.masks.WBmask, which completely engulfes pGM, pWM & pCSF.","title":"xASL_im_Column2IM.m"},{"location":"Functions/#xasl_im_compareniftiresolutionxyzm","text":"Format: [IsEqualResolution] = xASL_im_CompareNIfTIResolutionXYZ(PathNIfTI1, PathNIfTI2) Description: This function checks whether the X, Y and Z resolution of a NIfTI with any number of dimensions is equal. It rounds for 2 floating points, for both NIfTIs, to ensure that the same precision is compared.","title":"xASL_im_CompareNIfTIResolutionXYZ.m"},{"location":"Functions/#xasl_im_compareniftism","text":"Format: [identical,RMSE] = xASL_im_CompareNiftis(pathA,pathB) Description: Compare two niftis. Untouched comparison based on copies.","title":"xASL_im_CompareNiftis.m"},{"location":"Functions/#xasl_im_computedicem","text":"Format: [DiceCoeff] = xASL_im_ComputeDice(imA, imB) Description: This function calculates the Dice coefficient of image overlap.","title":"xASL_im_ComputeDice.m"},{"location":"Functions/#xasl_im_createasldeformationfieldm","text":"Format: xASL_im_CreateASLDeformationField(x, bOverwrite, EstimatedResolution) Description: This function smooths a transformation flow field to a lower resolution. Usually, we use a high resolution anatomical image (e.g. 3D T1w ) to obtain the flowfields from native space to standard space, and apply these to the lower resolution ASL images. Because of the resolution differences, the flowfields need to be downsampled/smoothed, to avoid deformation effects that are crispier than the functional image that is investigated. This function performs the following steps: Obtain resolutions Fill NaNs at edges y_T1.nii flowfield to prevent interpolation artifact Smooth flowfield Fill NaNs at edges y_ASL.nii Note that if the resolution of ASL is not significantly (i.e. >0.5 mm in any dimension) lower than T1w, the y_T1.nii is copied to y_ASL.nii","title":"xASL_im_CreateASLDeformationField.m"},{"location":"Functions/#xasl_im_createpseudocbfm","text":"Format: xASL_im_CreatePseudoCBF(x, spatialCoV[, bPVC]) Description: This function creates a pseudo-CBF image from mean CBF template, arterial transit time (ATT) bias field & vascular artifacts, weighted through spatial CoV The first part of this code puts templates in the native space and creates a pseudoCBF image from a downsampled pGM & pWM tissue (PseudoTissue). The latter is used for registration but also as reference for the template registration, to speed this up. The second part of this code computes a pseudoCBF image based on the pseudoTissue & the CBF templates of CBF, ATT biasfield and vascular peaks, based on spatial CoV. This submodule performs the following steps: Create the pseudoTissue CBF reference image, if it doesnt exist already Create the native space copies of ASL templates, if they dont exist already Spatial CoV input argument check Load native space copies of templates Create pseudoTissue from segmentations, mix this with the mean CBF template depending on spatial CoV Create pseudoCBF reference image used for CBF-based registration Scale mean_PWI_Clipped source image to the same range as PseudoCBF","title":"xASL_im_CreatePseudoCBF.m"},{"location":"Functions/#xasl_im_createslicegradientm","text":"Format: xASL_im_CreateSliceGradient(x) Description: Create slice gradient in same space as input file Reslice slice gradient to MNI (using existing ASL matrix changes from e.g. registration to MNI, motion correction, registration to GM) Creating average slice gradient","title":"xASL_im_CreateSliceGradient.m"},{"location":"Functions/#xasl_im_decomposeaffinetransformationm","text":"Format: [M, P] = xASL_im_DecomposeAffineTransformation(Mtransformation) Description: This function splits a transformation matrix into individual components, which can be useful to guide the SPM reslicing. The components are the same as in spm_(i)matrix.m, except for the shearing: these are included in the rotations, and the 90 degree rotations, these are separated. Reason for the separation of the 90 degree rotations, is that these indicate if orientations (transversal, coronal & sagittal) have been switched in the NIfTI. This can be useful to correct for any erroneous 90degree rotations from registration, or to put two images in the same orientation order or voxelsize without applying their subtle realignment (e.g. for manipulating registration references) THEORY 90 degree rotations: Any rotation will always swap the other dims (X rotation swaps Y/Z, Y rotation swaps X/Z etc.) because they are perpendicular (haaks) Dims X Y Z care for LR, AP and IS translation. - X-rotation will rotate the transverse slice (LR <-> AP) swapping Y (coronal) & Z (saggital) - Y-rotation will rotate the coronal slice (IS <-> LR) slice, swapping X (transversal) and Z (sagittal) - Z-rotation will rotate the sagittal slice (AP <-> IS) swapping X (transversal) and Y (sagittal) E.g., MPRAGE is acquired in sagittal slices, and ASL/fMRI/BOLD in transversal slices. This is an Y rotation (you look into the coronal plane, rotate this, which will swap the sagittal slices into transversal) This function performs the following steps: Start with an output P and M struct Obtain translations Obtain zoom Obtain 90degree rotations Obtain subtle rotations & shearing Check the rounding errors of the decomposition","title":"xASL_im_DecomposeAffineTransformation.m"},{"location":"Functions/#xasl_im_determineflipm","text":"Format: [LR_flip_YesNo] = xASL_im_DetermineFlip(PathOrientationResults) Description: This functions check determinants before and after image processing (nii.mat0 vs nii.mat, respectively) to find any potential left-right processing. This function performs the following steps: 1. Determine correct row, differs between Matlab versions 2. If units are printed as second row, the data starts on the third row 3. Determine column indices 4. Find left-right flips","title":"xASL_im_DetermineFlip.m"},{"location":"Functions/#xasl_im_dilateerodefullm","text":"Format: imOut = xASL_im_DilateErodeFull(imIn, type, kernel) Description: Runs dilation or erosion on a binary imIn in full three dimensions. It uses its own dilate_erode function and crops the image so that it contains only the mask. The size of all three dimensions of the kernel needs to be an odd number.","title":"xASL_im_DilateErodeFull.m"},{"location":"Functions/#xasl_im_dilateerodeseparablem","text":"Format: imOut = xASL_im_DilateErodeSeparable(imIn, type, kernel_x, kernel_y, kernel_z) Description: Runs dilation or erosion on a binary imIn separably in three dimensions. Dilation/erosion in each dimension is done by using the specified kernels. It uses its own dilate_erode function and crops the image so that it contains only the mask. Works only with odd sized kernels","title":"xASL_im_DilateErodeSeparable.m"},{"location":"Functions/#xasl_im_dilateerodespherem","text":"Format: el = xASL_im_DilateErodeSphere(R) Description: Creates a 3D structuring element (binary) sphere with the given diameter (R) and size 2*R+1","title":"xASL_im_DilateErodeSphere.m"},{"location":"Functions/#xasl_im_dummyorientationniftim","text":"Format: xASL_im_DummyOrientationNIfTI(PathSrc, PathRef, PathDummyOut[, bApplyRotationMinor, bApplyRotation90, bApplyZoom, bApplyTranslation]) Description: This function creates a dummy image as reference for xASL_spm_reslice, allowing to only apply specific parts of the transformation between the two images. E.g. only the rotation, or only the zooming. This can be useful to correct for any erroneous rotations from registration, or to put two images in the same space without applying their realignment. This function performs the following steps: Load orientations & calculate transformation Calculate the desired transformation Calculate new orientation matrix Calculate the new image size Save the dummy NIfTI","title":"xASL_im_DummyOrientationNIfTI.m"},{"location":"Functions/#xasl_im_estimateresolutionm","text":"Format: [resFWHM, resSigma, resErr, imSmo, imMask] = xASL_im_EstimateResolution(imCBF, imGM, imWM[, imMaskOrig, PSFtype, maxIter]) Description: Creates a high-resolution pseudo-CBF image based on segmented GM and WM maps and iteratively adjusts its resolution by smoothing until reaching a perfect fit with the CBF image thus obtaining the resolution difference between the GM and CBF image and uses this to calculate the estimated effective resolution of hte CBF. Note that all the calculations are done using voxels as measures and not mm, so the output resolution is also in voxels and has to be transfered to mm by using the knowledge about the voxel size. It is assumed that for imGM and imWM, the voxel size equals the resolution, and the imCBF is upsampled to the smaller voxels of imGM.","title":"xASL_im_EstimateResolution.m"},{"location":"Functions/#xasl_im_flipm","text":"Format: [MatrixOut] = xASL_im_Flip(MatrixIn, varargin) Description: Backwards compatibility for flipping left-right in standard space (NB: this can be different than in native space!).","title":"xASL_im_Flip.m"},{"location":"Functions/#xasl_im_flipniftim","text":"Format: xASL_im_FlipNifti(pathInput[, flipAxis, bOverwrite]) Description: This function allows correcting an inappropriate flip in the image matrix. It will not change the orientation matrix in the header but the image itself. So any NifTI program will not be aware of this flip! This function runs the following steps: 1. Manage if we overwrite the new NIfTI 2. Manage if we zip the new NIfTI 3. Load image from NIfTI 4. Flip image 5. Save image to NIfTI","title":"xASL_im_FlipNifti.m"},{"location":"Functions/#xasl_im_hausdorffdistm","text":"Format: xASL_im_HausdorffDist(imIn1,imIn2) Description: Calculate Hausdorff and modified Hausdorff distance between two ROIs in volumes imIn1, imIn2. Input images are binarized as 0 and non-0","title":"xASL_im_HausdorffDist.m"},{"location":"Functions/#xasl_im_im2columnm","text":"Format: [ColumnOut] = xASL_im_IM2Column(ImageIn, BrainMask[, ApplyShiftDim]) Description: This function \"compresses\" an image matrix (or multiple matrices) for optimization of memory and CPU resources. The output column only includes voxels that lie within the BrainMask. This excludes extracranial zero-information voxels from computations and memory use. NB: Important to use the same BrainMask for converting the column back to an image matrix! See also: xASL\\_im\\_Column2IM.m The mask mostly used for xASL_im_IM2Column is x.S.masks.WBmask , which completely engulfes pGM, pWM & pCSF","title":"xASL_im_IM2Column.m"},{"location":"Functions/#xasl_im_jointhistm","text":"Format: imHist = xASL_im_JointHist(imA,imB[,imMask,minA,maxA,minB,maxB,nBins]) Description: It calculates a joint histogram of two images of any dimensions over a mask of the same size. The boundaries and number of bins can either be given or min and max values are used. Values outside of the bins are counted to the first/last bin.","title":"xASL_im_JointHist.m"},{"location":"Functions/#xasl_im_lesion2catm","text":"Format: LesionPathOut = xASL_im_Lesion2CAT (PathIn) Description: For all lesion masks in the anatomical directory, load them, merge them and save them for the CAT segmentation. If there are no lesions found, the images are untouched.","title":"xASL_im_Lesion2CAT.m"},{"location":"Functions/#xasl_im_lesion2maskm","text":"Format: LesionIM = xASL_im_Lesion2Mask(LesionPath, x) Description: This function takes a mask and adds several ROIs, to be used as custom \"atlas\", e.g. when computing region-average CBF values. The mask % can be an ROI or lesion, if we assume it is a lesion, the following masks are created: Intralesional Perilesional (15 mm rim around the lesion) Hemisphere (ipsilateral to lesion) Contralateral version of 1 4a First create separate masks 4b Check if they are mutually exclusive 4c Save NIfTI file Contralateral version of 2 Contralateral version of 3 All these masks are masked by a brainmask (pGM+pWM)>0.5 This function performs the following steps: If lesion is empty, skip this & delete the file BrainMasking Create hemispheres Save mutually exclusive masks Create tsv-sidecar containing the names of the ROIs Visual QC","title":"xASL_im_Lesion2Mask.m"},{"location":"Functions/#xasl_im_m0erodesmoothextrapolatem","text":"Format: [ImOut] = xASL_im_M0ErodeSmoothExtrapolate(ImIn, x) Description: This function erodes, smooths & extrapolates M0 in standard space. It assumes that the M0 image is in standard space & that the GM & WM probability maps are aligned. Here, we mask the M0, to remove high CSF signal and low extracranial signal, enabling us to smooth the image without inserting wrong signal. See also the ExploreASL manuscript for a more extensive explanation. This function performs the following steps: Mask: Load segmentations, create structural mask Mask: Create intensity-based mask to remove extracranial signal Mask: Erode the combined masks Mask: Determine any odd borders Smoothing Extrapolating only Scale back to the GM M0 Print visual QC figure A visual QC figure is created, showing the M0 image processing steps for a single transversal slice (slice 53 in 1.5 mm MNI standard space) OutputFile = fullfile(x.D.M0regASLdir,['M0\\_im\\_proc\\_' x.P.SubjectID '.jpg']); The original M0 image (a) is masked with a (pGM+pWM)>50% mask (b) eroded with a two-voxel sphere to limit the influence of the ventricular and extracranial signal (c) and thresholded to exclude significantly high (i.e. median + 3*mean absolute deviation (MAD)) border region values (d) This masked M0 image is smoothed with a 16x16x16 mm full- width-half-maximum Gaussian filter (Mutsaerts et al., 2018) (e) after which the signal at the border is smoothly extrapolated until the full image is filled (f). Whereas the masking avoids mixing with cerebrospinal fluid or extracranial signal, the extrapolation avoids M0 division artifacts","title":"xASL_im_M0ErodeSmoothExtrapolate.m"},{"location":"Functions/#xasl_im_masknegativevascularsignalm","text":"Format: [NegativeMask, TreatedPWI] = xASL_quant_DetectNegativeVascularSignal(x) Description: This function segments clusters with significant negative ASL signal. This can be tricky as there is also the negative tail of Gaussian noise from the ASL subtraction. The image feature we use here, is that negative vascular signal will be a relatively large region with significant median negative value, whereas noise will be regions with relatively small negative signal. Negative signal from wrong background suppression timing (e.g. in the first slice with **2D EPI**) can be masked out with this as well. The procedure works as follows: Obtain mask of negative voxels within pGM>0.5 mask Obtain distribution of subzero clusters Define the negative threshold Create mask by thresholding whole image Note that the definition of the threshold is obtained within the GM only, but that this threshold is applied to the full image. Note that instead of the PWI path input, a CBF image should work equally well, as we don't expect a smooth M0 biasfield to change the distribution of negative clusters","title":"xASL_im_MaskNegativeVascularSignal.m"},{"location":"Functions/#xasl_im_maskpeakvascularsignalm","text":"Format: [MaskIM, CBF] = xASL_quant_VascularContrast(PathPWI, Path_M0, CompressionRate, ClipThresholdValue, bClip) Description: This function searches for an acceptable high threshold as definition of high intra-vascular ASL signal. It also allows to compress the values here (when bClip==true). Compression retains some variability, but limits their outlying influence on statistics. The procedure works as follows: Segment GM on ASL image at 80th percentile of CBF image distribution For PWI & CBF images, select voxels higher than median + ClipThresholdValue MAD Vascular artifacts will have a high intensity in both images, whereas errors by division by M0 will only have a high intensity on the M0 image, and high values due to a biasfield will only be noticeable on the PWI image Combine the two created masks Obtain average clipping value from selected voxels from the combined masks Apply compression if requested. If not, output image will have NaNs for intra-vascular voxels. Note that the definition of the threshold is obtained within the GM only, but that this threshold is applied to the full image to also remove extracranial extreme values. Note that the performance may change when using this script with or without M0, as this will change the distribution that determines where the threshold for extremes lies.","title":"xASL_im_MaskPeakVascularSignal.m"},{"location":"Functions/#xasl_im_modulationm","text":"Format: xASL_im_Modulation(x) Description: Combines the transformations to create Jacobians, & multiplies the standard space segmentations with these to create volumetric images for volumetric analyses.","title":"xASL_im_Modulation.m"},{"location":"Functions/#xasl_im_normalizelabelingterritoriesm","text":"Format: image_out = xASL_im_NormalizeLabelingTerritories( imageIN, GMmask, x) Description: Normalizes per perfusion territory mask should be GM mask.","title":"xASL_im_NormalizeLabelingTerritories.m"},{"location":"Functions/#xasl_im_pcam","text":"Format: [pc, score, eigenvalues, tsquare, loadings, Xmean] = xASL_im_PCA(dataIn) Description: Perform a Principal Component Analysis.","title":"xASL_im_PCA.m"},{"location":"Functions/#xasl_im_pvcbsplinem","text":"Format: [imPVEC,imCBFrec,imResidual,FWHM] = xASL_im_PVCbspline(imCBF,imPV[,bsplineNum]) Description: PVC of ASL data using prior GM-,WM-partial volume maps. Follows the principles of the PVEc algorithm by I. Asllani (MRM, 2008). The PV-corrected CBF_GM and CBF_WM maps are approximated using an uniformly sampled cubic B-splines. REFERENCES: -Asllani I, Borogovac A, Brown TR. Regression algorithm correcting for partial volume effects in arterial spin labeling MRI. Magnetic Resonance in Medicine. 2008 Dec 1;60(6):1362-71. -Petr J, Mutsaerts HJ, De Vita E, Steketee RM, Smits M, Nederveen AJ, Hofheinz F, van den Hoff J, Asllani I. Effects of systematic partial volume errors on the estimation of gray matter cerebral blood flow with arterial spin labeling MRI. MAGMA 2018. DOI:10.1007/s10334-018-0691-y","title":"xASL_im_PVCbspline.m"},{"location":"Functions/#xasl_im_pvckernelm","text":"Format: [imPVC,imCBFrec,imResidual] = xASL_im_PVCkernel(imCBF, imPV [,kernel,mode]) Description: Partial volume correction (PVC) of ASL data using prior GM-,WM-partial volume maps. Follows the principles of the PVC algorithm by I. Asllani (MRM, 2008).","title":"xASL_im_PVCkernel.m"},{"location":"Functions/#xasl_im_presmoothm","text":"Format: pathOut = xASL_im_PreSmooth(pathRef,pathSrc[,pathSmo,resRef,resSrc,srcAffinePath, bInvAffine]) Description: It assumes that the FWHM is equal to voxel size, unless the real resolution is given. Then takes into account the voxel sizes and orientation difference between the volumes, but performs the smoothing according to the given real resolution (it is possible to supply the resolution for just one image) - this should be helpful primarily when the It creates a Gaussian covariance matrix for the reference, transforms it according to the difference between the two images a produces the Gaussian covariance matrix of the pre-smoothing in the source space. Then it performs the smoothing. The following steps are performed: Obtain the voxel size Skip this function if reference resolution is equal to, or lower than source resolution Deal with affine transformation Obtain the transformation matrix from the Reference to the Source space Apply the smoothing filter on the source image(s) Save the smoothed image","title":"xASL_im_PreSmooth.m"},{"location":"Functions/#xasl_im_processm0conventionalm","text":"Format: [Corr_M0] = xASL_im_ProcessM0Conventional(ImIn, x) Description: This function uses the conventional M0 masking, and only a little smoothing, following what Philips uses for its 3D {{GRASE}}. Advantages of the newer M0 processing in ExploreASL are the lack of use of M0 threshold-based masking, the removal of high CSF values and higher SNR for ASL division.","title":"xASL_im_ProcessM0Conventional.m"},{"location":"Functions/#xasl_im_projectlabelsoverdatam","text":"Format: OutputIM = xASL_im_ProjectLabelsOverData(DataIM,LabelIM,x,ScaleFactorData,ScaleFactorLabel) Description: This script projects labels over an image, but works only in 2D. Make sure to make a 2D image from a 3D or 4D image using xASL_vis_TransformData2View.m can be used in combination with xASL_vis_Imwrite.m","title":"xASL_im_ProjectLabelsOverData.m"},{"location":"Functions/#xasl_im_replacelabelm","text":"Format: xASL_im_ReplaceLabel(pathNifti, LabelNumbersOld, LabelNumbersNew, pathNewNifti) Description: This function replaces label values/numbers inside a NIfTI image, by the following steps: Load NIfTI Replace numbers Save NIfTI","title":"xASL_im_ReplaceLabel.m"},{"location":"Functions/#xasl_im_resamplelinearfairm","text":"Format: [output_res]=xASL_im_ResampleLinearFair(im_input,newsize) Description: Downsample (or upsample, works similarly) old_res image to low_res image, trilinear. We recommend using \"xASL_spm_Resample\" instead, because of better performance. NB: new_res should fit exactly integer fold in old_res NB: all dimensions of new_res should have equal size","title":"xASL_im_ResampleLinearFair.m"},{"location":"Functions/#xasl_im_restoreorientationm","text":"Format: xASL_im_RestoreOrientation(PathNIfTI) Description: This function reverts the NIfTI header orientation matrix to the original orientation from the scanner/dcm2nii conversion.","title":"xASL_im_RestoreOrientation.m"},{"location":"Functions/#xasl_im_skullstripm","text":"Format: xASL_im_SkullStrip(InPath, PathMNIMask, x, OutPath) Description: Creates skull-stripped T1w image based on MNI -> native space registration from segmentation.","title":"xASL_im_SkullStrip.m"},{"location":"Functions/#xasl_im_smooth3dm","text":"Format: [imSmo, imGaussX, imGaussY, imGaussZ] = xASL_im_Smooth3D(imIn, sigma[, PSFtype]) Description: It smooths the 3D image with a 3D kernels that has defined the shape and SD of the smoothing separably in three dimension.","title":"xASL_im_Smooth3D.m"},{"location":"Functions/#xasl_im_splitimagelabelsm","text":"Format: xASL_im_SplitImageLabels(ImagePaths, LabelTable[, OutputFolder, bOverwrite, ResampleDir, SubRegExp]) Description: This function allows extracting of labels from a NIfTI file containing multiple labels, into single NIfTI files each containing a single label. Not all existing labels need to be extracted. The following steps are performed: Load TSV file Process images","title":"xASL_im_SplitImageLabels.m"},{"location":"Functions/#xasl_im_upsamplem","text":"Format: xASL_im_Upsample(PathOrig, PathDest, NewVoxelSize, LeaveEmpty, PaddingDim, Kernel) Description: Upsamples an ASL image, without changing the orientation matrix, which can be used e.g. for PVEc in higher resolution but same space.","title":"xASL_im_Upsample.m"},{"location":"Functions/#xasl_im_zeroedgesm","text":"Format: [IM] = xASL_im_ZeroEdges(IM[, EdgeThicknessPerc]) Description: Resampling can sometimes give some strange errors near image edges. These should be NaNs, but sometimes can be zeros or ones, or even weird numbers. For resampling, NaNs should be set to 0 (this is done in another function) as they can influence the resampling (depending on the transformation matrix). To be sure that the edges are nicely fixed, this function sets a border at the image matrix edges to zero.","title":"xASL_im_ZeroEdges.m"},{"location":"Functions/#xasl_im_dilateroim","text":"Format: xASL_im_dilateROI(PathIn, [PathOut, minVolume]) Description: The function loads a binary image from PathIn and if smaller than the defined volume (40 mL by default) it dilates it with a 3x3 sphere element until a minimal volume is reached. When it is small enough, it is saved to PathOut. 40 mm^3 is equal to 3 voxels in all directions in DARTEL space, or around the highest obtainable ASL effective resolution (3x3x4 mm).","title":"xASL_im_dilateROI.m"},{"location":"Functions/#xasl_im_rotatem","text":"Format: rotated = xASL_im_rotate(im, angle) Description: Simple rotation of the first two dimension of a ND image by 0, 90, 180, 270 degrees.","title":"xASL_im_rotate.m"},{"location":"Functions/#initialization","text":"","title":"Initialization"},{"location":"Functions/#xasl_init_dataloadingm","text":"Format: [x] = xASL_init_DataLoading(x) Description: Load dataset by adding relevant fields to xASL x struct.","title":"xASL_init_DataLoading.m"},{"location":"Functions/#xasl_init_defaulteffectiveresolutionm","text":"Format: [EffectiveResolution] = xASL_init_DefaultEffectiveResolution(PathASL, x) Description: This ExploreASL module provides an educated guess on the effective spatial resolution of ASL. This may depend on the combination of acquisition PSF, reconstruction filter, head motion. Note that the derived/processed images may have a lower effective resolution because of smoothing effects from interpolation. Note that this remains an educated-guess, the actual FWHM may still differ, especially for 3D GRASE sequences, where e.g. the choice of number of segments can affect the smoothness. This function conducts the following steps: Educated-guess FWHM Attempt accounting for in-plane interpolation in reconstruction Calculate and report effective spatial resolution","title":"xASL_init_DefaultEffectiveResolution.m"},{"location":"Functions/#xasl_init_definedatadependentsettingsm","text":"Format: [x] = xASL_init_DefineDataDependentSettings(x) Description: Define ExploreASL environment parameters, dependent of loaded data.","title":"xASL_init_DefineDataDependentSettings.m"},{"location":"Functions/#xasl_init_defineindependentsettingsm","text":"Format: [x] = xASL_init_DefineIndependentSettings(x) Description: Define ExploreASL environment parameters, independent of loaded data.","title":"xASL_init_DefineIndependentSettings.m"},{"location":"Functions/#xasl_init_definepathsm","text":"Format: [x] = xASL_init_DefinePaths(x) Description: Define paths used by ExploreASL.","title":"xASL_init_DefinePaths.m"},{"location":"Functions/#xasl_init_definestudydatam","text":"Format: [x] = xASL_init_DefineStudyData(x) Description: This initialization wrapper initializes the parameters for this pipeline run, i.e. subjects, sessions (runs), timepoints (visits), exclusions, sites, cohorts etc. Note that ASL sessions are defined here as what BIDS calls \"runs\". The \"longitudinal_Registration functions here manage different TimePoints, which is what BIDS calls \"visits\". With different structural scans, from the same participant. This is managed by subject name suffixes _1 _2 _n, and can be used for comparing visits in the population module, or running SPM's longitudinal within-subject registration. Parallelization is allowed here by calling ExploreASL different times, where it divides the subjects/images for processing across the nWorkers, using iWorker as the reference for the part that the current ExploreASL call will process. This requires having a Matlab license that can be started multiple times on a server, or alternatively running the ExploreASL compilation, and doesn't require the Matlab parallel toolbox. This function exists from the following parts: Manage included & excluded subjects Create dummy defaults (exclusion list, ASL sessions) Create list of total baseline & follow-up subjects, before exclusions Create TimePoint data-lists Manage exclusions Add sessions as statistical variable, if they exist Parallelization: If running parallel, select cases for this worker Add Longitudinal TimePoints (different T1 volumes) as covariate/set, after excluding Load & add statistical variables Make x.S.SetsOptions horizontal if vertical by transposing Create single site dummy, if there were no sites specified Check for time points sets Create list of baseline & follow-up subjects (i.e. after exclusion) Check what excluded from which TimePoints","title":"xASL_init_DefineStudyData.m"},{"location":"Functions/#xasl_init_determinerequiredpathsm","text":"Format: [x] = xASL_init_DetermineRequiredPaths(x) Description: Check the BIDS dataset root for the metadata JSON files.","title":"xASL_init_DetermineRequiredPaths.m"},{"location":"Functions/#xasl_init_filesystemm","text":"Format: [x] = xASL_init_FileSystem(x) Description: This function initializes the file system used throughout ExploreASL, for processing a single dataset/scan. It is repeated for each scan, and runs the following parts: Create folders Subject/session definitions Add prefixes & suffixes Add Subject-specific prefixes Add sidecars Add atlas paths","title":"xASL_init_FileSystem.m"},{"location":"Functions/#xasl_init_initializemutexm","text":"Format: [x] = xASL_init_InitializeMutex(x, ModuleName) Description: This function initializes the mutex/lock system of ExploreASL for a module. Mutex (for mutual exclusion) is a synchronization mechanism for enforcing limits of access to data (here a module for a single scan) to allow parallelization. It also allows stopping and continuing of ExploreASL. This function runs the following steps: Lock folder management Initialize mutex object","title":"xASL_init_InitializeMutex.m"},{"location":"Functions/#xasl_init_loaddataparameterfilem","text":"Format: [x] = xASL_init_LoadDataParameterFile(x, DataParPath, SelectParFile) Description: Load data parameter file.","title":"xASL_init_LoadDataParameterFile.m"},{"location":"Functions/#xasl_init_loadmetadatam","text":"Format: [x] = xASL_init_LoadMetadata(x) Description: This function loads all metadata used in the study, either statistical covariates (age, MMSE) or groups to compare between (site, sequence, cohort), or parameters to be used in quantification/image processing These parameters should be provided in .mat files in the root analysis folder. Each .mat file should contain a single type of metadata, and the filename should equal the variable name. Metadata content should be a cell array with subjects as first column and metadata as last column. Sessions (runs) can be included as second column. Metadata can be in any string or numerical format. participants.tsv is now added per BIDS. It looks for metadata in participants.tsv first, before going through the mat-files This function iterates through the following steps for each variable: Admin (what nOptions do we call ordinal, convert subject numeric to string, remove white spaces from data) Get unique list of data options & check for missing data Deal with data format (correct NaNs, deal with numeric vs strings) Distinguish continous data (e.g. age) or ordinal data (groups to compare, e.g. cohort) Check if data is complete for all subjects Include complete data in x.S.SETS","title":"xASL_init_LoadMetadata.m"},{"location":"Functions/#xasl_init_longitudinalregistrationm","text":"Format: [SubjectNlist, TimePoint, IsSubject, SubjectID_FirstVolume] = xASL_init_LongitudinalRegistration(x) Description: This function initializes the longitudinal registration for ExploreASL, which implements the SPM longitudinal registration. This function recognizes and defines visits (i.e. multiple scans per subject) in the initialization of ExploreASL, based on the suffixes _1 _2 _n in the subject names (identified as foldernames). Specifically, this function is called in the registration modules LongReg and DARTEL, the first carrying out within-subject registration and the second between-subject registration, based on the first time point only. For the first function, we specify here a list of visits/timepoints that should be registered longitudinally, for the second function we specify a list of first visits only, as the between-subject registration in ExploreASL is based on the first scan (as opposed to the average subject's scan). This function runs the following steps: Get TimePoint-list (list of visits) Find subject IDs","title":"xASL_init_LongitudinalRegistration.m"},{"location":"Functions/#xasl_init_printchecksettingsm","text":"Format: x = xASL_init_PrintCheckSettings(x) Description: Check whether pre-defined settings existed in dataPar.json . Prints these on the screen as the start of the pipeline. Runs following steps: Set default settings if not defined Print data/study specific settings Print warnings","title":"xASL_init_PrintCheckSettings.m"},{"location":"Functions/#xasl_init_printuserfeedbackm","text":"Format: xASL_init_PrintUserFeedback(x) Description: Print user feedback.","title":"xASL_init_PrintUserFeedback.m"},{"location":"Functions/#xasl_init_removelockdirsm","text":"Format: [x] = xASL_init_RemoveLockDirs(x) Description: Remove 'lock-dir' if present from aborted previous run, for current subjects only.","title":"xASL_init_RemoveLockDirs.m"},{"location":"Functions/#xasl_init_substructsm","text":"Format: [x] = xASL_init_SubStructs(x) Description: Initialize the ExploreASL x structure substructs/fields. Only fields which do not exist so far are added. This script is supposed to help with the overall modularity of ExploreASL. This script is identical to the function ExploreASL_Initialize_SubStructs within ExploreASL_Initialize. We can not call this script from ExploreASL_Initialize, since the paths are not initialized at that part of the script yet.","title":"xASL_init_SubStructs.m"},{"location":"Functions/#xasl_init_toolboxesm","text":"Format: x = xASL_init_Toolboxes(x) Description: Check & load ancillary toolboxes, versions and paths.","title":"xASL_init_Toolboxes.m"},{"location":"Functions/#xasl_init_visualizationsettingsm","text":"Format: [x] = xASL_init_VisualizationSettings(x) Description: This function defines several visualization settings are used throughout ExploreASL's pipeline and tools, assuming a [121 145 121] matrix with 1.5 mm isotropic resolution in MNI space.","title":"xASL_init_VisualizationSettings.m"},{"location":"Functions/#xasl_init_checkdatasetrootm","text":"Format: [x] = xASL_init_checkDatasetRoot(x) Description: Check the ExploreASL parameter \"DatasetRoot\".","title":"xASL_init_checkDatasetRoot.m"},{"location":"Functions/#xasl_init_checkdatasetroot_invalid_starting_2_0m","text":"Format: [x] = xASL_init_checkDatasetRoot_invalid_starting_2_0(x) Description: Script for backwards compatibility. This functionality allows loading JSON files instead of the BIDS dataset root.","title":"xASL_init_checkDatasetRoot_invalid_starting_2_0.m"},{"location":"Functions/#xasl_init_printsettingsm","text":"Format: xASL_init_printSettings(x) Description: Print chosen settings.","title":"xASL_init_printSettings.m"},{"location":"Functions/#input-and-output","text":"","title":"Input and Output"},{"location":"Functions/#xasl_io_checkdeprecatedfieldsxm","text":"Format: x = xASL_io_CheckDeprecatedFieldsX(x) Description: Check deprecated fields of x and fix them based on a conversion table. This table is used within: xASL_bids_parms2BIDS xASL_io_ReadDataPar xASL_adm_LoadParms xASL_adm_LoadX It is not only used to convert deprecated x structure fields to fields within up-to-date substructures of x, but also to rename fields and to move them back and forwards for the comparison with BIDS parameters within xASL_bids_parms2BIDS e.g., which is why it is important to make sure that if a row within the table is used to move & rename, that there is also another row where the new fieldname is moved to the same substructure.","title":"xASL_io_CheckDeprecatedFieldsX.m"},{"location":"Functions/#xasl_io_createniftim","text":"Format: xASL_io_CreateNifti(pathNewNifti, imNew, resMat, nBits, bGZip) Description: This function creates a new NIfTI file, using the SPM \"nifti\" functionality, with the parameters specified as input arguments. This function performs the following steps: Initialize NIfTI Choose datatype (bit resolution) Create scale slopes Create orientation matrix Write the new NIfTI, image matrix & scale slopes Zip and deal with zipping (.nii vs. .nii.gz)","title":"xASL_io_CreateNifti.m"},{"location":"Functions/#xasl_io_dcmtkreadm","text":"Format: header = xASL_io_DcmtkRead(filepath, bPixel) Description: SHORT Reads DICOM headers using DCMTK FORMAT: header = xASL_io_DcmtkRead(filepath, bPixel) INPUT: filepath (string) - full path to the DICOM file bPixel (bool) - read pixel data, default 0 OUTPUT: header (structure) - structure containing parsed DICOM header Calls the MEX function that uses DCMTK library to read the DICOM header. To change which parameters are read and their names - the MEX file needs to be edited. This function also corrects formating of certain parameters.","title":"xASL_io_DcmtkRead.m"},{"location":"Functions/#xasl_io_exportvtkm","text":"Format: xASL_io_ExportVTK(nifti, [mask, exportPath]) Description: Export a VTK image file based on a 3D NIFTI or a 3D/4D image matrix. 4D images will be exported as a VTK time series (export-1.vtk, export-2.vtk, etc.). This script uses vtkwrite (MIT License, Copyright 2016, Joe Yeh).","title":"xASL_io_ExportVTK.m"},{"location":"Functions/#xasl_io_makenifti4dicomm","text":"Format: xASL_io_MakeNifti4DICOM(PathIn, x) Description: This function converts a NIfTI file to one that is ready to convert to DICOM for PACS visualization purposes: For scaling/visualization: Remove peak signal Remove valley signal Remove NaNs Rescale to 12 bit integers Save NIfTI. We also zip the NIfTI as this NIfTI won't be opened by ExploreASL Manage scale slope/datatype Apply original orientation Zip NIfTI","title":"xASL_io_MakeNifti4DICOM.m"},{"location":"Functions/#xasl_io_pairwisesubtractionm","text":"Format: xASL_io_PairwiseSubtraction(InputFile,outputPath,do_mask,switch_sign) Description: Subtracts controls from labels and takes mean. Creates new perfusion-weighted delta_M file, prefaced with 's'. Converts into single precision floating point values (32 bit), removes scale slope. Only runs if ['s' input_file_ASL] doesn't exist. Remember to consider motion correction/ SPM realign (isotropically). Alternative to this function is robust fit (Camille Maumet).","title":"xASL_io_PairwiseSubtraction.m"},{"location":"Functions/#xasl_io_readdataparm","text":"Format: [x] = xASL_io_ReadDataPar(pathDataPar[,bStudyPar]) Description: This function reads the data-parameter file, which is a file containing settings specific to processing a certain dataset or study (abbreviated as DataPar) and creates the x-structure out of it. The file can be in .json or .m format. The input file name pathDataPar is given as a string or character array. The output is the x structure. It only loads the data, removes the x-prefixes, but keeps all the field names and units. It doesn't do any conversions to or from BIDS. The only added value to normal json-read is that it detects invalid entries (numbers in strings, and weird arrays), converts them correctly and reports this incorrect entries so that they can be manually fixed. Also, if an .m file is provided, it converts and saves it to a JSON file (doesn't overwrite) and reports that you should stop using .m files.","title":"xASL_io_ReadDataPar.m"},{"location":"Functions/#xasl_io_readthedicomm","text":"Format: [Info] = xASL_io_ReadTheDicom(bUseDCMTK, DicomPath) Description: This function tries to read a DICOM and throws a warning if it fails to","title":"xASL_io_ReadTheDicom.m"},{"location":"Functions/#xasl_io_splitaslm","text":"Format: xASL_io_SplitASL(inPath[, iM0, iDummy]) Description: This function splits ASL4D & M0 & Dummy images if they were in the same sequence. If dcm2niiX has already splitted the ASL4D NIfTI, this is reconstructed first. If no M0 exists, or only ASL splitting is desired, leave iM0 empty ([]). The dummy scans can be excluded from the ASL sequence during the splitting. Both iM0 and iDummy are the absolute positions of both in the original time series Vendor product sequence examples: GE 3D spiral sometimes puts the M0 at the last volume of the series -> iM0 = [2]; Philips 3D GRASE puts the M0 as control-label volume pair -> iM0 = [1 2]; Siemens 3D GRASE puts the M0 as the first volume -> iM0 = 1; Some Siemens 3D GRASE puts a second Dummy control image -> iDummy = 2; Input parameter admin Prepare paths First concatenate NIfTIs Save M0 NIfTI Determine ASL indices Save ASL4D NIfTI Split relevant JSON parameters/arrays Split ASL4D_aslContext.tsv Modify JSON fields Copy sidecars","title":"xASL_io_SplitASL.m"},{"location":"Functions/#xasl_io_dcm2niim","text":"Format: [niifiles, ScanNameOut, usedinput, msg] = xASL_io_dcm2nii(inpath, destdir, series_name, varargin) Description: Convert DICOM NIfTI/BIDS format using the dcm2nii command line utility. Initial settings Parse parameters Locate dcm2nii executable Set default arguments dcm2nii Set dcm2niiX initialization loading Check if we are reading a DICOM folder Check for existing targets Create temporary subfolder for converting Run dcm2nii and move files to final destination using specified series name Cleanup temp Optionally return the used input file","title":"xASL_io_dcm2nii.m"},{"location":"Functions/#xasl_num2strm","text":"Format: [DataOut] = xASL_num2str(DataIn[, f, bConcatenate, strDelimiter]) Description: When the provided data is numeric, this function will convert the number to string/characters, rewriting NaN into 'n/a' (BIDS convention) but otherwise preserving the Matlab builtin functionality, also for the second argument \"f\". If non-numeric data is provided, it is bypassed (avoiding any issues \"num2str\" will have with non-numeric data). It can concatenate an array/matrix of strings, taking first the columns in the first row, and then going across the rows. See builtin num2str for more details","title":"xASL_num2str.m"},{"location":"Functions/#qc","text":"","title":"QC"},{"location":"Functions/#xasl_qc_addlogginginfom","text":"Format: [x] = xASL_qc_AddLoggingInfo(x, loggingEntry) Description: Logging of errors and warnings within the x structure.","title":"xASL_qc_AddLoggingInfo.m"},{"location":"Functions/#xasl_qc_asymmetryindexm","text":"Format: [AI_perc] = xASL_qc_AsymmetryIndex(ImageIn) Description: Extract voxel-wise asymmetry index for QC purposes.","title":"xASL_qc_AsymmetryIndex.m"},{"location":"Functions/#xasl_qc_cat12_iqrm","text":"Format: [QA_Output] = xASL_qc_CAT12_IQR(InputImage, InputC1, InputC2, InputC3, bFLAIR) Description: Prepare and run CAT12s QC parameters (also for other images).","title":"xASL_qc_CAT12_IQR.m"},{"location":"Functions/#xasl_qc_checkvalidityjsonm","text":"Format: [IsValid] = xASL_qc_CheckValidityJSON(PathJSON) Description: This function loads a QC JSON (simply JSON file, won't take any exotic files) and simply check whether there is any empty value after a key. If this is the case, it will throw a warning, which will skip reading this JSON by the compiled spm_jsonread, avoiding the crash that this may result in.","title":"xASL_qc_CheckValidityJSON.m"},{"location":"Functions/#xasl_qc_collectparametersm","text":"Format: x = xASL_qc_CollectParameters(x, iSubject, ScanType, CollectQCFunction) Description: This function collects QC parameters for a module.","title":"xASL_qc_CollectParameters.m"},{"location":"Functions/#xasl_qc_collectqc_aslm","text":"Format: [x] = xASL_qc_CollectQC_ASL(x, iSubject) Description: This functions collects QC parameters for the ASL module These are stored in x.Output.ASL: ID - SubjectName ASL_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 SPM realign (too much motion is suspicious) MotionMean_mm - mean motion MotionExcl_Perc - percentage of excluded outliers MotionMax_mm - max motion MotionSD_mm - SD motion ASL quantification (strange average CBF, or strange GM-WM contrast) ASL acquisition parameters (should be fairly consistent over subjects/scans): TE - echo time TR - repetition time RescaleSlope - Philips Scaleslope - Philips Matrix X Y Z - matrix size Matrix Z - number of slices VoxelSize X Y - in plane resolution VoxelSize Z - slice thickness RigidBody2Anat_mm - Net Displacement Vector (RMS) from ASL to T1w image (mm) from registration","title":"xASL_qc_CollectQC_ASL.m"},{"location":"Functions/#xasl_qc_collectqc_structuralm","text":"Format: [x] = xASL_qc_CollectQC_Structural(x, iSubject) Description: This functions collects QC parameters for the structural module These are stored in x.Output.Structural: ID - SubjectName T1w_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 LST output: WMH_vol_mL - WMH volume WMH_n - WMH number of lesions CAT12 output: T1w_IQR_Perc - CAT12 IQR quality parameter for T1w volumetric: GM_vol_mL, WM_vol_mL, CSF_vol_mL, ICV_vol_mL, GM_ICV_Ratio","title":"xASL_qc_CollectQC_Structural.m"},{"location":"Functions/#xasl_qc_collectqc_funcm","text":"Format: [x] = xASL_qc_CollectQC_func(x, iSubject) Description: This functions collects QC parameters for the func module These are stored in x.Output.func: ID - SubjectName func_LR_flip_YesNo - Checks whether any image processing changed the left-right orientation by checking whether the determinant differs between nii.mat & nii.mat0 SPM realign (too much motion is suspicious) MotionMean_mm - mean motion MotionExcl_Perc - percentage of excluded outliers MotionMax_mm - max motion MotionSD_mm - SD motion func quantification (strange average CBF, or strange GM-WM contrast) CBF_GM_Median_mL100gmin - median GM CBF CBF_WM_Median_mL100gmin - median WM CBF SpatialCoV_GM_Perc - GM spatial CoV SpatialCoV_WM_Perc - WM spatial CoV CBF_GM_WM_Ratio - GM-WM CBF ratio func acquisition parameters (should be fairly consistent over subjects/scans): TE - echo time TR - repetition time RescaleSlope - Philips Scaleslope - Philips Matrix X Y Z - matrix size Matrix Z - number of slices VoxelSize X Y - in plane resolution VoxelSize Z - slice thickness RigidBody2Anat_mm - Net Displacement Vector (RMS) from func to T1w image (mm) from registration","title":"xASL_qc_CollectQC_func.m"},{"location":"Functions/#xasl_qc_collectsoftwareversionsm","text":"Format: [x] = xASL_qc_CollectSoftwareVersions(x) Description: This functions collects software versions for Matlab, SPM, CAT, LST & ExploreASL If FSL is installed, it will obtain its version as well. These are stored in x.Output.Software.","title":"xASL_qc_CollectSoftwareVersions.m"},{"location":"Functions/#xasl_qc_comparetemplatem","text":"Format: [QC] = xASL_qc_CompareTemplate(x, ModPrefix, iSubjectSession) Description: This function computes several advanced template-based QC parameters: RMSE_Perc - Root Mean Square Error between image and template (%) nRMSE_Perc - Same but then normalized AI_Perc - Asymmetry Index between image and template (%) Mean_SSIM_Perc - mean structural similarity index -> xASL_stat_MeanSSIM.m PeakSNR_Ratio - peak signal-to-noise ratio -> xASL_stat_PSNR.m","title":"xASL_qc_CompareTemplate.m"},{"location":"Functions/#xasl_qc_computefovcoveragem","text":"Format: [CoveragePerc] = xASL_qc_ComputeFoVCoverage(InputPath, x) Description: This function computes the intersection/overlap between brainmask on field-of-view (FoV) of low resolution image (native space) & the same brainmask with expanded FoV. It uses the pGM+pWM+pCSF as brainmask This assumes that the structural reference image has full brain coverage, and was properly segmented into GM, WM and CSF Also, we assume that the InputPath contains a single 3D volume","title":"xASL_qc_ComputeFoVCoverage.m"},{"location":"Functions/#xasl_qc_computeniftiorientationm","text":"Format: [structOut] = xASL_qc_ComputeNiftiOrientation(PathNIfTI[, structIn]) Description: It loads the input Nifti, finds its dimension, voxel size and a net vector distance from its original position before registration. Adds all these information into an output structure structOut while copying all from structIn and keeping it intact.","title":"xASL_qc_ComputeNiftiOrientation.m"},{"location":"Functions/#xasl_qc_createpdfm","text":"Format: xASL_qc_CreatePDF(x[, DoSubject]) Description: This function iterates over all values in x.Output and all images in x.Output_im, and prints them in a PDF file. x.Output & x.Output_im should contain the QC/result output of all ExploreASL pipeline steps. Further code explanation: Below, using the Matlab & SPM Figure tools we create an image, which is then printed to a PDF file fg = the main Figure handle ax = \"axes\" handles, these are objects containing either 1) text or 2) images, with fg as \"parent\" (1) & (2) images have ax as \"parent\" Positions are calculated in such a way that 4 categories can be printed, which will be the first 4 fields found in x.Output then allowing 8 single slice images, and 15 text lines (name & value columns)","title":"xASL_qc_CreatePDF.m"},{"location":"Functions/#xasl_qc_fa_outliersm","text":"Format: [FA_Outliers_mL] = xASL_qc_FA_Outliers(InputFA) Description: Extract the number of FA outliers, i.e. values of FA above 1 or below 0, from a FA image.","title":"xASL_qc_FA_Outliers.m"},{"location":"Functions/#xasl_qc_obtainqccategoriesfromjpgm","text":"Format: xASL_qc_ObtainQCCategoriesFromJPG(x) Description: This function obtains QC categories as covariant/set, based on the JPGs in //Population/ASLCheck. These are initially sorted by spatial CoV, and should be visually checked & put in the correct folder.","title":"xASL_qc_ObtainQCCategoriesFromJPG.m"},{"location":"Functions/#xasl_qc_pcpstructuralm","text":"Format: [anatQA] = xASL_qc_PCPStructural(PathT1, Pathc1T1, Pathc2T1, x, PopPathT1) Description: This function computes several anatomical QC parameters as proposed in SPM Univariate Plus: WM_ref_vol_mL - volume of the WM reference region (mL) WMref_vol_Perc - same but as percentage of total WM volume SNR_GM - GM signal-to-Noise Ratio (SNR), ie the mean intensity within GM divided by SD of WM reference region. Higher = better. CNR_GM_WM - GM-WM Contrast-to-Noise Ratio (CNR), i.e. the mean of GM - mean of WM divided by the SD of the WM reference region. Higher = better. FBER_WMref_Ratio - Foreground to Background Energy Ratio (FBER), i.e. the variance of voxels within the brain (in pGM+pWM mask) divided by the variance of voxels in the WM reference region. Higher = better. EFC_bits - Shannon Entropy Focus Criterion (EFC), i.e. the entropy of voxel intensities proportional to the maximum possibly entropy for a similarly sized image. Indicates ghosting and head motion-induced blurring. Lower = better. Mean_AI_Perc - mean relative voxel-wise absolute Asymmetry Index (AI) within the brain (pGM+pWM mask) (%) SD - same but SD (%) REFERENCES: Preprocessed Connectome Project Quality Assurance Protocol (QAP): http://preprocessed-connectomes-project.org/quality-assessment-protocol/ http://ieeexplore.ieee.org/document/650886/","title":"xASL_qc_PCPStructural.m"},{"location":"Functions/#xasl_qc_printorientationm","text":"Format: xASL_qc_PrintOrientation(niftiList, outputDir, outputFile); Description: This function lists NifTI orientation matrices before and after image processing, respectively nii.mat0 and nii.mat. In ExploreASL this is used for QC to detect accidental left-right flips, as these can occur unnoticed as the brain structure appears relatively symmetrical. This can be detected by negative determinants. Also, this can be used to detect any significant differences in acquisition or image processing. So orientation parameters and determinants should be similar across all scans from single scanner/coil, and registration should not give a relatively negative determinant. Results are saved in a TSV file This functions performs the following steps: 1. Print the header 2. Load the data 3. Print original orientation matrix 4. Print current orientation matrix 5. Print registration transformation matrix 6. Print FileName 7. Get statistics (mean & SD)","title":"xASL_qc_PrintOrientation.m"},{"location":"Functions/#xasl_qc_reportleftrightflipsm","text":"Format: xASL_qc_ReportLeftRightFlips(dirRoot [, bZip]) Description: This function identifies and reports illegal left-right flips for image matrices within a NIfTI. This can be useful as these are not readily observed by the human eye, as the left and right hemispheres are too symmetrical by default. All NifTIs are found recursively (i.e. in the folder and its subfolders), irregardless of them being .nii or .nii.gz.","title":"xASL_qc_ReportLeftRightFlips.m"},{"location":"Functions/#xasl_qc_tanimotocoeffm","text":"Format: TC = xASL_qc_TanimotoCoeff(Image1, Image2[, imMask, type]) Description: Compares images Image1 and Image2 within the mask imMask. TYPE specifies the input data type. RATIONALE: Note that the Tanimoto Coefficient is a measure of image overlap/intersection, similar to the Dice coefficient. With the option type 3, this is a fuzzy coefficient, which doesn't require to convert the two images to a binary mask. The TC can be interpreted as a stringent Kappa, ranging from 0 (completely dissimilar) to 100% (identical images). Assuming that perfect registration should not lead to identical images but still retain physiological differences, TC>70% can be regarded as excellent image agreement. The TC will be overestimated when smoothing, but this may lead to more stable artifact detection.","title":"xASL_qc_TanimotoCoeff.m"},{"location":"Functions/#xasl_qc_wadqcdcm","text":"Format: xASL_qc_WADQCDC(x, iSubject[, ScanType]) Description: This QC function runs WAD-QC specific Python script to zip QC information & incorporate this into a DICOM field for analysis on the WAD-QC server, by the following: Define QCDC script: this is the Python script written by Gaspare, edited by Joost Kuijer & copied to the EPAD CustomScripts folder of ExploreASL Python installation location is checked, with several known locations, for several servers. If we cannot find it, the QCDC is not ran Previous QCDC results are cleaned. QCDC stores all its results in a separate folder (Something like 2 layers up from the current folder, here referred to as QCDCDir = [x.D.ROOT 'qcdc_output']) from these result files, only the filled DICOM file is interesting, all the rest are copies of the QC results that we embedded into the DICOM Run QCDC (if Python installation detected) The following files need to be set as executable: ('QCDC', 'src', 'qc_data_collector.py') ('QCDC', 'src', 'bash', 'create_dcm_only_wadqc.sh') ('QCDC', 'src', 'bash', 'sendwadqc.sh') Clean up new QCDC results (as above) & move the filled DICOM to ['qcdc_' DummyFile] within the current ScanType folder Sending the DICOM to the WAD-QC server using storescu","title":"xASL_qc_WADQCDC.m"},{"location":"Functions/#xasl_qc_wadqc_generatedescriptorm","text":"Format: xASL_qc_WADQC_GenerateDescriptor(x, iSubject) Description: This QC function generates a JSON descriptor for Gaspare' QCDC script, by the following steps: a) include information about where to find the dummy DICOM (i.e. placeholder DICOM) b) For ExploreASL' QC fields (as passed through in x.Output), here we note all these QC fields for each ScanType, as the x.Output should have been collected equally in the QC file 'QC_collection_SubjectName.json' by function xASL_qc_CollectParameters c) Subfunction xASL_qc_WADQC_images - Includes visual standard space QC images, by searching them on prescribed paths within the Population folder (where currently all derivatives reside) d) Insert the PDF report; this PDF report is subject-specific, not scan-specific. For completeness it is added to each QCDC descriptor e) Add WAD-QC server details (i.e. IP address etc) f) Save the Descriptor JSON file.","title":"xASL_qc_WADQC_GenerateDescriptor.m"},{"location":"Functions/#xasl_qc_temporalsnrm","text":"Format: tSNR = xASL_qc_temporalSNR(pathIm4D,pathImTissueProb) Description: This function computes several temporal SNR QC parameters as proposed in SPM Univariate Plus: tSNR.tSNR_GM_Ratio : mean GM signal / std GM over time tSNR.tSNR.tSNR_WM_Ratio : mean WM signal / std WM over time tSNR.tSNR.tSNR_CSF_Ratio: mean CSF signal / std CSF over time tSNR.tSNR_WMref_Ratio : mean signal/std over time in eroded deep WM tSNR.tSNR_GMWM_Ratio : mean (GM+WM) signal / sqrt(std(GM+WM)^2+std(WMref)^2) tSNR.tSNR_GMWM_WMref_Ratio: mean (GM+WM) signal / std WMref over time tSNR.tSNR_Physio2Thermal_Ratio: sqrt((tSNR(GM+WM)/tSNR_GMWM_WMref_Ratio))^2-1) tSNR.tSNR_Slope_Corr: Differences to the SPM U+ suggestion: eroded WM is used for estimating background noise Brainmask is determined in the same way as the structural anatQC, CSF is determined from the pGM&pWM maps; REFERENCES: 1. Thomas Liu (2016). Noise contributions to the fMRI signal: An overview NeuroImage, 343, 141-151 http://dx.doi.org/10.1016/j.neuroimage.2016.09.008 2. Cesar Caballero-Gaudes and Richard C. Reynolds (2016). Methods For Cleaning The BOLD fMRI Signal. NeuroImage, 154,128-149 3. Lawrence Wald and Jonathan R Polimeni (2016). Impacting the effect of fMRI noise through hardware and acquisition choices ??? Implications for controlling false positive rates. NeuroImage, 154,15-22 4. SPM Utility + toolbox. Cyril Pernet. https://osf.io/wn3h8/","title":"xASL_qc_temporalSNR.m"},{"location":"Functions/#quantization","text":"","title":"Quantization"},{"location":"Functions/#xasl_quant_agesex2hctm","text":"Format: [Hematocrit] = xASL_quant_AgeSex2Hct([age, sex]) Description: This function estimates a participants hematocrit, based on literature-based values for age and sex. It performs the following steps: Warning unknown age/sex Imputing unknown age/sex Define hematocrit per age for unknown sex Define Hematocrit per age for males Define Hematocrit per age for females","title":"xASL_quant_AgeSex2Hct.m"},{"location":"Functions/#xasl_quant_bsupcalculationm","text":"Format: signalPercentage = xASL_quant_BSupCalculation(BackgroundSuppressionPulseTime, ReadoutTime[, PresaturationTime, T1Time, SliceTime, PathGraph]) Description: This function computes the tissue signal percentage that remains after background suppression pulses are played in the ASL acquisition. It assumes that the signal is, at first, optionally saturated by a 90 degree flip at PresaturationTime before readout. Then follows a series of BSup pulses (times before readout are given) that do a 180 degree flip. The observed tissue relaxes with time T1time and the signal attenuation is calculated for several slices acquired at times relative to the readout.","title":"xASL_quant_BSupCalculation.m"},{"location":"Functions/#xasl_quant_basilm","text":"Format: [CBF_nocalib] = xASL_quant_Basil(PWI, x) Description: This script performs quantification of the PWI using the FSL Basil pipeline. Final calibration to physiological units is performed by dividing the quantified PWI by the M0 image/value. This function performs the following steps: 1. Define paths 2. Delete previous BASIL output 3. Write the PWI as Nifti file for Basil to read as input 4. Create option_file that contains options which are passed to Fabber 5. Run Basil and retrieve CBF output 6. Scaling to physiological units 7. Householding","title":"xASL_quant_Basil.m"},{"location":"Functions/#xasl_quant_feastm","text":"Format: xASL_quant_FEAST(x) Description: This function quantifies ATT using the FEAST equations, using crushed and non-crushed sessions, of which the ratio is proportional to ATT. Note that the order of sessions should be 1) crushed 2) non-crushed This function runs the following steps: Skip this function if no FEAST data available Admin Load data & correct for timing differences (PLD etc) Smooth and clip CBF maps & FEAST ratio Compute TT maps","title":"xASL_quant_FEAST.m"},{"location":"Functions/#xasl_quant_getcontrollabelorderm","text":"Format: [ControlIM, LabelIM, OrderContLabl] = xASL_quant_GetControlLabelOrder(FramesIn, x) Description: This function automatically checks (and corrects if required) the control and label order of ASL timeseries based on the larger signal in control volumes. It supposes that data is acquired in pairs.","title":"xASL_quant_GetControlLabelOrder.m"},{"location":"Functions/#xasl_quant_hct2bloodt1m","text":"Format: BloodT1 = xASL_quant_Hct2BloodT1(Hematocrit, Y, B0, bVerbose) Description: This function converts hematocrit to blood T1, according to calculations defined by Patrick Hales. With courtesy and thanks! Note that we assume a venous O2 saturation of 68% (Yv=0.68) This function performs the following steps: Check fraction vs percentage hematocrit & Y, should be between 0 and 1 Specify defaults (Hb, Fe) Perform calculation Convert s to ms Print what we did","title":"xASL_quant_Hct2BloodT1.m"},{"location":"Functions/#xasl_quant_m0m","text":"Format: [M0IM] = xASL_quant_M0(inputM0, x) Description: This function quantifies the M0, except for the difference in voxel size between the M0 and ASL source data (which is scaled in xASL_wrp_ProcessM0.m). This function runs the following steps: Correct scale slopes, if Philips Convert control image with background suppression to pseudo-M0 Skip M0 quantification if ~x.Q.ApplyQuantification(4) Set TR specifically for GE Check for correct TR values Quantify the M0, either for single 3D volume or slice-wise Apply custom scalefactor if requested (x.modules.asl.M0_GMScaleFactor)","title":"xASL_quant_M0.m"},{"location":"Functions/#xasl_quant_singlepldm","text":"Format: [ScaleImage[, CBF]] = xASL_quant_SinglePLD(PWI, M0_im, imSliceNumber, x) Description: This script performs a multi-step quantification, by initializing a ScaleImage that travels through this script & gets changed by the following quantification factors: PLD scalefactor (gradient if 2D multi-slice) (if x.Q.ApplyQuantification(3)) Label decay scale factor for single (blood T1) - or dual-compartment (blood+tissue T1) model, CASL or PASL Single-compartment model: Alsop MRM 2014 Dual-compartment model: Wang MRM 2002: Gevers JMRI 2012 (if x.Q.ApplyQuantification(3)) Scaling to physiological units [ml/gr/ms =>ml/100gr/min =>(60,000 ms=>min)(1 gr=>100gr)] (if x.Q.ApplyQuantification(3)) Manufacturer-specific scalefactor (if x.Q.ApplyQuantification(1) -> future move to dcm2niiX stage) Finally, we: Divide PWI/M0 (if x.Q.ApplyQuantification(5)) Print parameters used Note that the output always goes to the CBF image (in the future this could go to different stages, e.g. dcm2niiX or PWI stage) Note that BASIL is also implemented, but it doesn't allow a standard space quantification yet (it would need to use imSliceNumber)","title":"xASL_quant_SinglePLD.m"},{"location":"Functions/#xasl_quant_slicetimingm","text":"Format: SliceTiming = xASL_quant_SliceTiming(x, inputIm) Description: This function takes the x.Q.SliceReadoutTime and returns the SliceTiming parameter. The function creates a vector (of the relatives timings for each slices) out of it with the correct length corresponding to the number of slices in the inputIm corresponding to the BIDS definition. It also checks the x.Q.readoutDim, and for 3D readouts it returns 0. It loads the image from inputIm and calculates the SliceTiming according to the number of slices in the third dimension If a path is given, it also checks if it can find a JSON sidecar, then it loads the JSON sidecar, and looks for SliceTiming inside it. If SliceTiming/SliceReadoutTime is found in the JSON sidecar, it prioritize it over the value in the x-struct For reference, we use these terms: SliceTiming (the BIDS parameter) - it is a vector with the same length as the number of slices and contains the timing of the start of the readout of each slice relative to the first slice SliceReadoutTime - Legacy xASL parameter that will be phased out. It contains either a vector matching the BIDS definition of SliceTiming or a scalar with difference in readout times between the consecutives slices (i.e. the xASL legacy definition of SliceTiming) SliceTimingDiff - Internal parameter in this function for calculating the time difference between consecutive slices. Admin ShortestTR Assign the vector value and check for vector consistency","title":"xASL_quant_SliceTiming.m"},{"location":"Functions/#xasl_quant_slicetiming_shortesttrm","text":"Format: [x] = xASL_quant_SliceTiming_ShortestTR(x) Description: When the TR is set to \"shortestTR\" in the ASL acquisition, each ASL scan will have its unique TR. As this is shortest, there won't be a delay between the readout of the last slice and the end of the TR. Therefore, the time to read out all slices is TR - InitialPostLabelDelay - LabelingDuration, and dividing this by the number of slices gives the SliceReadoutTime","title":"xASL_quant_SliceTiming_ShortestTR.m"},{"location":"Functions/#spm","text":"","title":"SPM"},{"location":"Functions/#xasl_spm_biasfieldcorrectionm","text":"Format: xASL_spm_BiasfieldCorrection(PathIn, SPMdir, Quality, MaskName, PathOut) Description: This function is a wrapper around the SPM \"old segment\" function, for biasfield removal. It is tested for M0 and mean control images. It conducts the following steps: Create implicit mask Define SPM 'old segmentation' settings Run SPM 'old segmentation' Delete temporary files Rename temporary SPM file into output file","title":"xASL_spm_BiasfieldCorrection.m"},{"location":"Functions/#xasl_spm_affinem","text":"Format: xASL_spm_affine(srcPath, refPath, fwhmSrc, fwhmRef[,otherList, bDCT, bQuality]) Description: This SPM wrapper runs SPM's old normalize-estimate function, which calculates the affine transformation (i.e. linear + zooming and shearing) that is required to align the source image with the reference image. By default it does not estimate the low-degree Discrete Cosine Transform (DCT) to have a simple affine transformation but this can be enabled in this wrapper. Also note that this affine transformation uses a correlation cost function, hence it requires the source and reference images to have similar contrasts and resolution - or provide the resolution estimates so the smoothing can be done. This function does not change the orientation header by default, but it allows to change those of others through the otherList. If bDCT is used or no otherList given, it stores its estimated affine transformation as orientation difference matrix in a file with the same path but _sn.mat extension. For the provided smoothing FWHM, note that smoothnesses combine with Pythagoras' rule (i.e. square summing).","title":"xASL_spm_affine.m"},{"location":"Functions/#xasl_spm_coregm","text":"Format: xASL_spm_coreg(refPath, srcPath[, OtherList, x, sep, FastReg]) Description: This SPM wrapper runs SPMs coregister-estimate function, which calculates the 6 parameter rigid-body transformation (a.k.a. linear) that is required to align the source image with the reference image. This 6 parameter transformation (i.e. 3 XYZ translations and 3 rotations) is applied to the orientation header of the source NIfTI image, and also to the images provided in OtherList (optional). Note that this SPM registration function uses a normalized mutual information (NMI) by default, enabling registration between two images with different contrast. Note that this algorithm will use the first volume of a multi-volume NIfTI","title":"xASL_spm_coreg.m"},{"location":"Functions/#xasl_spm_defacem","text":"Format: xASL_spm_deface(PathIn, bReplace) Description: This function removes the face from an anatomical NIfTI image, e.g. T1w or FLAIR, for disidentification/privacy purposes. When this script is run after the ExploreASL structural module, it does a pretty good job even for 2D images. However, note that this can always fail, strip part of the brain, or change the output of pipelines. So best not to compare results from defaced and non-defaced images. Also, note that defacing makes it difficult to ensure that the FLAIR and T1w are from the same subject.","title":"xASL_spm_deface.m"},{"location":"Functions/#xasl_spm_deformationsm","text":"Format: xASL_spm_deformations([x,] PathIn, PathOut[, Interpolation, InverseSpace, AffineTrans, DeformationPath]) Description: This ExploreASL wrapper manages the SPM deformation tool. It takes multiple (ExploreASL pipeline) transformations and combines/concatenates them into a single transformation prior to applying it to the input images. This allows to apply multiple transformations with a single interpolation, avoiding propagation of undesired interpolation effects. Mainly used to get native space images into standard space, or vice versa. Best to combine as many files as possible within this function, since the deformation calculation (which is the most computation intensive part) needs to be performed once for multi-file resampling This function runs the following steps:","title":"xASL_spm_deformations.m"},{"location":"Functions/#statistics","text":"","title":"Statistics"},{"location":"Functions/#xasl_stat_atlasforstatsm","text":"Format: [x] = xASL_stat_AtlasForStats(x) Description: This function loads atlases, checks them, and their ROI names, for later use as ROI definition in xASL_stat_GetROIstatistics Note that the atlases should be integer values, or different 4rd dimensions (i.e. multiple images), that are mutually exclusive. This function takes the following steps: Load atlas ROI names There should be a TSV sidecar to the atlas NIfTI file, as explained above. deal with memory mapping Resample atlas 50 1.5 mm^3 MNI Converted atlas with integers to 4D binary image Convert/compress masks into Columns Print atlas overview image","title":"xASL_stat_AtlasForStats.m"},{"location":"Functions/#xasl_stat_computediffercovm","text":"Format: diffCoV = xASL_stat_ComputeDifferCoV(imCBF) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask,bPVC,imGM,imWM) diffCoV = xASL_stat_ComputeDifferCoV(imCBF,imMask,bPVC,imGM,imWM,b3D) Description: It calculates the spatial DiffCoV value on finite part of imCBF. Optionally a mask IMMASK is provide, and PVC is done for bPVC==2 using imGM and imWM masks and constructing pseudoCoV from pseudoCBF image. For bPVC~=2, imGM and imWM are ignored. It is calculated in 2D or assuming also 3D edges based on B3D. Calculate derivate spatial CoV, by summing up differences in CBF between neighbors. The derivative uses Sobels filter.","title":"xASL_stat_ComputeDifferCoV.m"},{"location":"Functions/#xasl_stat_computemeanm","text":"Format: [CBF_GM CBF_WM] = xASL_stat_ComputeMean(imCBF[, imMask, nMinSize, bPVC, bParametric, imGM, imWM]) Description: It calculates mean or median of CBF over the mask imMask if the mask volume exceeds nMinSize. It calculates either a mean, a median, or a mean after PVC, depending on the settings of bPVC. For the PVC options, it needs also imGM and imWM and returns the separate PV-corrected values calculated over the entire ROI. Admin Mask calculations Calculate the ROI statistics 3a. No PVC and simple mean 3b. No PVC and median 3c. Simple PVC 3d. Full PVC on a region","title":"xASL_stat_ComputeMean.m"},{"location":"Functions/#xasl_stat_computespatialcovm","text":"Format: sCov = xASL_stat_ComputeSpatialCoV(imCBF[, imMask, nMinSize, bPVC, bParametric, imGM, imWM]) Description: It calculates the spatial CoV value on finite part of imCBF. Optionally a mask IMMASK is provide, ROIs of size < NMINSIZE are ignored, and PVC is done for bPVC==2 using imGM and imWM masks and constructing pseudoCoV from pseudoCBF image. For bPVC~=2, imGM and imWM are ignored Admin Create masks sCoV computation","title":"xASL_stat_ComputeSpatialCoV.m"},{"location":"Functions/#xasl_stat_equalvariancestestm","text":"Format: [resTest, P] = xASL_stat_EqualVariancesTest(X[, alpha, type]) Description: Brown-Forsythe or Levene's test for equality of variances. The response variable is transformed (yij = abs(xij - median(xj)) for Brown-Forsythe and yij = abs(xij - mean(xj)) for Levene's test). And then runs a one-way ANOVA F-test to check if the variances are equal.","title":"xASL_stat_EqualVariancesTest.m"},{"location":"Functions/#xasl_stat_getroistatisticsm","text":"Format: [x] = xASL_stat_GetROIstatistics(x) Description: This function computes mean and spatial CoV for each ROI, in a [1.5 1.5 1.5] mm MNI space, with several ASL-specific adaptions: Skip ROI masks that are smaller than 1 mL as this would be too noisy for ASL (ignored when x.S.IsASL==false) Expand each ROI mask such that it has sufficient WM content (skipped when IsASL==false) Create for each ROI mask a left, right and bilateral copy Iterate over all subjects: a) Load partial volume maps b) Correct for WMH SEGM -> IS THIS STILL REQUIRED??? c) Load data d) Show ROIs projected on ASL image e) Actual data computations Partial Volume Correction (PVC) options: PVC==0 -> perform masking only, no regression PVC==1 -> single compartment regression, for pGM PVC==2 -> dual compartment regression for pGM & pWM (i.e. normal PVC) Here we mask out susceptibility artifacts (including outside FoV) for all ASL computations, and also mask out vascular artifacts for computing the mean. While other artifacts/FoV can be masked out on population level (i.e. >0.95 subjects need to have a valid signal in a certain voxel), vascular artifacts differ too much in their location between subjects, so we mask this on subject-level. Note that the words \"mask\" and \"ROI\" are used interchangeably throughout this function, where they can have a different or the same meaning PM: WE COULD CHANGE THIS, INTO MASK BEING USED TO EXCLUDE VOXELS AND ROI FOR INCLUDING VOXELS","title":"xASL_stat_GetROIstatistics.m"},{"location":"Functions/#xasl_stat_madnanm","text":"Format: y = xASL_stat_MadNan(x[,flag, dim]) Description: Calculates a Median/Mean Absolute deviation, but ignoring NaNs in the calculation. xASL_stat_MadNan(X) or xASL_stat_MadNan(X,0) computes xASL_stat_MeanNan(ABS(X-xASL_stat_MeanNan(X)) xASL_stat_MadNan(X,1) computes xASL_stat_MedianNan(ABS(X-xASL_st_MedianNan(X)).","title":"xASL_stat_MadNan.m"},{"location":"Functions/#xasl_stat_meanssimm","text":"Format: mssim=xASL_stat_MeanSSIM(imRef,imSrc[,dynRange]) Description: Calculates the similarity index according to Want et al.","title":"xASL_stat_MeanSSIM.m"},{"location":"Functions/#xasl_stat_multiplelinregm","text":"Format: [b,CI,pval,stats] = xASL_stat_MultipleLinReg(X,Y[,bIntercept]) Description: Performs a multiple linear regression Y=b*X+a and provides the intercept and regression coefficients beta including their significance and confidence intervals. It calculates additionally the goodness of the fit.","title":"xASL_stat_MultipleLinReg.m"},{"location":"Functions/#xasl_stat_psnrm","text":"Format: PSNR=xASL_stat_PSNR(imRef,imSrc) Description: Calculates the PSNR, needs two input arguments - 3D images of the same size. Uses 95% percentile instead of MAX.","title":"xASL_stat_PSNR.m"},{"location":"Functions/#xasl_stat_pairwisedicem","text":"Format: [DiceCoeff] = xASL_stat_PairwiseDice(GroupA, GroupB) Description: This function obtains for two lists of images Dice coefficients, for all possible permutations of both lists, by the following steps: 1. Admin (check cell, image exist etc) 2. Obtain matrix of pair-wise permutations 3. Obtain DICE scores PM: Allow entering one group only PM: could extend with xASL_qc_TanimotoCoeff","title":"xASL_stat_PairwiseDice.m"},{"location":"Functions/#xasl_stat_printstatsm","text":"Format: [x] = xASL_stat_PrintStats(x) Description: This function prints an overview of statistics from data that were acquired per ROI, in a TSV file. It starts by printing covariates (called \"Sets\"). Rows will be subjects/sessions, columns will be the sets and ROI-statistics. Any missing data will be skipped (setting them to NaN should have happened in a previous function). This function performs the following steps: First remove previous TSV-file, if already existed printing to a TSV file can be tricky if it is opened by Excel. Make sure to close previous versions first, otherwise this part will crash. Print overview of sets to TSV as explained above. Uses subfunction xASL_stat_CreateLegend to put legends. Aim is to create a single TSV file that has a proper overview of the data, & is self-explanatory to those reading/using it. Define number of ASL sessions, force to 1 in case of TT or volume metrics Print the overview","title":"xASL_stat_PrintStats.m"},{"location":"Functions/#xasl_stat_quantilenanm","text":"Format: y = xASL_stat_QuantileNan(x[,quant, dim]) Description: Calculates a quantile, but ignoring NaNs in the calculation","title":"xASL_stat_QuantileNan.m"},{"location":"Functions/#xasl_stat_robustmeanm","text":"Format: [NoOutliers, iOutliers, ThresholdDeviation] = xASL_stat_RobustMean(IM, ParameterFunction) Description: This function detects outlier images, that can be used to create a robust average, e.g. for template or biasfield creation. This is based either on the sum-of-squares with the mean image (SoS), or on the average relative asymmetry index (AI). Images that are median+/-3 mad off are defined as outliers. MAD = median/mean absolute difference","title":"xASL_stat_RobustMean.m"},{"location":"Functions/#xasl_stat_shapirowilkm","text":"Format: [H, P, W] = xASL_stat_ShapiroWilk(x[, alpha]) Description: Performs the statistical test of normality - null hypothesis is that the sample is from normal distribution with unspecified mean and variance. Based on the sample kurtosis it performs either Shapiro-Wilk (for platykurtic) or Shapiro-Francia test (for leptokurtic).","title":"xASL_stat_ShapiroWilk.m"},{"location":"Functions/#xasl_stat_stdnanm","text":"Format: y = xASL_stat_StdNan(x[,w,dim]) Description: It behaves in a similar way as VAR - it directly passes all arguments to xASL_stat_VarNan.","title":"xASL_stat_StdNan.m"},{"location":"Functions/#xasl_stat_sumnanm","text":"Format: y = xASL_stat_SumNan(x[,dim]) Description: It uses the function SUM, but it sets all the NaNs to zero before calling it.","title":"xASL_stat_SumNan.m"},{"location":"Functions/#xasl_stat_uniquepairwisepermutationsm","text":"Format: [PermutationList] = xASL_stat_UniquePairwisePermutations(GroupA, GroupB) Description: This function lists for one or two samples of indices all possible permutations of indices, performing the following steps: One sample permutations Two sample permutations Print conclusion PM: Allow entering one group only PM: could extend with xASL_qc_TanimotoCoeff","title":"xASL_stat_UniquePairwisePermutations.m"},{"location":"Functions/#xasl_stat_varnanm","text":"Format: y = xASL_stat_VarNan(x[,w,dim]) Description: It behaves in a similar way as VAR.","title":"xASL_stat_VarNan.m"},{"location":"Functions/#xasl_stat_fcdfm","text":"Format: F = xASL_stat_fcdf(F,M,N) Description: Calculates the cumulative distribution function of the F-distribution for degrees of freedom M,N at value F.","title":"xASL_stat_fcdf.m"},{"location":"Functions/#xasl_stat_tcdfm","text":"Format: F = xASL_stat_tcdf(T,nu) Description: Calculates the cumulative distribution function of the Student's t-distribution for degrees of freedom nu at value T.","title":"xASL_stat_tcdf.m"},{"location":"Functions/#xasl_stat_ticdfm","text":"Format: T = xASL_stat_ticdf(P,nu) Description: Calculates the inverse of cumulative distribution function of the Student's t-distribution for degrees of freedom nu at value P.","title":"xASL_stat_ticdf.m"},{"location":"Functions/#xasl_stat_ttestm","text":"Format: [H,P,CI,stats] = xASL_stat_ttest(X[,M,alpha,tail,dim]) Description: Performs a t-test that the distribution of the input data X has a mean different from 0 (or from a given mean M, or that the distributions X and Y have different means). A normal distribution of the data with an unknown variance is assumed.","title":"xASL_stat_ttest.m"},{"location":"Functions/#xasl_stat_ttest2m","text":"Format: [H,P,CI,stats] = xASL_stat_ttest2(X,Y[,alpha,tail,vartype,dim]) Description: Performs a unpaired t-test that the distribution of the input data X has a mean different from that of Y. A normal distribution of the data with an unknown variance is assumed.","title":"xASL_stat_ttest2.m"},{"location":"Functions/#xasl_str2numm","text":"Format: [DataOut] = xASL_str2num(DataIn[, bKeepCell, bReplaceNonNumerical]) Description: str2num wrapper, which only converts strings to numbers, and allows inputting cells. Also, it replaces 'n/a' with NaN (BIDS convention). And it has some other functionality as described in bKeepCell & bReplaceNonNumerical above.","title":"xASL_str2num.m"},{"location":"Functions/#xasl_test_flavorsm","text":"Format: xASL_test_Flavors(pathExploreASL, pathTest[, bTest, x]) Description: Runs the full testing on import and processing of the FlavorsDatabase. The testing directory path has to be provided with the FlavorsDatabase subdirectory containig the Flavors - this subdirectory is read, but not modified. New directories are created for that inside the test directory.","title":"xASL_test_Flavors.m"},{"location":"Functions/#xasl_test_flavors_dcm2bidsm","text":"Format: xASL_test_Flavors_DCM2BIDS(baseDirImport) Description: Runs the DICOM to ASL-BIDS import for all data in the baseDirImport directory. Study directories are supposed to be in, containing a 'sourcedata' folder - this folder can contain subject directories and also sourceStructure.json and studyPar.json specifying the directory structure and the additional study parameters, respectively. The import creates first the 'temp' subfolder with data after dcm2nii and with all tags read and saved to JSON. Then it assembles everything with the studyParameters and makes sure all is in BIDS format and saves it correctly in the 'rawdata' subdirectory. This function runs the following sections: 1. Initialization 2. DICOM -> NII+JSON (i.e. dcm2niiX) 3. Manual curation for certain flavors 3a. Siemens_PCASL_3DGRASE_VD13D_2 3b. Philips_PCASL_3DGRASE_5.4.1.0_TopUp_1 3c. Siemens_PCASL_3DGRASE_VB17A_TopUp_1 3d. Siemens_PCASL_3DGRASE_VB17A_multiPLD_1 4. Convert NII+JSON -> BIDS","title":"xASL_test_Flavors_DCM2BIDS.m"},{"location":"Functions/#xasl_test_getlogcontentm","text":"Format: [logContent] = xASL_test_GetLogContent(rootDir, [printContent], [storeRelativePath], [exportTable]) Description: Get warnings and errors from log files. Input check Load all log files Iterate over log files Optional: Print log content Optional: Export (0 = no export, 1 = TSV export, 2 = XLSX export)","title":"xASL_test_GetLogContent.m"},{"location":"Functions/#visualization","text":"","title":"Visualization"},{"location":"Functions/#xasl_vis_addim2qcm","text":"Format: [x] = xASL_vis_AddIM2QC(x,parms); Description: Checks which images already are loaded, and adds new image.","title":"xASL_vis_AddIM2QC.m"},{"location":"Functions/#xasl_vis_createvisualfigm","text":"Format: [ImOut, FileName] = xASL_vis_CreateVisualFig(x, ImIn[, DirOut, IntScale, NamePrefix, ColorMap, bClip, MaskIn, bWhite, MaxWindow, bTransparancy, bVerbose, bContour]) Description: This function creates a visualization Figure by merging flexibly rearranging NIfTI slices, input matrix or path, managing colormaps for different merged image layers. Current use is for visual QC figures and overview in papers. Function is structured as: Admin, deal with input arguments Process image layers separately * xASL_im_TransformData2View: Reshapes image data into visualization figure * xASL_im_ClipExtremes: Clips image to given percentile also we scale for peak intensity, we make sure that there is no visible clipping/distortion * Convert to colors, using any input colormaps combine image layers, using input argument IntScale print figure This function assumes that the first image is a grayscale background image (e.g. for transparancy reasons), if there are multiple images","title":"xASL_vis_CreateVisualFig.m"},{"location":"Functions/#xasl_vis_cropparmsacquirem","text":"Format: [xmin xmax ymin ymax] = xASL_vis_CropParmsAcquire(temp_image) Description: Goes from outside to inside to acquire crop settings. Works with grayscale images (2 dimensions per slice). Image position information (2D matrix) should be first 2 dimensions. Could include colordimension later on.","title":"xASL_vis_CropParmsAcquire.m"},{"location":"Functions/#xasl_vis_cropparmsapplym","text":"Format: ImageOut = xASL_vis_CropParmsApply(ImageIn,CropParameters) Description: This function crops 2D image matrices.","title":"xASL_vis_CropParmsApply.m"},{"location":"Functions/#xasl_vis_imwritem","text":"Format: [ImOut] = xASL_vis_Imwrite(ImIn, PathOut[, ColorMap, bRescale]) Description: This functions takes an input image matrix, interpolates it to HD resolution (1920x1080) for visibility, and saves the image as jpg. This function avoids the graphic interface of Matlab, for running from CLI Careful: this function overwrites any existing PathOut.","title":"xASL_vis_Imwrite.m"},{"location":"Functions/#xasl_vis_overlapt1_aslm","text":"Format: xASL_vis_OverlapT1_ASL( x, ASL) Description: Part of ExploreASL. Shows spatial agreement ASL and probability maps.","title":"xASL_vis_OverlapT1_ASL.m"},{"location":"Functions/#xasl_vis_tileimagesm","text":"Format: [ImOut] = xASL_vis_TileImages(ImIn, nColumns) Description: Merges selected slices (3D) into one single 2D picture. Plots all slices in one figure with specified rows and columns, aiming for a square tile. PM: can be extended to multiple slices","title":"xASL_vis_TileImages.m"},{"location":"Functions/#xasl_vis_transformdata2viewm","text":"Format: FigureOut = xASL_vis_TransformData2View(ImagesIn, x) Description: This function changes the dimensionality and reshapes the input images in such a way that they are nicely tiled in a mosaic for visualization purposes. Reshaping a series of images with this function can be useful for visualization of SPM/voxel-based analyses.","title":"xASL_vis_TransformData2View.m"},{"location":"Functions/#xasl_vis_visualqc_topupm","text":"Format: [MeanAI_PreTopUp_Perc, MeanAI_PostTopUp_Perc] = xASL_vis_VisualQC_TopUp(PathPopB0, PathPopUnwarped, x, iSubject, CheckDir) Description: This function creates a Figure that showes the effect of TopUp with 6 images with axial slices: the NormPE, RevPE and their difference image in colorscale, and this before (upper row) & after (lower row) TopUp.","title":"xASL_vis_VisualQC_TopUp.m"},{"location":"Functions/#xasl_vis_visualizeroism","text":"Format: xASL_vis_VisualizeROIs(x, ROI_list) Description: Creates for each subject a JPEG image containing the original T1w, WMH_SEGM and T1w after lesion-filling.","title":"xASL_vis_VisualizeROIs.m"},{"location":"Functions/#xasl_wrp_linearreg_others2t1wm","text":"Format: xASL_wrp_LinearReg_Others2T1w(x[, bAutoACPC]) Description: This submodule registers T1c and T2 linearly to the T1w","title":"xASL_wrp_LinearReg_Others2T1w.m"},{"location":"Import_Module/","text":"Submodules of the Import Module xASL_bids_AddGeneratedByField.m Format: xASL_bids_AddGeneratedByField(x, pathJSONin[, pathJSONout]) Description: Add the generated by field to the struct. xASL_bids_BIDS2Legacy.m Format: [dataPar] = xASL_bids_BIDS2Legacy(pathStudy, x[, bOverwrite, dataPar]) Description: This function converts BIDS rawdata (in pathStudy/rawdata/) to xASL legacy derivative format (e.g. pathStudy/derivatives/ExploreASL/) Can be updated step-by-step when ExploreASL's derivative structure moves to BIDS NB: ask how Visits/session layer is defined in bids-matlab (should be separate layer within subjects, but now isn't?) This function performs the following steps: Parse a folder using bids-matlab Define Subject Define SubjectVisit Parse modality Parse scantype Compile paths for copying Manage sidecars to copy Copy files Parse M0 Create DataPar.json Copy participants.tsv Add dataset_description.json Clean up xASL_bids_BIDS2Legacy_CompilePathsForCopying.m Format: [bidsPar, TypeIs, pathOrig, pathDest] = xASL_bids_BIDS2Legacy_CompilePathsForCopying(bidsPar, TypeIs, ModalityIs, RunIs, iSubjSess, BIDS, TypeRunIndex, ModalityFields, pathLegacy_SubjectVisit) Description: Compile paths for BIDS to Legacy copying. xASL_bids_BIDS2Legacy_ManageSidecars.m Format: [bidsPar, pathOrig, pathDest, TypeIs] = xASL_bids_BIDS2Legacy_ManageSidecars(bidsPar, pathOrig, pathDest, TypeIs) Description: Manage JSON sidecars for BIDS2Legacy conversion. xASL_bids_BIDS2Legacy_ParseModality.m Format: xASL_bids_BIDS2Legacy_ParseModality(BIDS, bidsPar, SubjectVisit, iSubjSess, ModalitiesUnique, nModalities, bOverwrite, pathLegacy_SubjectVisit) Description: Parse modality for BIDS to Legacy conversion. xASL_bids_BIDS2Legacy_ParseScanType.m Format: xASL_bids_BIDS2Legacy_ParseScanType(modalityConfiguration, SubjectVisit, RunsUnique, RunsAre, bOverwrite, Reference, bidsPar, ModalityIs, iSubjSess, BIDS, ModalityFields, pathLegacy_SubjectVisit) Description: Parse scan type during BIDS to Legacy conversion. xASL_bids_BIDS2xASL_CopyFile.m Format: xASL_bids_BIDS2xASL_CopyFile(pathOrig, pathDest, bOverwrite) Description: Copy files for BIDS to Legacy conversion. xASL_imp_AppendNiftiParameters.m Format: s = xASL_imp_AppendNiftiParameters(nii_files) Description: Append Nifti Parameters. xASL_imp_AppendParmsParameters.m Format: [s, FieldNames] = xASL_imp_AppendParmsParameters(parms) Description: Append Parms Parameters. xASL_imp_BIDS2Legacy.m Format: [x] = xASL_imp_BIDS2Legacy(x); Description: BIDS to Legacy conversion script which calls xASL_bids_BIDS2Legacy. Input check Start with checking dataset_description.json & rawdata The input is dataset_description.json in the rawdata folder The input is dataPar.json or sourceStructure.json - have to look for a rawdata folder Run the legacy conversion: Check if a dataPar is provided, otherwise use the defaults Overwrite DatasetRoot xASL_imp_CatchErrors.m Format: [dcm2niiCatchedErrors] = xASL_imp_CatchErrors(WarningID, WarningMessage, WarningLine, WarningFileName, WarningPath, scan_name, scanpath, destdir, dcm2niiCatchedErrors, imPar, StackIn) Description: Catch reported warnings/errors, print them if verbose, & add them to a structure of warnings/errors to be stored for later QC. xASL_imp_CreateSummaryFile.m Format: xASL_imp_CreateSummaryFile(imPar, PrintDICOMFields, x, fid_summary) Description: Create summary file. Create summary file Report totals xASL_imp_DCM2NII.m Format: xASL_imp_DCM2NII(imPar, x) Description: Run the dcm2nii part of the import. Initialize defaults of dcm2nii Create the basic folder structure for sourcedata & derivative data Here we try to fix backwards compatibility, but this may break Redirect output to a log file Start with defining the subjects, visits, sessions (i.e. BIDS runs) and scans (i.e. ScanTypes) by listing or typing Sanity check for missing elements Import subject by subject, visit by visit, session by session, scan by scan xASL_imp_DCM2NII_CheckIfFME.m Format: [resultJSON, bTimeEncoded, bTimeEncodedFME] = xASL_imp_DCM2NII_CheckIfFME(nii_files, bTimeEncoded, bTimeEncodedFME) Description: Check if the current sequence is a FME (Fraunhofer Mevis) time encoded sequence. xASL_imp_DCM2NII_ReorderTimeEncoded.m Format: xASL_imp_DCM2NII_ReorderTimeEncoded(nii_files, bTimeEncoded, resultJSON) Description: Reorder TEs and PLDs accordingly for time encoded sequences. xASL_imp_DCM2NII_Subject.m Format: [imPar, summary_lines, PrintDICOMFields, globalCounts, scanNames, dcm2niiCatchedErrors, pathDcmDict] = xASL_imp_DCM2NII_Subject(x, imPar, iSubject, matches, dcm2niiCatchedErrors) Description: Run DCM2NII for one individual subject. Run DCM2NII for one individual subject Iterate over visits Loop through all sessions Iterate over scans Initialize variables (scanID, summary_line, first_match) Convert scan ID to a suitable name and set scan-specific parameters Minimalistic feedback of where we are Now pick the matching one from the folder list Determine input and output paths Start the conversion if this scan should not be skipped Store JSON files In case of a single NII ASL file loaded from PAR/REC, we need to shuffle the dynamics from CCCC...LLLL order to CLCLCLCL... order 9 Copy single dicom as QC placeholder Store the summary info so it can be sorted and printed below xASL_imp_DCM2NII_Subject_ShuffleTheDynamics.m Format: [x, nii_files, summary_line, globalCounts, ASLContext] = xASL_imp_DCM2NII_Subject_ShuffleTheDynamics(x, globalCounts, scanpath, scan_name, nii_files, iSubject, iSession, iScan) Description: Shuffle the dynamics. Fallbacks Fill NIfTI Table Get ASL context if possible Only try shuffling if you dont know the ASL context already Merge NIfTIs if there are multiples for ASL or M0, merge multiple files Extract relevant parameters from nifti header and append to summary file xASL_imp_DCM2NII_Subject_StartConversion.m Format: [imPar, globalCounts, x, summary_line, destdir, scanpath, scan_name, dcm2niiCatchedErrors, nii_files, first_match] = xASL_imp_DCM2NII_Subject_StartConversion(imPar, globalCounts, x, bSkipThisOne, summary_line, destdir, scanpath, scan_name, dcm2niiCatchedErrors) Description: Start of DCM2NII subject conversion. xASL_imp_DCM2NII_Subject_StoreJSON.m Format: [parms, pathDcmDict] = xASL_imp_DCM2NII_Subject_StoreJSON(imPar, SavePathJSON, first_match, bUseDCMTK, pathDcmDict) Description: Store JSON. xASL_imp_Deface.m Format: xASL_imp_Deface(imPar) Description: Run defacing. Iterate over list of subjects Get subject labels Process all anatomical files ( xASL\\_spm\\_deface ) xASL_imp_Initialize.m Format: imPar = xASL_imp_Initialize(studyPath, imParPath) Description: Initialize DCM2NII. Read study file Specify paths Finalize the directories Specify the tokens Specify the additional details of the conversion xASL_imp_NII2BIDS.m Format: xASL_imp_NII2BIDS(x, imPar, studyPath, studyParPath) Description: Run the NII2BIDS conversion. Load the study parameters + dataset description Create the study description output and verify that all is there Go through all subjects and check all the M0 and ASLs and modify the JSONs xASL_imp_NII2BIDS_Run.m Format: xASL_imp_NII2BIDS_Run(bidsPar, studyPar, subjectSessionLabel, inSessionPath, outSessionPath, listRuns, iRun) Description: NII2BIDS conversion for a single sessions, single runs. Convert anat files Convert perf files xASL_imp_NII2BIDS_RunAnat.m Format: xASL_imp_NII2BIDS_RunAnat(bidsPar, studyPar, subjectSessionLabel, inSessionPath, outSessionPath, listRuns, iRun) Description: NII2BIDS conversion for a single sessions, single run. xASL_imp_NII2BIDS_RunPerf.m Format: xASL_imp_NII2BIDS_RunPerf(bidsPar, studyPar, subjectSessionLabel, inSessionPath, outSessionPath, listRuns, iRun) Description: NII2BIDS conversion for a single sessions, single run. Define the pathnames Load the JSONs and NIfTI information BIDSify ASL Prepare the link to M0 in ASL.json BIDSify M0 Save all ASL files (JSON, NIFTI, CONTEXT) to the BIDS directory xASL_imp_NII2BIDS_Session.m Format: xASL_imp_NII2BIDS_Session(imPar, bidsPar, studyPar, listSessions, nameSubjectSession, subjectLabel, iSession) Description: NII2BIDS conversion for a single sessions. Make a subject directory Iterate over runs xASL_imp_NII2BIDS_Subject.m Format: xASL_imp_NII2BIDS_Subject(imPar, bidsPar, studyPar, nameSubject) Description: Run NII to ASL-BIDS for one individual subject. Initialize Process the anat & perfusion files Make a subject directory Iterate over sessions Iterate over runs xASL_imp_NII2BIDS_Subject_DefineM0Type.m Format: [jsonLocal, bJsonLocalM0isFile] = xASL_imp_NII2BIDS_Subject_DefineM0Type(studyPar, bidsPar, jsonLocal, pathM0, linkM0prefix) Description: Define M0 Type xASL_imp_UpdateDatasetRoot.m Format: [x] = xASL_imp_UpdateDatasetRoot(x, studyPath) Description: Update x.opts.DatasetRoot to dataset_description.json after NII2BIDS conversion","title":"Module Import"},{"location":"Import_Module/#submodules-of-the-import-module","text":"","title":"Submodules of the Import Module"},{"location":"Import_Module/#xasl_bids_addgeneratedbyfieldm","text":"Format: xASL_bids_AddGeneratedByField(x, pathJSONin[, pathJSONout]) Description: Add the generated by field to the struct.","title":"xASL_bids_AddGeneratedByField.m"},{"location":"Import_Module/#xasl_bids_bids2legacym","text":"Format: [dataPar] = xASL_bids_BIDS2Legacy(pathStudy, x[, bOverwrite, dataPar]) Description: This function converts BIDS rawdata (in pathStudy/rawdata/) to xASL legacy derivative format (e.g. pathStudy/derivatives/ExploreASL/) Can be updated step-by-step when ExploreASL's derivative structure moves to BIDS NB: ask how Visits/session layer is defined in bids-matlab (should be separate layer within subjects, but now isn't?) This function performs the following steps: Parse a folder using bids-matlab Define Subject Define SubjectVisit Parse modality Parse scantype Compile paths for copying Manage sidecars to copy Copy files Parse M0 Create DataPar.json Copy participants.tsv Add dataset_description.json Clean up","title":"xASL_bids_BIDS2Legacy.m"},{"location":"Import_Module/#xasl_bids_bids2legacy_compilepathsforcopyingm","text":"Format: [bidsPar, TypeIs, pathOrig, pathDest] = xASL_bids_BIDS2Legacy_CompilePathsForCopying(bidsPar, TypeIs, ModalityIs, RunIs, iSubjSess, BIDS, TypeRunIndex, ModalityFields, pathLegacy_SubjectVisit) Description: Compile paths for BIDS to Legacy copying.","title":"xASL_bids_BIDS2Legacy_CompilePathsForCopying.m"},{"location":"Import_Module/#xasl_bids_bids2legacy_managesidecarsm","text":"Format: [bidsPar, pathOrig, pathDest, TypeIs] = xASL_bids_BIDS2Legacy_ManageSidecars(bidsPar, pathOrig, pathDest, TypeIs) Description: Manage JSON sidecars for BIDS2Legacy conversion.","title":"xASL_bids_BIDS2Legacy_ManageSidecars.m"},{"location":"Import_Module/#xasl_bids_bids2legacy_parsemodalitym","text":"Format: xASL_bids_BIDS2Legacy_ParseModality(BIDS, bidsPar, SubjectVisit, iSubjSess, ModalitiesUnique, nModalities, bOverwrite, pathLegacy_SubjectVisit) Description: Parse modality for BIDS to Legacy conversion.","title":"xASL_bids_BIDS2Legacy_ParseModality.m"},{"location":"Import_Module/#xasl_bids_bids2legacy_parsescantypem","text":"Format: xASL_bids_BIDS2Legacy_ParseScanType(modalityConfiguration, SubjectVisit, RunsUnique, RunsAre, bOverwrite, Reference, bidsPar, ModalityIs, iSubjSess, BIDS, ModalityFields, pathLegacy_SubjectVisit) Description: Parse scan type during BIDS to Legacy conversion.","title":"xASL_bids_BIDS2Legacy_ParseScanType.m"},{"location":"Import_Module/#xasl_bids_bids2xasl_copyfilem","text":"Format: xASL_bids_BIDS2xASL_CopyFile(pathOrig, pathDest, bOverwrite) Description: Copy files for BIDS to Legacy conversion.","title":"xASL_bids_BIDS2xASL_CopyFile.m"},{"location":"Import_Module/#xasl_imp_appendniftiparametersm","text":"Format: s = xASL_imp_AppendNiftiParameters(nii_files) Description: Append Nifti Parameters.","title":"xASL_imp_AppendNiftiParameters.m"},{"location":"Import_Module/#xasl_imp_appendparmsparametersm","text":"Format: [s, FieldNames] = xASL_imp_AppendParmsParameters(parms) Description: Append Parms Parameters.","title":"xASL_imp_AppendParmsParameters.m"},{"location":"Import_Module/#xasl_imp_bids2legacym","text":"Format: [x] = xASL_imp_BIDS2Legacy(x); Description: BIDS to Legacy conversion script which calls xASL_bids_BIDS2Legacy. Input check Start with checking dataset_description.json & rawdata The input is dataset_description.json in the rawdata folder The input is dataPar.json or sourceStructure.json - have to look for a rawdata folder Run the legacy conversion: Check if a dataPar is provided, otherwise use the defaults Overwrite DatasetRoot","title":"xASL_imp_BIDS2Legacy.m"},{"location":"Import_Module/#xasl_imp_catcherrorsm","text":"Format: [dcm2niiCatchedErrors] = xASL_imp_CatchErrors(WarningID, WarningMessage, WarningLine, WarningFileName, WarningPath, scan_name, scanpath, destdir, dcm2niiCatchedErrors, imPar, StackIn) Description: Catch reported warnings/errors, print them if verbose, & add them to a structure of warnings/errors to be stored for later QC.","title":"xASL_imp_CatchErrors.m"},{"location":"Import_Module/#xasl_imp_createsummaryfilem","text":"Format: xASL_imp_CreateSummaryFile(imPar, PrintDICOMFields, x, fid_summary) Description: Create summary file. Create summary file Report totals","title":"xASL_imp_CreateSummaryFile.m"},{"location":"Import_Module/#xasl_imp_dcm2niim","text":"Format: xASL_imp_DCM2NII(imPar, x) Description: Run the dcm2nii part of the import. Initialize defaults of dcm2nii Create the basic folder structure for sourcedata & derivative data Here we try to fix backwards compatibility, but this may break Redirect output to a log file Start with defining the subjects, visits, sessions (i.e. BIDS runs) and scans (i.e. ScanTypes) by listing or typing Sanity check for missing elements Import subject by subject, visit by visit, session by session, scan by scan","title":"xASL_imp_DCM2NII.m"},{"location":"Import_Module/#xasl_imp_dcm2nii_checkiffmem","text":"Format: [resultJSON, bTimeEncoded, bTimeEncodedFME] = xASL_imp_DCM2NII_CheckIfFME(nii_files, bTimeEncoded, bTimeEncodedFME) Description: Check if the current sequence is a FME (Fraunhofer Mevis) time encoded sequence.","title":"xASL_imp_DCM2NII_CheckIfFME.m"},{"location":"Import_Module/#xasl_imp_dcm2nii_reordertimeencodedm","text":"Format: xASL_imp_DCM2NII_ReorderTimeEncoded(nii_files, bTimeEncoded, resultJSON) Description: Reorder TEs and PLDs accordingly for time encoded sequences.","title":"xASL_imp_DCM2NII_ReorderTimeEncoded.m"},{"location":"Import_Module/#xasl_imp_dcm2nii_subjectm","text":"Format: [imPar, summary_lines, PrintDICOMFields, globalCounts, scanNames, dcm2niiCatchedErrors, pathDcmDict] = xASL_imp_DCM2NII_Subject(x, imPar, iSubject, matches, dcm2niiCatchedErrors) Description: Run DCM2NII for one individual subject. Run DCM2NII for one individual subject Iterate over visits Loop through all sessions Iterate over scans Initialize variables (scanID, summary_line, first_match) Convert scan ID to a suitable name and set scan-specific parameters Minimalistic feedback of where we are Now pick the matching one from the folder list Determine input and output paths Start the conversion if this scan should not be skipped Store JSON files In case of a single NII ASL file loaded from PAR/REC, we need to shuffle the dynamics from CCCC...LLLL order to CLCLCLCL... order 9 Copy single dicom as QC placeholder Store the summary info so it can be sorted and printed below","title":"xASL_imp_DCM2NII_Subject.m"},{"location":"Import_Module/#xasl_imp_dcm2nii_subject_shufflethedynamicsm","text":"Format: [x, nii_files, summary_line, globalCounts, ASLContext] = xASL_imp_DCM2NII_Subject_ShuffleTheDynamics(x, globalCounts, scanpath, scan_name, nii_files, iSubject, iSession, iScan) Description: Shuffle the dynamics. Fallbacks Fill NIfTI Table Get ASL context if possible Only try shuffling if you dont know the ASL context already Merge NIfTIs if there are multiples for ASL or M0, merge multiple files Extract relevant parameters from nifti header and append to summary file","title":"xASL_imp_DCM2NII_Subject_ShuffleTheDynamics.m"},{"location":"Import_Module/#xasl_imp_dcm2nii_subject_startconversionm","text":"Format: [imPar, globalCounts, x, summary_line, destdir, scanpath, scan_name, dcm2niiCatchedErrors, nii_files, first_match] = xASL_imp_DCM2NII_Subject_StartConversion(imPar, globalCounts, x, bSkipThisOne, summary_line, destdir, scanpath, scan_name, dcm2niiCatchedErrors) Description: Start of DCM2NII subject conversion.","title":"xASL_imp_DCM2NII_Subject_StartConversion.m"},{"location":"Import_Module/#xasl_imp_dcm2nii_subject_storejsonm","text":"Format: [parms, pathDcmDict] = xASL_imp_DCM2NII_Subject_StoreJSON(imPar, SavePathJSON, first_match, bUseDCMTK, pathDcmDict) Description: Store JSON.","title":"xASL_imp_DCM2NII_Subject_StoreJSON.m"},{"location":"Import_Module/#xasl_imp_defacem","text":"Format: xASL_imp_Deface(imPar) Description: Run defacing. Iterate over list of subjects Get subject labels Process all anatomical files ( xASL\\_spm\\_deface )","title":"xASL_imp_Deface.m"},{"location":"Import_Module/#xasl_imp_initializem","text":"Format: imPar = xASL_imp_Initialize(studyPath, imParPath) Description: Initialize DCM2NII. Read study file Specify paths Finalize the directories Specify the tokens Specify the additional details of the conversion","title":"xASL_imp_Initialize.m"},{"location":"Import_Module/#xasl_imp_nii2bidsm","text":"Format: xASL_imp_NII2BIDS(x, imPar, studyPath, studyParPath) Description: Run the NII2BIDS conversion. Load the study parameters + dataset description Create the study description output and verify that all is there Go through all subjects and check all the M0 and ASLs and modify the JSONs","title":"xASL_imp_NII2BIDS.m"},{"location":"Import_Module/#xasl_imp_nii2bids_runm","text":"Format: xASL_imp_NII2BIDS_Run(bidsPar, studyPar, subjectSessionLabel, inSessionPath, outSessionPath, listRuns, iRun) Description: NII2BIDS conversion for a single sessions, single runs. Convert anat files Convert perf files","title":"xASL_imp_NII2BIDS_Run.m"},{"location":"Import_Module/#xasl_imp_nii2bids_runanatm","text":"Format: xASL_imp_NII2BIDS_RunAnat(bidsPar, studyPar, subjectSessionLabel, inSessionPath, outSessionPath, listRuns, iRun) Description: NII2BIDS conversion for a single sessions, single run.","title":"xASL_imp_NII2BIDS_RunAnat.m"},{"location":"Import_Module/#xasl_imp_nii2bids_runperfm","text":"Format: xASL_imp_NII2BIDS_RunPerf(bidsPar, studyPar, subjectSessionLabel, inSessionPath, outSessionPath, listRuns, iRun) Description: NII2BIDS conversion for a single sessions, single run. Define the pathnames Load the JSONs and NIfTI information BIDSify ASL Prepare the link to M0 in ASL.json BIDSify M0 Save all ASL files (JSON, NIFTI, CONTEXT) to the BIDS directory","title":"xASL_imp_NII2BIDS_RunPerf.m"},{"location":"Import_Module/#xasl_imp_nii2bids_sessionm","text":"Format: xASL_imp_NII2BIDS_Session(imPar, bidsPar, studyPar, listSessions, nameSubjectSession, subjectLabel, iSession) Description: NII2BIDS conversion for a single sessions. Make a subject directory Iterate over runs","title":"xASL_imp_NII2BIDS_Session.m"},{"location":"Import_Module/#xasl_imp_nii2bids_subjectm","text":"Format: xASL_imp_NII2BIDS_Subject(imPar, bidsPar, studyPar, nameSubject) Description: Run NII to ASL-BIDS for one individual subject. Initialize Process the anat & perfusion files Make a subject directory Iterate over sessions Iterate over runs","title":"xASL_imp_NII2BIDS_Subject.m"},{"location":"Import_Module/#xasl_imp_nii2bids_subject_definem0typem","text":"Format: [jsonLocal, bJsonLocalM0isFile] = xASL_imp_NII2BIDS_Subject_DefineM0Type(studyPar, bidsPar, jsonLocal, pathM0, linkM0prefix) Description: Define M0 Type","title":"xASL_imp_NII2BIDS_Subject_DefineM0Type.m"},{"location":"Import_Module/#xasl_imp_updatedatasetrootm","text":"Format: [x] = xASL_imp_UpdateDatasetRoot(x, studyPath) Description: Update x.opts.DatasetRoot to dataset_description.json after NII2BIDS conversion","title":"xASL_imp_UpdateDatasetRoot.m"},{"location":"License/","text":"The ExploreASL Software is distributed under the license described below, designed to encourage collabortion while at the same time aiming to reuse commercial profit for academical purpose (e.g. hire an ExploreASL developer). All contents, except for those in the folder //External, are proprietary of ExploreASL . The content in the folder //External is not subject to this license. Provisionary license ExploreASL . This license will be renewed soon after legal checks. ExploreASL , Release 0.999 (c) 2020, Amsterdam University Medical Center (the \"Software\") The Software remains the property of Amsterdam University Medical Center (AUMC, \" the University \"). The Software is distributed \"AS IS\" under this License solely for non-commercial use in the hope that it will be useful, but in order that the University as a charitable foundation protects its assets for the benefit of its educational and research purposes, the University makes clear that no condition is made or to be implied, nor is any warranty given or to be implied, as to the accuracy of the Software , or that it will be suitable for any particular purpose or for use under any specific conditions. Furthermore, the University disclaims all responsibility for the use which is made of the Software . It further disclaims any liability for the outcomes arising from using the Software . The Licensee agrees to indemnify the University and hold the University harmless from and against any and all claims, damages and liabilities asserted by third parties (including claims for negligence) which arise directly or indirectly from the use of the Software or the sale of any products based on the Software . No part of the Software may be reproduced, modified, transmitted or transferred in any form or by any means, electronic or mechanical, without the express permission of the University . The permission of the University is not required if the said reproduction, modification, transmission or transference is done without financial return, the conditions of this License are imposed upon the receiver of the product, and all original and amended source code is included in any transmitted product. You may be held legally responsible for any copyright infringement that is caused or encouraged by your failure to abide by these terms and conditions. You are not permitted under this License to use this Software commercially. Use for which any financial return is received shall be defined as commercial use, and includes (1) integration of all or part of the source code or the Software into a product for sale or license by or on behalf of Licensee to third parties or (2) use of the Software or any derivative of it for research with the final aim of developing software products for sale or license to a third party or (3) use of the Software or any derivative of it for research with the final aim of developing non-software products for sale or license to a third party, or (4) use of the Software to provide any service to an external organization for which payment is received. If you are interested in collaborating or contributing to this Software, please contact Henk Mutsaerts (h.j.mutsaerts@amsterdamumc.nl). If you are interested in using this Software commercially, please contact Innovation Exchange Amsterdam (\"IXA\"), the technology transfer company of the University , to negotiate a license.","title":"License"},{"location":"Modules/","text":"Modules 1. Import Module xASL_module_Import Format: xASL_module_Import(studyPath[, imParPath, studyParPath, bRunSubmodules, bCopySingleDicoms, bUseDCMTK, bCheckPermissions, x]) Description: Import batch T1 , T2 , FLAIR , DWI , fMRI , M0 , ASL data from dicom 2 NIfTI in ASL-BIDS format and structure. Uses dcm2niiX for the conversion, and additionally collects important DICOM header data and puts them in .json sidecars to be used with the ExploreASL pipeline. This function takes any folder input, but the folder input should be specified in the imPar definition. Follow the steps below, for study \"MyStudy\" located on \"//MyDisk\" : Make sure you have your DICOM data. Export them from XNAT, download them, or whatsoever Create a root folder with study ID name, and put the DICOMs in any structure in the sourcedata folder within the study ID root folder Examples: imPar.StudyID: MyStudy Dataset Root folder: //MyDisk/MyStudy sourcedata folder containing DICOMs: //MyDisk/MyStudy/sourcedata Make sure that your DICOM data has any structure that can be retrieved from the folder and/or file names. This function doesn't yet read the DICOM headers For a quick and dirty (but actually slow) function that converts a DICOM folder/file structure into readable format, first run ConvertDicomFolderStructure_CarefulSlow.m. This will read each DICOM individually, and put it in a folder with the name identical to the DICOMs SeriesName/ProtocolName. Once you have all DICOMs in folderstructure with identifyable names inside //MyDisk/MyStudy/sourcedata , set up the folderstructure in ExploreASL_ImportConfig.m. This setup uses the SPM form of regular expressions, which can be daunting at first, but are very flexible. Easiest is to study other examples, before creating your own. For this example, let's say we have //MyDisk/MyStudy/sourcedata/ScanType/SubjectName because we downloaded our data from XNAT, ordered per ScanType first, and then per subject. BRIEF EXPLANATION: Let's suppose we don't have sessions (only a single structural and functional scan per subject) The names of our scans comes out of XNAT as '3D\\_FLAIR\\_eyesClosed' , 'T1w\\_MPRAGE' and 'PCASL\\_10\\_min' and the subject names are 'MyStudy001' .. 'MyStudy002' .. etc. imPar.folderHierarchy - contains a a cell array of regular expressions, with each cell specifying a directory layer/level the parts within brackets () tell the script that this is a token (i.e. subject, session, ScanType) Examples: imPar.folderHierarchy = {'^(3D\\_FLAIR|T1w|PCASL).*', '^(Sub-\\d{3})$'}; here we say that there are two folder layers '', separated by comma , where the names between brackets are used to define what is what. ^ means that the foldername has to start with the following, $ means that the previous has to be the end of the foldername .\\* means anything, anylength, \\d{3} means three digits imPar.tokenOrdering - defines which tokens are captured by the brackets () in imPar.folderHierarchy: position 1==subject , 2==visit , 3==session , 4==ScanType Examples: imPar.tokenOrdering = [2 3 0 1]; stating that subject is the 2nd token, visit is the 3rd token, session has no token (i.e. no session) and ScanType is the 1st token imPar.tokenVisitAliases - cell array that defines the aliases for the Visits, i.e. it tells the script which scans are which timepoint/visit. Similar as explained below for ScanAliases. First column contains the names that are recognized in sourcedata DICOM folders for visits, second column how it is named in NIfTI structure (should be _1 _2 _3 etc). Examples: imPar.tokenVisitAliases = {'Screening','\\_1'; 'Month\\_12','\\_2'; 'Month\\_24','\\_3'; 'Month\\_36','\\_4'; 'Month\\_48','\\_5'}; Note that if you specify tokenVisitAliases, the folders will receive the indices (e.g. \\_1 \\_2 \\_3 ), or even \\_1 only with a single Visit). If you don't specify them, they will not get this postfix. imPar.tokenScanAliases - cell array that defines the aliases for the ScanTypes, i.e. it tells the script which scans are which ScanType. First column should contain regular expression corresponding with the matching criteria in imPar.folderHierarchy whereas the second column contains the alias. Following valid aliases exist: 'T1' 'FLAIR' 'ASL4D' 'M0' 'ASL4D\\_RevPE' 'func' 'func\\_NormPE' 'func\\_RevPE' 'dwi' 'dwi\\_RevPE' 'DSC4D' Examples: imPar.tokenScanAliases = {'^3D\\_FLAIR$', 'FLAIR'; '^T1w$', 'T1'; '^PCASL$', 'ASL4D'}; imPar.tokenSessionAliases - same as tokenScanAliases but for sessions Examples: imPar.tokenSessionAliases = {}; % as we don't have sessions imPar.bMatchDirectories - true if the last layer is a folder, false if the last layer is a filename (as e.g. with PAR/REC, enhanced DICOMs) 2. Structural Module xASL_module_Structural Format: [result, x] = xASL_module_Structural(x) Description: This first ExploreASL module processes the structural images, i.e. high-resolution T1w and FLAIR (if present), on an individual (i.e. subject-to-subject) basis. If a FLAIR is present, this is processed first to obtain a WMH mask to fill the hypointense lesions on the T1w, before segmenting the T1w. For the T1w segmentation this module uses CAT12 by default but if this fails it falls back to SPM after trying to optimize the image contrast. This module has the following steps/submodules/wrappers: 010\\_LinearReg\\_T1w2MNI - Ensure the alignment of subjects' anterior commissure (AC) with the AC in MNI & apply this to all images 020\\_LinearReg\\_FLAIR2T1w - Align the FLAIR (if present) with T1w 030\\_FLAIR\\_BiasfieldCorrection - Perform a biasfield correction (if not performed by LST in following steps) 040\\_LST\\_Segment\\_FLAIR\\_WMH - Segment WMH lesions on FLAIR (if present) 050\\_LST\\_T1w\\_LesionFilling\\_WMH - Use WMH segmentation to fill lesions on T1w 060\\_Segment\\_T1w - Tissue segmentation on T1w 070\\_CleanUpWMH\\_SEGM - Extra WMH cleanup of some over- and under-segmentation 080\\_Resample2StandardSpace - Clone all images to standard space 090\\_GetVolumetrics - Obtain whole-brain volumes of GM, WM, CSF, WMH 100\\_VisualQC - Obtain QC parameters & save QC Figures 110\\_DoWADQCDC - QC for WAD-QC DICOM server (OPTIONAL) 3. ASL Module xASL_module_ASL Format: [result, x] = xASL_module_ASL(x) Description: This ExploreASL module processes the ASL images, i.e. ASL4D, M0, etc (if present), on an individual (i.e. session-to-session, where session indicates BIDS \"run\") basis. Both 2D and 3D options are automatially chosen, as well as processing of time-series (if available), such as motion correction and outlier exclusion. This module has the following submodules/wrappers: 010\\_TopUpASL - FSL TopUp geometric distortion correction (if M0 images with reversed phase-encoding are present) 020\\_RealignASL - If time-series are present, motion correction and outlier exclusion (ENABLE) 030\\_RegisterASL - Registration of ASL to T1w anatomical images (if lacking, to MNI images) 040\\_ResampleASL - Resample ASL images to standard space 050\\_PreparePV - Create partial volume images in ASL space with ASL resolution 060\\_ProcessM0 - M0 image processing 070\\_CreateAnalysisMask - Create mask using FoV, vascular outliers & susceptibility atlas 080\\_Quantification - CBF quantification 090\\_VisualQC\\_ASL - Generate QC parameters & images 100\\_WADQC - QC for WAD-QC DICOM server (OPTIONAL) 4. Population Module xASL_module_Population Format: [result, x] = xASL_module_Population(x) Description: This ExploreASL module processes all available images on the group level. It assumes that all images were adequately processed in the previous modules. It will perform the following group-wise processing and checks: 010\\_CreatePopulationTemplates - Create population average images, to compare scanners, cohorts etc without physiological variance 020\\_CreateAnalysisMask - Generate a group-level mask by combining individuals masks, for ROI-based analysis & VBA 030\\_CreateBiasfield - When there are multiple scanners, create scanner-specific biasfields (uses Site.mat for this) 040\\_GetDICOMStatistics - Create TSV file with overview of DICOM parameters 050\\_GetVolumeStatistics - Create TSV file with overview of volumetric parameters 060\\_GetMotionStatistics - Create TSV file with overview of motion parameters 065\\_GetRegistrationStatistics - Create TSV file with overview of the registration statistics 070\\_GetROIstatistics - Create TSV file with overview of regional values (e.g. qCBF, mean control, pGM etc) 080\\_SortBySpatialCoV - Sort ASL_Check QC images by their spatial CoV in quality bins 090\\_DeleteTempFiles - Delete temporary files","title":"Modules"},{"location":"Modules/#modules","text":"","title":"Modules"},{"location":"Modules/#1-import-module","text":"","title":"1. Import Module"},{"location":"Modules/#xasl_module_import","text":"Format: xASL_module_Import(studyPath[, imParPath, studyParPath, bRunSubmodules, bCopySingleDicoms, bUseDCMTK, bCheckPermissions, x]) Description: Import batch T1 , T2 , FLAIR , DWI , fMRI , M0 , ASL data from dicom 2 NIfTI in ASL-BIDS format and structure. Uses dcm2niiX for the conversion, and additionally collects important DICOM header data and puts them in .json sidecars to be used with the ExploreASL pipeline. This function takes any folder input, but the folder input should be specified in the imPar definition. Follow the steps below, for study \"MyStudy\" located on \"//MyDisk\" : Make sure you have your DICOM data. Export them from XNAT, download them, or whatsoever Create a root folder with study ID name, and put the DICOMs in any structure in the sourcedata folder within the study ID root folder Examples: imPar.StudyID: MyStudy Dataset Root folder: //MyDisk/MyStudy sourcedata folder containing DICOMs: //MyDisk/MyStudy/sourcedata Make sure that your DICOM data has any structure that can be retrieved from the folder and/or file names. This function doesn't yet read the DICOM headers For a quick and dirty (but actually slow) function that converts a DICOM folder/file structure into readable format, first run ConvertDicomFolderStructure_CarefulSlow.m. This will read each DICOM individually, and put it in a folder with the name identical to the DICOMs SeriesName/ProtocolName. Once you have all DICOMs in folderstructure with identifyable names inside //MyDisk/MyStudy/sourcedata , set up the folderstructure in ExploreASL_ImportConfig.m. This setup uses the SPM form of regular expressions, which can be daunting at first, but are very flexible. Easiest is to study other examples, before creating your own. For this example, let's say we have //MyDisk/MyStudy/sourcedata/ScanType/SubjectName because we downloaded our data from XNAT, ordered per ScanType first, and then per subject. BRIEF EXPLANATION: Let's suppose we don't have sessions (only a single structural and functional scan per subject) The names of our scans comes out of XNAT as '3D\\_FLAIR\\_eyesClosed' , 'T1w\\_MPRAGE' and 'PCASL\\_10\\_min' and the subject names are 'MyStudy001' .. 'MyStudy002' .. etc. imPar.folderHierarchy - contains a a cell array of regular expressions, with each cell specifying a directory layer/level the parts within brackets () tell the script that this is a token (i.e. subject, session, ScanType) Examples: imPar.folderHierarchy = {'^(3D\\_FLAIR|T1w|PCASL).*', '^(Sub-\\d{3})$'}; here we say that there are two folder layers '', separated by comma , where the names between brackets are used to define what is what. ^ means that the foldername has to start with the following, $ means that the previous has to be the end of the foldername .\\* means anything, anylength, \\d{3} means three digits imPar.tokenOrdering - defines which tokens are captured by the brackets () in imPar.folderHierarchy: position 1==subject , 2==visit , 3==session , 4==ScanType Examples: imPar.tokenOrdering = [2 3 0 1]; stating that subject is the 2nd token, visit is the 3rd token, session has no token (i.e. no session) and ScanType is the 1st token imPar.tokenVisitAliases - cell array that defines the aliases for the Visits, i.e. it tells the script which scans are which timepoint/visit. Similar as explained below for ScanAliases. First column contains the names that are recognized in sourcedata DICOM folders for visits, second column how it is named in NIfTI structure (should be _1 _2 _3 etc). Examples: imPar.tokenVisitAliases = {'Screening','\\_1'; 'Month\\_12','\\_2'; 'Month\\_24','\\_3'; 'Month\\_36','\\_4'; 'Month\\_48','\\_5'}; Note that if you specify tokenVisitAliases, the folders will receive the indices (e.g. \\_1 \\_2 \\_3 ), or even \\_1 only with a single Visit). If you don't specify them, they will not get this postfix. imPar.tokenScanAliases - cell array that defines the aliases for the ScanTypes, i.e. it tells the script which scans are which ScanType. First column should contain regular expression corresponding with the matching criteria in imPar.folderHierarchy whereas the second column contains the alias. Following valid aliases exist: 'T1' 'FLAIR' 'ASL4D' 'M0' 'ASL4D\\_RevPE' 'func' 'func\\_NormPE' 'func\\_RevPE' 'dwi' 'dwi\\_RevPE' 'DSC4D' Examples: imPar.tokenScanAliases = {'^3D\\_FLAIR$', 'FLAIR'; '^T1w$', 'T1'; '^PCASL$', 'ASL4D'}; imPar.tokenSessionAliases - same as tokenScanAliases but for sessions Examples: imPar.tokenSessionAliases = {}; % as we don't have sessions imPar.bMatchDirectories - true if the last layer is a folder, false if the last layer is a filename (as e.g. with PAR/REC, enhanced DICOMs)","title":"xASL_module_Import"},{"location":"Modules/#2-structural-module","text":"","title":"2. Structural Module"},{"location":"Modules/#xasl_module_structural","text":"Format: [result, x] = xASL_module_Structural(x) Description: This first ExploreASL module processes the structural images, i.e. high-resolution T1w and FLAIR (if present), on an individual (i.e. subject-to-subject) basis. If a FLAIR is present, this is processed first to obtain a WMH mask to fill the hypointense lesions on the T1w, before segmenting the T1w. For the T1w segmentation this module uses CAT12 by default but if this fails it falls back to SPM after trying to optimize the image contrast. This module has the following steps/submodules/wrappers: 010\\_LinearReg\\_T1w2MNI - Ensure the alignment of subjects' anterior commissure (AC) with the AC in MNI & apply this to all images 020\\_LinearReg\\_FLAIR2T1w - Align the FLAIR (if present) with T1w 030\\_FLAIR\\_BiasfieldCorrection - Perform a biasfield correction (if not performed by LST in following steps) 040\\_LST\\_Segment\\_FLAIR\\_WMH - Segment WMH lesions on FLAIR (if present) 050\\_LST\\_T1w\\_LesionFilling\\_WMH - Use WMH segmentation to fill lesions on T1w 060\\_Segment\\_T1w - Tissue segmentation on T1w 070\\_CleanUpWMH\\_SEGM - Extra WMH cleanup of some over- and under-segmentation 080\\_Resample2StandardSpace - Clone all images to standard space 090\\_GetVolumetrics - Obtain whole-brain volumes of GM, WM, CSF, WMH 100\\_VisualQC - Obtain QC parameters & save QC Figures 110\\_DoWADQCDC - QC for WAD-QC DICOM server (OPTIONAL)","title":"xASL_module_Structural"},{"location":"Modules/#3-asl-module","text":"","title":"3. ASL Module"},{"location":"Modules/#xasl_module_asl","text":"Format: [result, x] = xASL_module_ASL(x) Description: This ExploreASL module processes the ASL images, i.e. ASL4D, M0, etc (if present), on an individual (i.e. session-to-session, where session indicates BIDS \"run\") basis. Both 2D and 3D options are automatially chosen, as well as processing of time-series (if available), such as motion correction and outlier exclusion. This module has the following submodules/wrappers: 010\\_TopUpASL - FSL TopUp geometric distortion correction (if M0 images with reversed phase-encoding are present) 020\\_RealignASL - If time-series are present, motion correction and outlier exclusion (ENABLE) 030\\_RegisterASL - Registration of ASL to T1w anatomical images (if lacking, to MNI images) 040\\_ResampleASL - Resample ASL images to standard space 050\\_PreparePV - Create partial volume images in ASL space with ASL resolution 060\\_ProcessM0 - M0 image processing 070\\_CreateAnalysisMask - Create mask using FoV, vascular outliers & susceptibility atlas 080\\_Quantification - CBF quantification 090\\_VisualQC\\_ASL - Generate QC parameters & images 100\\_WADQC - QC for WAD-QC DICOM server (OPTIONAL)","title":"xASL_module_ASL"},{"location":"Modules/#4-population-module","text":"","title":"4. Population Module"},{"location":"Modules/#xasl_module_population","text":"Format: [result, x] = xASL_module_Population(x) Description: This ExploreASL module processes all available images on the group level. It assumes that all images were adequately processed in the previous modules. It will perform the following group-wise processing and checks: 010\\_CreatePopulationTemplates - Create population average images, to compare scanners, cohorts etc without physiological variance 020\\_CreateAnalysisMask - Generate a group-level mask by combining individuals masks, for ROI-based analysis & VBA 030\\_CreateBiasfield - When there are multiple scanners, create scanner-specific biasfields (uses Site.mat for this) 040\\_GetDICOMStatistics - Create TSV file with overview of DICOM parameters 050\\_GetVolumeStatistics - Create TSV file with overview of volumetric parameters 060\\_GetMotionStatistics - Create TSV file with overview of motion parameters 065\\_GetRegistrationStatistics - Create TSV file with overview of the registration statistics 070\\_GetROIstatistics - Create TSV file with overview of regional values (e.g. qCBF, mean control, pGM etc) 080\\_SortBySpatialCoV - Sort ASL_Check QC images by their spatial CoV in quality bins 090\\_DeleteTempFiles - Delete temporary files","title":"xASL_module_Population"},{"location":"Population_Module/","text":"Submodules of the Population Module xASL_adm_DeleteManyTempFiles.m Format: xASL_adm_DeleteManyTempFiles(x) Description: This function removes as many files as possible. xASL_adm_GzipAllFiles.m Format: xASL_adm_GzipAllFiles(ROOT, bFolder, bUseLinux, pathExternal) Description: This function zips NIfTI files or folders recursively and deletes the original file/folder after zipping. xASL_im_CreateAnalysisMask.m Format: [x] = xASL_im_CreateAnalysisMask(x, Threshold) Description: This function takes the mean population-based probability maps of masks, thresholds and combines them: A. Creation GM, WM & WholeBrain masks by p>0.5 B. Create, combine & save vascular, susceptibity & FoV masks: - MaskVascular - MaskSusceptibility = MaskSusceptibility & MaskFoV C. Create & save VBA mask - MaskAnalysis = MaskVascular & MaskSusceptibility - x.S.VBAmask = MaskAnalysis & GMmask D. Visualization: Creates a figure with columns being following maps/masks overlaid over mean population T1w: 1. FoV probability 0-50% missing voxels 2. Vascular 0-7.5% missing voxels 3. Susceptibility 0-50% missing voxels 4. Analysis mask xASL_qc_SortBySpatialCoV.m Format: xASL_qc_SortBySpatialCoV(x, Threshold1, Threshold2) Description: This function organizes the ASL QC images in //analysis/Population/ASLCheck into CBF, vascular and artifactual contrast per the spatial CoV thresholds defined above, in folders: //analysis/Population/ASLCheck/1_CBFContrast //analysis/Population/ASLCheck/2_VascularContrast //analysis/Population/ASLCheck/3_ArtifactualContrast Invalid spatial CoV numbers (e.g. NaN) will go to: //analysis/Population/ASLCheck/4_Unknown_sCoV Note: these outputs need to be visually checked; but pre-sorting them by spatial CoV puts them already in categories that are quick to skim through and manually correct by moving the images The idea is then that only category 1 images are used for perfusion (CBF) analyses, both categories 1 & 2 for the vascular (sCoV) analyses, and the category 3 images excluded from analysis. PM: this code does not include multiple sessions per subject yet! NB: this code uses the //analysis/Population/Stats/CoV_qCBF*TotalGM*.csv file, make sure that this file isn't edited! xASL_stat_ComputeWsCV.m Format: xASL_stat_ComputeWsCV(x) Description: Calculates the within and between-subject coefficient of variance (wsCV and bsCV respectively), to estimate the power to detect effects. This requires 4D images that have been split. xASL_stat_GetAcquisitionTime.m Format: [x] = xASL_stat_GetAcquisitionTime(x) Description: This functions collects the DICOM field AcquisitionTime from each json sidecar (& parms.mat for backward compatibility) and saves them in the participants.tsv. Additionally, it creates a AcquisitionTime histogram of the full study, which can be useful to check time of scanning -> can influence physiological CBF variability. Collect times Save times Create time histogram xASL_stat_GetDICOMStatistics.m Format: xASL_stat_GetDICOMStatistics(x, ScanType, HasSessions) Description: This functions prints DICOM metadata (e.g. parameters used for quantification) and collects them in a single tsv (per BIDS). Summarizes this for the total population. Can be useful to detect software upgrades, where only slight parameter changes can hint on quantification changes. This function carries out the following steps: Load & save individual parameter files Print summary Write TSV file xASL_stat_GetMotionStatistics.m Format: xASL_stat_GetMotionStatistics(x) Description: This functions collects motion stats, with the following steps: Collect motion data If no data, skip this function Print motion vs exclusion overview Add motion data to participants.tsv xASL_stat_GetRegistrationStatistics.m Format: xASL_stat_GetRegistrationStatistics(x) Description: Loads the data from the study given in the QC_collection*.json files. Goes through all subjects and sessions and prints the Tanimoto coefficients that define the quality of the registrations. Steps: Load & extract parameters from individual parameter files Write TSV file xASL_stat_GetVolumeStatistics.m Format: xASL_stat_GetVolumeStatistics(x) Description: This functions collects motion stats, with the following. Steps: Collect structural volume data Collect WMH data Add stats in participants.tsv xASL_wrp_CreateBiasfield.m Format: xASL_wrp_CreateBiasfield(x) Description: This function creates a smooth biasfield as intensity map to normalize intensities between different sequences/scanner/sites within a single study. This is a simple pragmatic approach and is not validated, but is the best we can do. First acquires average additive & multiplicative factors for total GM, then does a smooth voxel-wise rescaling. This doesn't make an assumption whether site or sequence differences are additive or multiplicative, but rather fits them both. Global scaling it performed to GM CBF == 60 mL/100g/min NB: make sure that sequence resolution differences have been taken in account before creating these biasfields PM: add normalization of between-subjects SD as well. PM: are there other things we can normalize? xASL_wrp_CreatePopulationTemplates.m Format: xASL_wrp_CreatePopulationTemplates(x[, bSaveUnmasked, Compute4Sets, SpecificScantype, bSkipWhenMissingScans, bRemoveOutliers, FunctionsAre]) Description: This function creates simple parametric images, a.k.a. templates, for different image/scan types, on population level, as well as for different sets (e.g. sites/scanners/cohorts, etc) if specified. By default these images are masked, and transformed into a single column, for quick computations with low memory usage. The default parametric images that are created are the mean, between-subject SD, and the maximal intensity projection (MIP). The latter can e.g. identify intra-vascular signal that is similar between different subjects. Other parametric maps can be decommented (now commented out for speed). Any new addition to participants.tsv will be recognized and loaded, for the generation of new parametric maps for groups specifically (needs to be set in input argument bCompute4Sets) If a set only includes a combination of the following SetOptions: left, right, l, r, n/a, NaN (irrespective of capitals) each image with option right/r, will be flipped in the left-right direction, and left/right will not be treated as separate groups. This function performs the following steps: Define images/scantypes (if they are not defined by input argument SpecificScantype) Iterate over scan types & sessions Check availability images Load images Remove outliers Compute templates for all subjects together (only for bilateral images) Compute templates for individual sets xASL_wrp_GetROIstatistics.m Format: xASL_wrp_GetROIstatistics(x) Description: This wrapper organizes the computation of statistics for different ROIs in a [1.5 1.5 1.5] mm MNI space: Load the atlas: xASL_stat_AtlasForStats Organize TSV output name: using x.S.output_ID Obtain the ROI statistics: xASL_stat_GetROIstatistics Print statistics in TSV files: xASL_stat_PrintStats","title":"Module Population"},{"location":"Population_Module/#submodules-of-the-population-module","text":"","title":"Submodules of the Population Module"},{"location":"Population_Module/#xasl_adm_deletemanytempfilesm","text":"Format: xASL_adm_DeleteManyTempFiles(x) Description: This function removes as many files as possible.","title":"xASL_adm_DeleteManyTempFiles.m"},{"location":"Population_Module/#xasl_adm_gzipallfilesm","text":"Format: xASL_adm_GzipAllFiles(ROOT, bFolder, bUseLinux, pathExternal) Description: This function zips NIfTI files or folders recursively and deletes the original file/folder after zipping.","title":"xASL_adm_GzipAllFiles.m"},{"location":"Population_Module/#xasl_im_createanalysismaskm","text":"Format: [x] = xASL_im_CreateAnalysisMask(x, Threshold) Description: This function takes the mean population-based probability maps of masks, thresholds and combines them: A. Creation GM, WM & WholeBrain masks by p>0.5 B. Create, combine & save vascular, susceptibity & FoV masks: - MaskVascular - MaskSusceptibility = MaskSusceptibility & MaskFoV C. Create & save VBA mask - MaskAnalysis = MaskVascular & MaskSusceptibility - x.S.VBAmask = MaskAnalysis & GMmask D. Visualization: Creates a figure with columns being following maps/masks overlaid over mean population T1w: 1. FoV probability 0-50% missing voxels 2. Vascular 0-7.5% missing voxels 3. Susceptibility 0-50% missing voxels 4. Analysis mask","title":"xASL_im_CreateAnalysisMask.m"},{"location":"Population_Module/#xasl_qc_sortbyspatialcovm","text":"Format: xASL_qc_SortBySpatialCoV(x, Threshold1, Threshold2) Description: This function organizes the ASL QC images in //analysis/Population/ASLCheck into CBF, vascular and artifactual contrast per the spatial CoV thresholds defined above, in folders: //analysis/Population/ASLCheck/1_CBFContrast //analysis/Population/ASLCheck/2_VascularContrast //analysis/Population/ASLCheck/3_ArtifactualContrast Invalid spatial CoV numbers (e.g. NaN) will go to: //analysis/Population/ASLCheck/4_Unknown_sCoV Note: these outputs need to be visually checked; but pre-sorting them by spatial CoV puts them already in categories that are quick to skim through and manually correct by moving the images The idea is then that only category 1 images are used for perfusion (CBF) analyses, both categories 1 & 2 for the vascular (sCoV) analyses, and the category 3 images excluded from analysis. PM: this code does not include multiple sessions per subject yet! NB: this code uses the //analysis/Population/Stats/CoV_qCBF*TotalGM*.csv file, make sure that this file isn't edited!","title":"xASL_qc_SortBySpatialCoV.m"},{"location":"Population_Module/#xasl_stat_computewscvm","text":"Format: xASL_stat_ComputeWsCV(x) Description: Calculates the within and between-subject coefficient of variance (wsCV and bsCV respectively), to estimate the power to detect effects. This requires 4D images that have been split.","title":"xASL_stat_ComputeWsCV.m"},{"location":"Population_Module/#xasl_stat_getacquisitiontimem","text":"Format: [x] = xASL_stat_GetAcquisitionTime(x) Description: This functions collects the DICOM field AcquisitionTime from each json sidecar (& parms.mat for backward compatibility) and saves them in the participants.tsv. Additionally, it creates a AcquisitionTime histogram of the full study, which can be useful to check time of scanning -> can influence physiological CBF variability. Collect times Save times Create time histogram","title":"xASL_stat_GetAcquisitionTime.m"},{"location":"Population_Module/#xasl_stat_getdicomstatisticsm","text":"Format: xASL_stat_GetDICOMStatistics(x, ScanType, HasSessions) Description: This functions prints DICOM metadata (e.g. parameters used for quantification) and collects them in a single tsv (per BIDS). Summarizes this for the total population. Can be useful to detect software upgrades, where only slight parameter changes can hint on quantification changes. This function carries out the following steps: Load & save individual parameter files Print summary Write TSV file","title":"xASL_stat_GetDICOMStatistics.m"},{"location":"Population_Module/#xasl_stat_getmotionstatisticsm","text":"Format: xASL_stat_GetMotionStatistics(x) Description: This functions collects motion stats, with the following steps: Collect motion data If no data, skip this function Print motion vs exclusion overview Add motion data to participants.tsv","title":"xASL_stat_GetMotionStatistics.m"},{"location":"Population_Module/#xasl_stat_getregistrationstatisticsm","text":"Format: xASL_stat_GetRegistrationStatistics(x) Description: Loads the data from the study given in the QC_collection*.json files. Goes through all subjects and sessions and prints the Tanimoto coefficients that define the quality of the registrations. Steps: Load & extract parameters from individual parameter files Write TSV file","title":"xASL_stat_GetRegistrationStatistics.m"},{"location":"Population_Module/#xasl_stat_getvolumestatisticsm","text":"Format: xASL_stat_GetVolumeStatistics(x) Description: This functions collects motion stats, with the following. Steps: Collect structural volume data Collect WMH data Add stats in participants.tsv","title":"xASL_stat_GetVolumeStatistics.m"},{"location":"Population_Module/#xasl_wrp_createbiasfieldm","text":"Format: xASL_wrp_CreateBiasfield(x) Description: This function creates a smooth biasfield as intensity map to normalize intensities between different sequences/scanner/sites within a single study. This is a simple pragmatic approach and is not validated, but is the best we can do. First acquires average additive & multiplicative factors for total GM, then does a smooth voxel-wise rescaling. This doesn't make an assumption whether site or sequence differences are additive or multiplicative, but rather fits them both. Global scaling it performed to GM CBF == 60 mL/100g/min NB: make sure that sequence resolution differences have been taken in account before creating these biasfields PM: add normalization of between-subjects SD as well. PM: are there other things we can normalize?","title":"xASL_wrp_CreateBiasfield.m"},{"location":"Population_Module/#xasl_wrp_createpopulationtemplatesm","text":"Format: xASL_wrp_CreatePopulationTemplates(x[, bSaveUnmasked, Compute4Sets, SpecificScantype, bSkipWhenMissingScans, bRemoveOutliers, FunctionsAre]) Description: This function creates simple parametric images, a.k.a. templates, for different image/scan types, on population level, as well as for different sets (e.g. sites/scanners/cohorts, etc) if specified. By default these images are masked, and transformed into a single column, for quick computations with low memory usage. The default parametric images that are created are the mean, between-subject SD, and the maximal intensity projection (MIP). The latter can e.g. identify intra-vascular signal that is similar between different subjects. Other parametric maps can be decommented (now commented out for speed). Any new addition to participants.tsv will be recognized and loaded, for the generation of new parametric maps for groups specifically (needs to be set in input argument bCompute4Sets) If a set only includes a combination of the following SetOptions: left, right, l, r, n/a, NaN (irrespective of capitals) each image with option right/r, will be flipped in the left-right direction, and left/right will not be treated as separate groups. This function performs the following steps: Define images/scantypes (if they are not defined by input argument SpecificScantype) Iterate over scan types & sessions Check availability images Load images Remove outliers Compute templates for all subjects together (only for bilateral images) Compute templates for individual sets","title":"xASL_wrp_CreatePopulationTemplates.m"},{"location":"Population_Module/#xasl_wrp_getroistatisticsm","text":"Format: xASL_wrp_GetROIstatistics(x) Description: This wrapper organizes the computation of statistics for different ROIs in a [1.5 1.5 1.5] mm MNI space: Load the atlas: xASL_stat_AtlasForStats Organize TSV output name: using x.S.output_ID Obtain the ROI statistics: xASL_stat_GetROIstatistics Print statistics in TSV files: xASL_stat_PrintStats","title":"xASL_wrp_GetROIstatistics.m"},{"location":"Requirements/","text":"Requirements Developer Note The following requirements are necessary to robustly execute the ExploreASL workflow. ExploreASL is tested on Debian/Ubuntu 20.04 LTS with Matlab 2019a. Using an older version of Linux or Matlab could lead to errors. Software Requirements Matlab 2019a Debian/Ubuntu 20.04 LTS Hardware Requirements 4 GB RAM Included Software Versions of included & used third-party tools: SPM12 7219 CAT12 r1615 LST 2.0.15","title":"Requirements"},{"location":"Requirements/#requirements","text":"","title":"Requirements"},{"location":"Requirements/#developer-note","text":"The following requirements are necessary to robustly execute the ExploreASL workflow. ExploreASL is tested on Debian/Ubuntu 20.04 LTS with Matlab 2019a. Using an older version of Linux or Matlab could lead to errors.","title":"Developer Note"},{"location":"Requirements/#software-requirements","text":"Matlab 2019a Debian/Ubuntu 20.04 LTS","title":"Software Requirements"},{"location":"Requirements/#hardware-requirements","text":"4 GB RAM","title":"Hardware Requirements"},{"location":"Requirements/#included-software","text":"Versions of included & used third-party tools: SPM12 7219 CAT12 r1615 LST 2.0.15","title":"Included Software"},{"location":"SPMxASL/","text":"SPM xASL Functions CorrClusTh.m Format: function [k,Pc] = CorrClusTh(SPM,u,alpha,guess) Description: Finds the corrected cluster size (spatial extent) threshold for a given cluster defining threshold u and FWE-corrected level alpha. xASL_Copy.m Format: xASL_Copy(SrxASL_SysCopyath, DstPath[, bOverwrite, bVerbose)]) Description: Copies a file to a file or a directory to a directory. For a file, it zips it in the end if the destination path contains nii.gz. It also makes sure that only one of .nii and .nii.gz exists in the destination directory. It is faster than the default Matlab function, and runs on multiple OSes. NB: This function calls xASL_SysMove for the actual copying. Run xASL_SysMove instead of xASL_Move if you don't want the .nii|.nii.gz management/checking xASL_Move.m Format: xASL_Move(SrcPath, DstPath[, bOverwrite, bVerbose]) Description: Moves a file to a file, a file to a directory, or a directory to a directory. It manages the unzipping or zipping according to the extension after the move. And it makes sure that only one of .nii and .nii.gz exists in the destination directory. Bypass inefficient Matlab stuff on Linux and Windows, but can only move on the same file system. NB: This function calls xASL_SysMove for the actual moving. Run xASL_SysMove instead of xASL_Move if you don't want the .nii|.nii.gz management/checking xASL_SysCopy.m Format: xASL_SysCopy(SrcPath, DstPath, bOverwrite, bVerbose) Description: Copies a file to a file or a directory to a directory. Bypass inefficient matlab stuff on linux and windows, but can only move on the same file system. xASL_SysMove.m Format: xASL_SysMove(SrcPath, DstPath[, bForce, bSourceCheck]) Description: Moves a file to a file, a file to a directory, or a directory to a directory. SBypass inefficient matlab stuff on linux and windows, but can only move on same file system! xASL_TrackProgress.m Format: xASL_TrackProgress(iCurrent[, iMax]) Description: Counts the percentage of the work done and display on the screen. Either iCurrent of iMax are given. Or only the percentages are given. xASL_adm_ConvertSeconds2TimeString.m Format: TimeString = xASL_adm_ConvertSeconds2TimeString(Seconds) Description: Converts number to time input hh (with minutes in fractions/floating point) -> output hhmm Inverse from xASL_adm_ConvertTime2Nr. xASL_adm_ConvertSlash.m Format: [newString] = xASL_adm_ConvertSlash( StringOriginal,ForceUnix) Description: Converts Windows forward slashes to backward slashes Prevents confusion file separation & regular expression forward slashes in Windows. xASL_adm_CreateDir.m Format: status = xASL_adm_CreateDir(strPath) create all missing subdirs status = xASL_adm_CreateDir(strPath, strBranch) create strBranch (if missing) under existing strPath status = xASL_adm_CreateDir(strPath, nMaxNewDirs) impose limit on the number of new directories Description: Recursively creates missing directories at the given path or for given subdirectories, with an option to limit the number of newly created directories. xASL_adm_DeleteFileList.m Format: filepaths = xASL_adm_DeleteFileList(strDirectory, strRegEx[, bRecurse, nRequired]) xASL_adm_DeleteFileList(strDirectory, strRegEx[, bRecurse, nRequired]) Description: Delete the files that match regular expression STRREGEXP in the given directory STRDIRECTORY. Deletes recursively if specified in BRECURSE. Deletes all files unless the number is specified by NREQUIRED, if the number is not met, then does not delete anything and throws an error. xASL_adm_GetFileList.m Format: filepaths = xASL_adm_GetFileList(strDirectory[, strRegEx, mode, nRequired, bGetDirNames]) Description: List files or directories from a given path. And optionally uses regular expressions to filter the result with option to set a minimal requirement on the number of results. xASL_adm_GzipNifti.m Format: pathOut = xASL_adm_GzipNifti(pathIn [,bOverwrite]) Description: Take the input file, zips it, overwriting any existing zipped file and return the path of the zipped file. xASL_adm_ManageMoCoMat.m Format: xASL_adm_ManageMoCoMat(PathIn) Description: This function manages the orientation matrices that SPM puts in an external .mat sidecar file if there are more than 1 volumes. The first volume should be equal to the orientation header of the NIfTI, if not, we assume that the NIfTI header is correct. This function performs several checks & corrects if necessary, combined with throwing a warning: A) the nVolumes in .mat & .nii image should be equal, if not, delete sidecar B) .mat should have more than one volume, if not delete sidecar C) If there are illegal numbers in the diagonal of the .mat orientation matrices (here only checked for zeros or non finite values) then the .mat is removed D) If this is true for the first volume only, the .mat is retained but the first volume orientation is overwritten with a zero matrix xASL_adm_UnixPath.m Format: [PathIs] = xASL_adm_UnixPath(PathIs[, bTryWSL]) Description: This function performs the following steps to convert a path to a path that is compatible with the Unix-filesystem as used in e.g. Linux/MacOS. It also has special support for Windows Subsystem for Linux (WSL), though this should only be activated specifically for WSL calls. Note that we want to use this function for most Unix calls (to fix paths), but in the case of WSL only for some calls, where Matlab in Windows calls Linux-code through WSL (e.g. for FSL) - these have to be explicitly specified by the bTryWSL option. Skip this function without Unix-filesystem Trim whitespace Selectively convert forward to backward slashes (ignore already escaped whitespace) Escape characters and residual whitespaces (ignore already escaped whitespaces) If WSL: add mounting prefix xASL_adm_UnzipNifti.m Format: pathOut = xASL_adm_UnzipNifti(pathIn[, bOverwrite]) Description: Takes the input file, unzips if needed, delete the zipped file and return the path to the unzipped file. If the input is already unzipped, then does nothing, but returns the original filename - so it can be run just to be sure a file is unzipped without much overhead. Returns error if more than one file is in the archive, if the filename does not exist, is a directory etc. If there's a NII and NII.GZ already existing, then return error, or just overwrite in case overwrite is set to 1 xASL_adm_ZipFileNameHandling.m Format: [srcOut, dstOut] = xASL_adm_ZipFileNameHandling(srcIn, dstIn) Description: Adjusts the source and destination filenames of a nifti file to reflect if NII or NII.GZ exist on the input. If either .nii or .nii.gz is corrupt, it automatically deletes the corrupt one and keeps the healthy one, while reporting a warning. This happens when you restart the pipeline after it crashed, if it crashed while unzipping. xASL_bids_csv2tsvReadWrite.m Format: [PathTSV, CellContents] = xASL_bids_csv2tsvReadWrite(PathIn[, bDeleteCSV, bWriteTSV]) Description: This function PathIn and loads it, also trying CSV or TSV extensions if these exist. It outputs the contents to a cell array. If a CSV file exists but not a TSV file, it converts and replaces the CSV to TSV file, per BIDS. This function has the following parts: Read the CSV or TSV file Write the TSV file (if requested) Delete the CSV file (if requested) xASL_csvRead.m Format: [CellContents] = xASL_csvRead(PathCSV) Description: This function loads a comma-separated value (csv) file - which is the format that BIDS prefers - and outputs it to a cell array. xASL_csvWrite.m Format: xASL_csvWrite(InputCell, PathCSV, bOverwrite) Description: Rudimentary function, please use xASL_tsvWrite instead. For usage, type help xASL_tsvWrite. This function will still work though. xASL_delete.m Format: xASL_delete(InputPath) Description: Delete the file in the given path. If a NIFTI file with extension '.nii' or '.nii.gz' is given, Then delete both the .nii and .nii.gz files. xASL_exist.m Format: xASL_exist(PathIn[,Type]) Description: Check if the given path exists, wrapper around the Matlab exist function, to allow checking for either .nii or .nii.gz Otherwise, exist is used normally. xASL_fileparts.m Format: [Fpath, Ffile, Fext] = xASL_fileparts(InputPath) Description: Returns the path, file name, and file extension for InputPath using the fileparts.m function. If a file ending at nii.gz is given, then the whole nii.gz is returned as the extension. Does not verify the existence of the file, or existence of .nii or .nii.gz xASL_im_ConvertMap2Mask.m Format: [IMout] = xASL_im_ConvertMap2Mask(IMin) Description: Provides a robust way of conversion of a continuous map to a binary mask, which can be used for lesions, ROIs, or tissue probability maps. Based on the assumption that a map should be thresholded at 50% to form a map, which is often the case for automatic segmentations. xASL_im_DistanceTransform.m Format: [dist, x, y, z] = xASL_im_DistanceTransform(im) Description: Calculates the distance transform in a binary image Uses Borgefors Chamfers computation of Euclidean distance in 3D using a 5x5x5 window. xASL_im_FillNaNs.m Format: xASL_im_FillNaNs(InputPath[, UseMethod, bQuality]) Description: This function fills any NaNs in an image. In SPM, any voxels outside the boundary box/field of view are filled by NaNs when resampling. These NaNs can confuse some algorithms, hence it doesn't hurt replacing them in some cases (e.g. for flowfields). Also, smoothing restricted in a mask is done in ExploreASL with the function xASL_im_ndnanfilter, after first setting all voxels outside the mask to NaN. In this case, this functon can be useful to extrapolate the smoothed image to avoid any division artifact near brain edges (e.g. for reducing the M0 image to a smooth biasfield). This function performs the following 3 steps: Load image Replace NaNs Save image xASL_im_LesionRemoval4CAT.m Format: [Ycls, LesionImOut] = xASL_im_LesionRemoval4CAT(Ycls, PathIn) Description: For all lesion masks in the anatomical directory, remove them from the current segmentations. xASL_im_ResampleIM.m Format: [imOut] = xASL_im_ResampleIM(imIn, matIn, matOut, dimOut[, interpolationType]) Description: Resamples an input image imIn oriented according to the homogeneous matrix matIn to and output image imOut that has dimension dimOut and matrix matOut. This allows to resample images between two spaces with different orientation and matrix sizes. It uses the Matlab interp3 function and the interpolation method used by this method can be chosen. Note that the recommended use of this function is resampling between space with similar resolution or upsampling. For downsampling, simple interpolation does not delivery correct results respecting the point-spread-function and a combination of xASL_im_PreSmooth and xASL_spm_reslice should be used instead. xASL_im_SaveOriginal4CAT.m Format: xASL_im_SaveOriginal4CAT(Ycls, PathIn) Description: Save the segmentation before lesion masking. xASL_im_conv3Dsep.m Format: [imConv] = xASL_mex_conv3Dsep(im,kX,[kY,kZ]) Description: 3D separable convolution with a supplied kernel It converts the results to double Returned is the convoluted image The wrapper makes sure that kX are Nx1 format, removes nan, and removes excessive zeros at the ends. xASL_im_ndnanfilter.m Format: [Y,fil] = xASL_im_ndnanfilter(X,filterType,F,WNAN) Description: This function applies a 3-dimensional convolution of X with given kernel. NaNs elements are taken into account (ignored). By default, edges are not padded and one-sided filter is used at the image edges. Notes: * Accepts empty value for any input. When X is empty, the program can be used as a N-dimensional window generator. * NaNs elements surrounded by no-NaNs elements (which will depend on window width) are the ones that will be interpolated. The others are leaved untouched. * When WNAN=2, the programs acts like an NAN-interpolat/GAP-filling, leaving untouched the no-NaNs elements but the filtering is perfomed anyway. I recommend the default behaviour (WNAN=0) in order to keep the filtered data in the workspace, and then use the code at the end of this function to get/remove the interpolated NaNs * To achieve similar results as ndnanfilter previously, use same F as with the 'rect' filter. * Note that the FWHM of Gaussian is given in VOXELS, not in mm * For the Gaussian filter, use (previous N, new FWHM) N= 1 ~ FWHM 0.94 N= 2 ~ FWHM 1.885 N= 4 ~ FWHM 3.76 N= 6 ~ FWHM 5.652 N= 8 ~ FWHM 7.536 N=10 ~ FWHM 9.42 N=12 ~ FWHM 11.3 N=16 ~ FWHM 15.07 N=20 ~ FWHM 18.84 N=10/2.355 ~ FWHM 4 Basically divide by 1.06 xASL_io_Nifti2Im.m Format: imOut = xASL_io_Nifti2Im(niftiIn [, ImageSize]) Description: This function loads a NIfTI image matrix with flexible input (as explained under INPUT: niftiIn). It does the following. Try to load a NIfTI If NIfTI successfully loaded, try to load the NIfTI image If the above didnt work, try to create a dummy image Convert to single precision data format Also able to load NIfTI as .nii.mat format xASL_io_ReadNifti.m Format: [NiftiObject, pathIn] = xASL_io_ReadNifti(pathIn) Description: Read Nifti file given by the path. Return the NII object. And also return the actual path to the loaded Nifti if by any reason the name changed during the function runtime (e.g. unzipping). xASL_io_SaveNifti.m Format: xASL_io_SaveNifti(pathOrigNifti, pathNewNifti, imNew[, nBits, bGZip, newMat]) Description: It loads the pathOrigNifti, takes all the parameters from it, and creates a new Nifti file with these parameters, but new image matrix from imNew. It saves the result in pathNewNifti. It runs the following steps: Unzipping and manage name input file Determine the bit precision Create new NIfTI Remove redundant .mat orientation files Delete any pre-existing NIfTI files with the same name xASL_round.m Format: [OutputN] = xASL_round(InputN[, PrecisionN]) Description: Recent Matlab versions support a second input that specifies that number of decimals to round at, but earlier Matlab versions do not support this. For backward compatibility, use this wrapper instead of round. xASL_spm_admin.m Format: xASL_spm_admin(pathIn[, bPadComma1]) Description: This SPM admin function takes a NIfTI path and does a few checks to make this valid to SPM. It accepts both .nii and .nii.gz. It runs the following steps: 1. Unzip .nii.gz 2. Convert char to cell 3. Add ',1' suffix xASL_spm_reslice.m Format: xASL_spm_reslice(refPath, srcPath[, srcAffinePath, bInvAffine, bQuality, NewName, InterpolationPar]) Description: This wrapper runs SPM's reslice function (a.k.a. coregister: reslice) which resamples a source image into the space of a reference image, taking into account any orientation differences between the two images that are defined in the orientation matrix in the NIfTI header. When the source image contains multiple volumes, they are all resampled. The source image will get the same orientation matrix as the reference image, as it is now in the same space as the reference image. This can be useful when two images are to be compared voxel-by-voxel, e.g. when overlaying a CBF image over a structural image, or when wanting to use a mask from a different space. When after running this function, the reference and source images are not in alignment, they need to be registered first (i.e. xASL_spm_register). Resampling/reslicing needs an interpolation method to know from which voxels of the source image, a voxel in the new image will be computed. A simplistic explanation is that this determines the number of surrounding neighborhood voxels it uses to determine the new voxel value. The example syntax below would reslice/resample the CBF image to the T1w space (assuming the Affine was done to register CBF to T1w) It also works with the external .mat file of the source file that has the same name as the source file. It also can optionally take a _sn.mat containing the affine transformation information. xASL_spm_smooth.m Format: xASL_spm_smooth(pathIn, fwhmSmooth, pathNew]) Description: This SPM wrapper runs SPM's smooth function, which spatially smooths the input image with a Gaussian kernel. In the case of multiple volumes (i.e. a 4D NIfTI), each 3D volume is spatially smoothed separately. Note that smoothnesses combine with Pythagoras' rule (i.e. sum quadratically) xASL_stat_MeanNan.m Format: y = xASL_stat_MeanNan(x[,dim]) Description: It calculates the sum using the SUM functions and divides by the number of values but ignoring NaNs. xASL_stat_MedianNan.m Format: y = xASL_stat_MedianNan(x[,dim]) Description: It calculates the MEDIAN along the given dimension, but it sets all the NaNs to zero before calling it. xASL_tsvRead.m Format: [CellContents] = xASL_tsvRead(PathTSV[, bStruct]) Description: This function loads a tab-separated value (TSV) file - which is the format that BIDS prefers - and outputs it to a cell array. xASL_tsvWrite.m Format: xASL_tsvWrite(InputCell, PathTSV[, bOverwrite, bCSV]) Description: This function loads a cell array and prints it to a tab-separated value (TSV) file, which is the format that BIDS prefers. xASL_wrp_DARTELSaveIntermedTrans.m Format: xASL_wrp_DARTELSaveIntermedTrans(Yy, u, odim, rdim, idim, Mar, mat, M0, M1, nameOut, numIteration) Description: This function is called from the CAT12 segmentation function to save the intermediate results of the DARTEL transformation. Normally, the registration only saves the final results - the final transformation field. This function enables to save also the intermediate transformation field. It takes all the internal variables from the transformation and save the field to a sub-directory 'mri' that normally contains all the intermediate results of the CAT12 segmentation. It adds a 'y_' prefix and adds the specified iteration number as postfix. xASL_wrp_GSSaveIntermedTrans.m Format: xASL_wrp_GSSaveIntermedTrans(y, idim, odim, rdim, M0, M1, R, M1t, M1r, nameOut, numIteration) Description: This function is called from the CAT12 segmentation function to save the intermediate results of the Geodesic shooting transformation. Normally, the registration only saves the final results - the final transformation field. This function enables to save also the intermediate transformation field. It takes all the internal variables from the transformation and save the field to a sub-directory 'mri' that normally contains all the intermediate results of the CAT12 segmentation. It adds a 'y_' prefix and adds the specified iteration number as postfix.","title":"SPM xASL Functions"},{"location":"SPMxASL/#spm-xasl-functions","text":"","title":"SPM xASL Functions"},{"location":"SPMxASL/#corrclusthm","text":"Format: function [k,Pc] = CorrClusTh(SPM,u,alpha,guess) Description: Finds the corrected cluster size (spatial extent) threshold for a given cluster defining threshold u and FWE-corrected level alpha.","title":"CorrClusTh.m"},{"location":"SPMxASL/#xasl_copym","text":"Format: xASL_Copy(SrxASL_SysCopyath, DstPath[, bOverwrite, bVerbose)]) Description: Copies a file to a file or a directory to a directory. For a file, it zips it in the end if the destination path contains nii.gz. It also makes sure that only one of .nii and .nii.gz exists in the destination directory. It is faster than the default Matlab function, and runs on multiple OSes. NB: This function calls xASL_SysMove for the actual copying. Run xASL_SysMove instead of xASL_Move if you don't want the .nii|.nii.gz management/checking","title":"xASL_Copy.m"},{"location":"SPMxASL/#xasl_movem","text":"Format: xASL_Move(SrcPath, DstPath[, bOverwrite, bVerbose]) Description: Moves a file to a file, a file to a directory, or a directory to a directory. It manages the unzipping or zipping according to the extension after the move. And it makes sure that only one of .nii and .nii.gz exists in the destination directory. Bypass inefficient Matlab stuff on Linux and Windows, but can only move on the same file system. NB: This function calls xASL_SysMove for the actual moving. Run xASL_SysMove instead of xASL_Move if you don't want the .nii|.nii.gz management/checking","title":"xASL_Move.m"},{"location":"SPMxASL/#xasl_syscopym","text":"Format: xASL_SysCopy(SrcPath, DstPath, bOverwrite, bVerbose) Description: Copies a file to a file or a directory to a directory. Bypass inefficient matlab stuff on linux and windows, but can only move on the same file system.","title":"xASL_SysCopy.m"},{"location":"SPMxASL/#xasl_sysmovem","text":"Format: xASL_SysMove(SrcPath, DstPath[, bForce, bSourceCheck]) Description: Moves a file to a file, a file to a directory, or a directory to a directory. SBypass inefficient matlab stuff on linux and windows, but can only move on same file system!","title":"xASL_SysMove.m"},{"location":"SPMxASL/#xasl_trackprogressm","text":"Format: xASL_TrackProgress(iCurrent[, iMax]) Description: Counts the percentage of the work done and display on the screen. Either iCurrent of iMax are given. Or only the percentages are given.","title":"xASL_TrackProgress.m"},{"location":"SPMxASL/#xasl_adm_convertseconds2timestringm","text":"Format: TimeString = xASL_adm_ConvertSeconds2TimeString(Seconds) Description: Converts number to time input hh (with minutes in fractions/floating point) -> output hhmm Inverse from xASL_adm_ConvertTime2Nr.","title":"xASL_adm_ConvertSeconds2TimeString.m"},{"location":"SPMxASL/#xasl_adm_convertslashm","text":"Format: [newString] = xASL_adm_ConvertSlash( StringOriginal,ForceUnix) Description: Converts Windows forward slashes to backward slashes Prevents confusion file separation & regular expression forward slashes in Windows.","title":"xASL_adm_ConvertSlash.m"},{"location":"SPMxASL/#xasl_adm_createdirm","text":"Format: status = xASL_adm_CreateDir(strPath) create all missing subdirs status = xASL_adm_CreateDir(strPath, strBranch) create strBranch (if missing) under existing strPath status = xASL_adm_CreateDir(strPath, nMaxNewDirs) impose limit on the number of new directories Description: Recursively creates missing directories at the given path or for given subdirectories, with an option to limit the number of newly created directories.","title":"xASL_adm_CreateDir.m"},{"location":"SPMxASL/#xasl_adm_deletefilelistm","text":"Format: filepaths = xASL_adm_DeleteFileList(strDirectory, strRegEx[, bRecurse, nRequired]) xASL_adm_DeleteFileList(strDirectory, strRegEx[, bRecurse, nRequired]) Description: Delete the files that match regular expression STRREGEXP in the given directory STRDIRECTORY. Deletes recursively if specified in BRECURSE. Deletes all files unless the number is specified by NREQUIRED, if the number is not met, then does not delete anything and throws an error.","title":"xASL_adm_DeleteFileList.m"},{"location":"SPMxASL/#xasl_adm_getfilelistm","text":"Format: filepaths = xASL_adm_GetFileList(strDirectory[, strRegEx, mode, nRequired, bGetDirNames]) Description: List files or directories from a given path. And optionally uses regular expressions to filter the result with option to set a minimal requirement on the number of results.","title":"xASL_adm_GetFileList.m"},{"location":"SPMxASL/#xasl_adm_gzipniftim","text":"Format: pathOut = xASL_adm_GzipNifti(pathIn [,bOverwrite]) Description: Take the input file, zips it, overwriting any existing zipped file and return the path of the zipped file.","title":"xASL_adm_GzipNifti.m"},{"location":"SPMxASL/#xasl_adm_managemocomatm","text":"Format: xASL_adm_ManageMoCoMat(PathIn) Description: This function manages the orientation matrices that SPM puts in an external .mat sidecar file if there are more than 1 volumes. The first volume should be equal to the orientation header of the NIfTI, if not, we assume that the NIfTI header is correct. This function performs several checks & corrects if necessary, combined with throwing a warning: A) the nVolumes in .mat & .nii image should be equal, if not, delete sidecar B) .mat should have more than one volume, if not delete sidecar C) If there are illegal numbers in the diagonal of the .mat orientation matrices (here only checked for zeros or non finite values) then the .mat is removed D) If this is true for the first volume only, the .mat is retained but the first volume orientation is overwritten with a zero matrix","title":"xASL_adm_ManageMoCoMat.m"},{"location":"SPMxASL/#xasl_adm_unixpathm","text":"Format: [PathIs] = xASL_adm_UnixPath(PathIs[, bTryWSL]) Description: This function performs the following steps to convert a path to a path that is compatible with the Unix-filesystem as used in e.g. Linux/MacOS. It also has special support for Windows Subsystem for Linux (WSL), though this should only be activated specifically for WSL calls. Note that we want to use this function for most Unix calls (to fix paths), but in the case of WSL only for some calls, where Matlab in Windows calls Linux-code through WSL (e.g. for FSL) - these have to be explicitly specified by the bTryWSL option. Skip this function without Unix-filesystem Trim whitespace Selectively convert forward to backward slashes (ignore already escaped whitespace) Escape characters and residual whitespaces (ignore already escaped whitespaces) If WSL: add mounting prefix","title":"xASL_adm_UnixPath.m"},{"location":"SPMxASL/#xasl_adm_unzipniftim","text":"Format: pathOut = xASL_adm_UnzipNifti(pathIn[, bOverwrite]) Description: Takes the input file, unzips if needed, delete the zipped file and return the path to the unzipped file. If the input is already unzipped, then does nothing, but returns the original filename - so it can be run just to be sure a file is unzipped without much overhead. Returns error if more than one file is in the archive, if the filename does not exist, is a directory etc. If there's a NII and NII.GZ already existing, then return error, or just overwrite in case overwrite is set to 1","title":"xASL_adm_UnzipNifti.m"},{"location":"SPMxASL/#xasl_adm_zipfilenamehandlingm","text":"Format: [srcOut, dstOut] = xASL_adm_ZipFileNameHandling(srcIn, dstIn) Description: Adjusts the source and destination filenames of a nifti file to reflect if NII or NII.GZ exist on the input. If either .nii or .nii.gz is corrupt, it automatically deletes the corrupt one and keeps the healthy one, while reporting a warning. This happens when you restart the pipeline after it crashed, if it crashed while unzipping.","title":"xASL_adm_ZipFileNameHandling.m"},{"location":"SPMxASL/#xasl_bids_csv2tsvreadwritem","text":"Format: [PathTSV, CellContents] = xASL_bids_csv2tsvReadWrite(PathIn[, bDeleteCSV, bWriteTSV]) Description: This function PathIn and loads it, also trying CSV or TSV extensions if these exist. It outputs the contents to a cell array. If a CSV file exists but not a TSV file, it converts and replaces the CSV to TSV file, per BIDS. This function has the following parts: Read the CSV or TSV file Write the TSV file (if requested) Delete the CSV file (if requested)","title":"xASL_bids_csv2tsvReadWrite.m"},{"location":"SPMxASL/#xasl_csvreadm","text":"Format: [CellContents] = xASL_csvRead(PathCSV) Description: This function loads a comma-separated value (csv) file - which is the format that BIDS prefers - and outputs it to a cell array.","title":"xASL_csvRead.m"},{"location":"SPMxASL/#xasl_csvwritem","text":"Format: xASL_csvWrite(InputCell, PathCSV, bOverwrite) Description: Rudimentary function, please use xASL_tsvWrite instead. For usage, type help xASL_tsvWrite. This function will still work though.","title":"xASL_csvWrite.m"},{"location":"SPMxASL/#xasl_deletem","text":"Format: xASL_delete(InputPath) Description: Delete the file in the given path. If a NIFTI file with extension '.nii' or '.nii.gz' is given, Then delete both the .nii and .nii.gz files.","title":"xASL_delete.m"},{"location":"SPMxASL/#xasl_existm","text":"Format: xASL_exist(PathIn[,Type]) Description: Check if the given path exists, wrapper around the Matlab exist function, to allow checking for either .nii or .nii.gz Otherwise, exist is used normally.","title":"xASL_exist.m"},{"location":"SPMxASL/#xasl_filepartsm","text":"Format: [Fpath, Ffile, Fext] = xASL_fileparts(InputPath) Description: Returns the path, file name, and file extension for InputPath using the fileparts.m function. If a file ending at nii.gz is given, then the whole nii.gz is returned as the extension. Does not verify the existence of the file, or existence of .nii or .nii.gz","title":"xASL_fileparts.m"},{"location":"SPMxASL/#xasl_im_convertmap2maskm","text":"Format: [IMout] = xASL_im_ConvertMap2Mask(IMin) Description: Provides a robust way of conversion of a continuous map to a binary mask, which can be used for lesions, ROIs, or tissue probability maps. Based on the assumption that a map should be thresholded at 50% to form a map, which is often the case for automatic segmentations.","title":"xASL_im_ConvertMap2Mask.m"},{"location":"SPMxASL/#xasl_im_distancetransformm","text":"Format: [dist, x, y, z] = xASL_im_DistanceTransform(im) Description: Calculates the distance transform in a binary image Uses Borgefors Chamfers computation of Euclidean distance in 3D using a 5x5x5 window.","title":"xASL_im_DistanceTransform.m"},{"location":"SPMxASL/#xasl_im_fillnansm","text":"Format: xASL_im_FillNaNs(InputPath[, UseMethod, bQuality]) Description: This function fills any NaNs in an image. In SPM, any voxels outside the boundary box/field of view are filled by NaNs when resampling. These NaNs can confuse some algorithms, hence it doesn't hurt replacing them in some cases (e.g. for flowfields). Also, smoothing restricted in a mask is done in ExploreASL with the function xASL_im_ndnanfilter, after first setting all voxels outside the mask to NaN. In this case, this functon can be useful to extrapolate the smoothed image to avoid any division artifact near brain edges (e.g. for reducing the M0 image to a smooth biasfield). This function performs the following 3 steps: Load image Replace NaNs Save image","title":"xASL_im_FillNaNs.m"},{"location":"SPMxASL/#xasl_im_lesionremoval4catm","text":"Format: [Ycls, LesionImOut] = xASL_im_LesionRemoval4CAT(Ycls, PathIn) Description: For all lesion masks in the anatomical directory, remove them from the current segmentations.","title":"xASL_im_LesionRemoval4CAT.m"},{"location":"SPMxASL/#xasl_im_resampleimm","text":"Format: [imOut] = xASL_im_ResampleIM(imIn, matIn, matOut, dimOut[, interpolationType]) Description: Resamples an input image imIn oriented according to the homogeneous matrix matIn to and output image imOut that has dimension dimOut and matrix matOut. This allows to resample images between two spaces with different orientation and matrix sizes. It uses the Matlab interp3 function and the interpolation method used by this method can be chosen. Note that the recommended use of this function is resampling between space with similar resolution or upsampling. For downsampling, simple interpolation does not delivery correct results respecting the point-spread-function and a combination of xASL_im_PreSmooth and xASL_spm_reslice should be used instead.","title":"xASL_im_ResampleIM.m"},{"location":"SPMxASL/#xasl_im_saveoriginal4catm","text":"Format: xASL_im_SaveOriginal4CAT(Ycls, PathIn) Description: Save the segmentation before lesion masking.","title":"xASL_im_SaveOriginal4CAT.m"},{"location":"SPMxASL/#xasl_im_conv3dsepm","text":"Format: [imConv] = xASL_mex_conv3Dsep(im,kX,[kY,kZ]) Description: 3D separable convolution with a supplied kernel It converts the results to double Returned is the convoluted image The wrapper makes sure that kX are Nx1 format, removes nan, and removes excessive zeros at the ends.","title":"xASL_im_conv3Dsep.m"},{"location":"SPMxASL/#xasl_im_ndnanfilterm","text":"Format: [Y,fil] = xASL_im_ndnanfilter(X,filterType,F,WNAN) Description: This function applies a 3-dimensional convolution of X with given kernel. NaNs elements are taken into account (ignored). By default, edges are not padded and one-sided filter is used at the image edges. Notes: * Accepts empty value for any input. When X is empty, the program can be used as a N-dimensional window generator. * NaNs elements surrounded by no-NaNs elements (which will depend on window width) are the ones that will be interpolated. The others are leaved untouched. * When WNAN=2, the programs acts like an NAN-interpolat/GAP-filling, leaving untouched the no-NaNs elements but the filtering is perfomed anyway. I recommend the default behaviour (WNAN=0) in order to keep the filtered data in the workspace, and then use the code at the end of this function to get/remove the interpolated NaNs * To achieve similar results as ndnanfilter previously, use same F as with the 'rect' filter. * Note that the FWHM of Gaussian is given in VOXELS, not in mm * For the Gaussian filter, use (previous N, new FWHM) N= 1 ~ FWHM 0.94 N= 2 ~ FWHM 1.885 N= 4 ~ FWHM 3.76 N= 6 ~ FWHM 5.652 N= 8 ~ FWHM 7.536 N=10 ~ FWHM 9.42 N=12 ~ FWHM 11.3 N=16 ~ FWHM 15.07 N=20 ~ FWHM 18.84 N=10/2.355 ~ FWHM 4 Basically divide by 1.06","title":"xASL_im_ndnanfilter.m"},{"location":"SPMxASL/#xasl_io_nifti2imm","text":"Format: imOut = xASL_io_Nifti2Im(niftiIn [, ImageSize]) Description: This function loads a NIfTI image matrix with flexible input (as explained under INPUT: niftiIn). It does the following. Try to load a NIfTI If NIfTI successfully loaded, try to load the NIfTI image If the above didnt work, try to create a dummy image Convert to single precision data format Also able to load NIfTI as .nii.mat format","title":"xASL_io_Nifti2Im.m"},{"location":"SPMxASL/#xasl_io_readniftim","text":"Format: [NiftiObject, pathIn] = xASL_io_ReadNifti(pathIn) Description: Read Nifti file given by the path. Return the NII object. And also return the actual path to the loaded Nifti if by any reason the name changed during the function runtime (e.g. unzipping).","title":"xASL_io_ReadNifti.m"},{"location":"SPMxASL/#xasl_io_saveniftim","text":"Format: xASL_io_SaveNifti(pathOrigNifti, pathNewNifti, imNew[, nBits, bGZip, newMat]) Description: It loads the pathOrigNifti, takes all the parameters from it, and creates a new Nifti file with these parameters, but new image matrix from imNew. It saves the result in pathNewNifti. It runs the following steps: Unzipping and manage name input file Determine the bit precision Create new NIfTI Remove redundant .mat orientation files Delete any pre-existing NIfTI files with the same name","title":"xASL_io_SaveNifti.m"},{"location":"SPMxASL/#xasl_roundm","text":"Format: [OutputN] = xASL_round(InputN[, PrecisionN]) Description: Recent Matlab versions support a second input that specifies that number of decimals to round at, but earlier Matlab versions do not support this. For backward compatibility, use this wrapper instead of round.","title":"xASL_round.m"},{"location":"SPMxASL/#xasl_spm_adminm","text":"Format: xASL_spm_admin(pathIn[, bPadComma1]) Description: This SPM admin function takes a NIfTI path and does a few checks to make this valid to SPM. It accepts both .nii and .nii.gz. It runs the following steps: 1. Unzip .nii.gz 2. Convert char to cell 3. Add ',1' suffix","title":"xASL_spm_admin.m"},{"location":"SPMxASL/#xasl_spm_reslicem","text":"Format: xASL_spm_reslice(refPath, srcPath[, srcAffinePath, bInvAffine, bQuality, NewName, InterpolationPar]) Description: This wrapper runs SPM's reslice function (a.k.a. coregister: reslice) which resamples a source image into the space of a reference image, taking into account any orientation differences between the two images that are defined in the orientation matrix in the NIfTI header. When the source image contains multiple volumes, they are all resampled. The source image will get the same orientation matrix as the reference image, as it is now in the same space as the reference image. This can be useful when two images are to be compared voxel-by-voxel, e.g. when overlaying a CBF image over a structural image, or when wanting to use a mask from a different space. When after running this function, the reference and source images are not in alignment, they need to be registered first (i.e. xASL_spm_register). Resampling/reslicing needs an interpolation method to know from which voxels of the source image, a voxel in the new image will be computed. A simplistic explanation is that this determines the number of surrounding neighborhood voxels it uses to determine the new voxel value. The example syntax below would reslice/resample the CBF image to the T1w space (assuming the Affine was done to register CBF to T1w) It also works with the external .mat file of the source file that has the same name as the source file. It also can optionally take a _sn.mat containing the affine transformation information.","title":"xASL_spm_reslice.m"},{"location":"SPMxASL/#xasl_spm_smoothm","text":"Format: xASL_spm_smooth(pathIn, fwhmSmooth, pathNew]) Description: This SPM wrapper runs SPM's smooth function, which spatially smooths the input image with a Gaussian kernel. In the case of multiple volumes (i.e. a 4D NIfTI), each 3D volume is spatially smoothed separately. Note that smoothnesses combine with Pythagoras' rule (i.e. sum quadratically)","title":"xASL_spm_smooth.m"},{"location":"SPMxASL/#xasl_stat_meannanm","text":"Format: y = xASL_stat_MeanNan(x[,dim]) Description: It calculates the sum using the SUM functions and divides by the number of values but ignoring NaNs.","title":"xASL_stat_MeanNan.m"},{"location":"SPMxASL/#xasl_stat_mediannanm","text":"Format: y = xASL_stat_MedianNan(x[,dim]) Description: It calculates the MEDIAN along the given dimension, but it sets all the NaNs to zero before calling it.","title":"xASL_stat_MedianNan.m"},{"location":"SPMxASL/#xasl_tsvreadm","text":"Format: [CellContents] = xASL_tsvRead(PathTSV[, bStruct]) Description: This function loads a tab-separated value (TSV) file - which is the format that BIDS prefers - and outputs it to a cell array.","title":"xASL_tsvRead.m"},{"location":"SPMxASL/#xasl_tsvwritem","text":"Format: xASL_tsvWrite(InputCell, PathTSV[, bOverwrite, bCSV]) Description: This function loads a cell array and prints it to a tab-separated value (TSV) file, which is the format that BIDS prefers.","title":"xASL_tsvWrite.m"},{"location":"SPMxASL/#xasl_wrp_dartelsaveintermedtransm","text":"Format: xASL_wrp_DARTELSaveIntermedTrans(Yy, u, odim, rdim, idim, Mar, mat, M0, M1, nameOut, numIteration) Description: This function is called from the CAT12 segmentation function to save the intermediate results of the DARTEL transformation. Normally, the registration only saves the final results - the final transformation field. This function enables to save also the intermediate transformation field. It takes all the internal variables from the transformation and save the field to a sub-directory 'mri' that normally contains all the intermediate results of the CAT12 segmentation. It adds a 'y_' prefix and adds the specified iteration number as postfix.","title":"xASL_wrp_DARTELSaveIntermedTrans.m"},{"location":"SPMxASL/#xasl_wrp_gssaveintermedtransm","text":"Format: xASL_wrp_GSSaveIntermedTrans(y, idim, odim, rdim, M0, M1, R, M1t, M1r, nameOut, numIteration) Description: This function is called from the CAT12 segmentation function to save the intermediate results of the Geodesic shooting transformation. Normally, the registration only saves the final results - the final transformation field. This function enables to save also the intermediate transformation field. It takes all the internal variables from the transformation and save the field to a sub-directory 'mri' that normally contains all the intermediate results of the CAT12 segmentation. It adds a 'y_' prefix and adds the specified iteration number as postfix.","title":"xASL_wrp_GSSaveIntermedTrans.m"},{"location":"Structural_Module/","text":"Submodules of the Structural Module xASL_wrp_CleanUpWMH_SEGM.m Format: xASL_wrp_CleanUpWMH_SEGM(x) Description: This submodule aims to clean up WMH under- or oversegmentations in a conservatively & robust way, i.e. erring on the side of caution. It uses input from the tissue class segmentation (e.g. CAT12) to repair the WMH segmentation (e.g. LST LPA/LGA or externally provided). Note that before running the tissue segmentation, the T1w was (conservatively) filled for WMH lesions. % This function is not tested a lot, so mainly conservatively set up to improve the WMH volumetrics, rather than improve the registration. This submodule contains the following steps: Administration Correct pGM islands inside pWM WMH can have an intensity similar to GM on the T1w, which erroneously classifies them as GM instead of WM(H). The rule used here, is to define GM islands within the WM as clusters of pGM>0.05 for which 3 layers (dilations) have at least 95% pWM. For these islands, pGM is given 100% to pWM. 50% of pWM is given to pWMH (the pWMH/pNAWM distinction is made later in the pipeline, here still pWM=pWMH+pNAWM). The reason is that not all low T1w intensities within the WM are WMH, we still expect some lacunes, perivascular (Virchow-Robin) spaces, which could be considered pNAWM rather than pWMH. Perform brainmasking & join masks Correct any WMH inside GM or CSF -> here we assume that CAT12 did a good segmentation job. If pGM is larger than pWM & larger than pWMH, we consider a voxel to be pGM and remove the pWMH. This effectively removes pWMH segmentation noise in the GM or CSF, it doesn't correct any significant misclassification of WMH in the GM or CSF. If the WMH segmentation does a significant misclassification (e.g. setting the pWMH inside GM or CSF to a probability higher than GM or CSF is by tissue segmentation), this is lesion filled after the WMH segmentation, on the T1w, hence the tissue segmentation won't have a chance to correct this. Fortunately, most oversegmentations in the GM/CSF have low pWMH, as WMH segmentation algorithms already perform a light tissue prior-based clean up themselves. Saving & file management Prepare visuals for visual QC & file management xASL_wrp_FLAIR_BiasfieldCorrection.m Format: xASL_wrp_FLAIR_BiasfieldCorrection(x) Description: This submodule performs a biasfield correction on T1w and applies it on FLAIR. This can be useful, when there are large lesions on the FLAIR that hamper capturing the biasfield nicely on the FLAIR itself. In such cases, the biasfield of the T1w might be easier to obtain and should be the same as the FLAIR, provided they are scanned in the same scan session (i.e.g same scanner, same coil). BE CAREFUL: this submodule assumes that the biasfields of the T1w and FLAIR are comparable, which is not the case when one of the two (or both) are already biasfield corrected. xASL_wrp_GetVolumetrics.m Format: xASL_wrp_GetVolumetrics(x) Description: This submodule computes the total volume for each of the tissue classes & stores them in a TSV file (per BIDS). This is computed from the native space segmentation derivatives (GM, WM & CSF), from which the ICV & relative volumes can be calculated. This is performed for CAT12 or SPM12 (whichever was used), and optionally for a WMH_SEGM. xASL_wrp_LST_Segment_FLAIR_WMH.m Format: xASL_wrp_LST_Segment_FLAIR_WMH(x, rWMHPath[, WMHsegmAlg]) Description: This submodule runs the LST WMH segmentation, either with LGA or LPA. LPA is the default choice, it outperforms LGA a bit, depending on the image quality. These algorithms perform optimally with 3T images, with good contrast. Generally, LPA oversegments whereas LGA undersegments. The LPA oversegmentation is corrected in a later submodule. If a WMH_SEGM already existed, the LST is run quickly as dummy only, to be replaced by the original WMH_SEGM image. This function has the following parts: Resample FLAIR (& WMH_SEGM, if exists) to T1w space where we assume WMH_SEGM_ORI == FLAIR space (if externally provided) WMH_SEGM == T1w space Define parameters for segmentation Run the segmentation Replace by already existing WMH_SEGM File management Remove NaNs from segmentations & fix image edges Remove lesion masks from WMH_SEGM xASL_wrp_LST_T1w_LesionFilling_WMH.m Format: xASL_wrp_LST_T1w_LesionFilling_WMH(x) Description: This submodule runs the LST WMH-based T1w lesion filling, which should improve the registration & segmentation of the T1w by e.g. CAT12/SPM12. The WMH can be either segmented in the previous submodule by LST LGA/LPGA or provided externally. Before lesion filling, we clean up the WMH segmentation, to make the lesion filling a bit more conservative. Sometimes the WMH segmentation oversegments inside the GM (as there can be hyperintensities on the FLAIR) & we don't want to lesion-fill these on the T1w (which would turn their intensities in intensities similar to WM, leading to misclassifications by the T1w segmentation). Note that this is submodule only performs the lesion filling, and the clean up is also performed for the lesion filling only. A more thorough WMH clean up (for e.g. WMH volumetrics) is performed later in the Structural module, using also the results from the T1w segmentation. Note when changing the lesion filling here, LST lesion filling expects a probability map, doesnt work nicely with binary mask This function runs the following steps: File management Clean up the WMH segmentation used for lesion filling Run lesion filling Correction of too much/erronous lesion filling File management xASL_wrp_LinearReg_FLAIR2T1w.m Format: xASL_wrp_LinearReg_FLAIR2T1w(x[, bAutoACPC]) Description: This submodule registers FLAIR linearly to the T1w The same transformation is applied to all other related scans (FLAIR-segmented lesions, WMH specifically or other lesions) This is required to enable the application of T1w derivatives (e.g. transformations to standard space, tissue segmentation) for FLAIR and vice versa (e.g. WMH lesion-filling). xASL_wrp_LinearReg_T1w2MNI.m Format: xASL_wrp_LinearReg_T1w2MNI(x[, bAutoACPC]) Description: This submodule registers T1w linearly to the center of MNI space, a.k.a. ACPC alignment The same transformation is applied to all other related scans (ASL4D, M0, FLAIR, etc.) This facilitates MNI-based algorithms (e.g. SPM-based segmentation), and allows for visual QC with all images roughly in the same space. This submodule first clips high values that can bias the registration algorithm, then performs a center of mass-based ACPC alignment, and then several iterations of SPM coregistration. Assuming that this submodule is run at the start of ExploreASL, all NIfTI orientation matrices are restored before running the registration. xASL_wrp_Resample2StandardSpace.m Format: xASL_wrp_Resample2StandardSpace(x) Description: This submodule resamples all structural images & their derivatives to standard space. It uses the transformation fields that were obtained previously in the Structural module, concatenates all transformations into a single transformation (if not already done) & applies the transformation with a single interpolation (either trilinear for low quality or probability maps, or 2nd order B-spline). Finally, it computes the Jacobian determinants (i.e. the derivative of the transformation field) to obtain a map of the volumetric effects of the transformation. This Jacobian map is multiplied with the standard space resampled images, to restore their (local & global) total volume. The sum of volumes in native & standard space are compared as QC. This submodule is not only part of the structural module, but can be repeated when the transformation map is edited, e.g. after longitudinal registration or after creation of a group-wise template. xASL_wrp_SegmentT1w.m Format: [x] = xASL_wrp_SegmentT1w(x, bSegmentSPM12) Description: This submodule segments high resolution structural/anatomical scans into GM/WM/CSF/soft tissue/bone/air tissue classes. It will save GM/WM/CSF in native space, and the transformation from native to standard space. This transformation includes Geodesic Shooting/DARTEL for CAT12. This submodule contains the following steps: Administration Extra segmentation options by Jan Petr Segmentation using CAT12 -> If CAT12 fails, it will be repeated with higher contrast, higher strength affine preprocessing & less biasfield regularization -> If CAT12 fails twice, it will be skipped & SPM12 will be run Segmentation using SPM12 File management CAT12 File management lesions Resample lesions to standard space -> for the lesion masking. MORE EXPLANATION NEEDED BY JAN Manage flowfields -> smooth combination non-linear flowfield outside the lesion & uniform flowfield within the lesion File management xASL_wrp_VisualQC_Structural.m Format: xASL_wrp_VisualQC_Structural(x) Description: This submodule performs several visualizations for visual & quantitative QC. After initial admin It starts with the SPM UP parameters (courtesy of Cyril Pernet, his SPM UP scripts were made more robust & accurate by Jan & Henk, & are implemented here for T1w (& optionally FLAIR). Then it performs a collection of visualizations Also repeated specifically for lesions & manually provided ROIs Finally, this contains a report of all missing raw & derivative files, in native & standard space, printing the NIfTI orientation matrix content before (hdr.mat0) & after registrations (hdr.mat) The determinant of these matrices should be the same, otherwise LeftRight has flipped. This should also be the same across a group scanned at the same scanner Then various other QC functions are called & all are summarized in a PDF report.","title":"Module Structural"},{"location":"Structural_Module/#submodules-of-the-structural-module","text":"","title":"Submodules of the Structural Module"},{"location":"Structural_Module/#xasl_wrp_cleanupwmh_segmm","text":"Format: xASL_wrp_CleanUpWMH_SEGM(x) Description: This submodule aims to clean up WMH under- or oversegmentations in a conservatively & robust way, i.e. erring on the side of caution. It uses input from the tissue class segmentation (e.g. CAT12) to repair the WMH segmentation (e.g. LST LPA/LGA or externally provided). Note that before running the tissue segmentation, the T1w was (conservatively) filled for WMH lesions. % This function is not tested a lot, so mainly conservatively set up to improve the WMH volumetrics, rather than improve the registration. This submodule contains the following steps: Administration Correct pGM islands inside pWM WMH can have an intensity similar to GM on the T1w, which erroneously classifies them as GM instead of WM(H). The rule used here, is to define GM islands within the WM as clusters of pGM>0.05 for which 3 layers (dilations) have at least 95% pWM. For these islands, pGM is given 100% to pWM. 50% of pWM is given to pWMH (the pWMH/pNAWM distinction is made later in the pipeline, here still pWM=pWMH+pNAWM). The reason is that not all low T1w intensities within the WM are WMH, we still expect some lacunes, perivascular (Virchow-Robin) spaces, which could be considered pNAWM rather than pWMH. Perform brainmasking & join masks Correct any WMH inside GM or CSF -> here we assume that CAT12 did a good segmentation job. If pGM is larger than pWM & larger than pWMH, we consider a voxel to be pGM and remove the pWMH. This effectively removes pWMH segmentation noise in the GM or CSF, it doesn't correct any significant misclassification of WMH in the GM or CSF. If the WMH segmentation does a significant misclassification (e.g. setting the pWMH inside GM or CSF to a probability higher than GM or CSF is by tissue segmentation), this is lesion filled after the WMH segmentation, on the T1w, hence the tissue segmentation won't have a chance to correct this. Fortunately, most oversegmentations in the GM/CSF have low pWMH, as WMH segmentation algorithms already perform a light tissue prior-based clean up themselves. Saving & file management Prepare visuals for visual QC & file management","title":"xASL_wrp_CleanUpWMH_SEGM.m"},{"location":"Structural_Module/#xasl_wrp_flair_biasfieldcorrectionm","text":"Format: xASL_wrp_FLAIR_BiasfieldCorrection(x) Description: This submodule performs a biasfield correction on T1w and applies it on FLAIR. This can be useful, when there are large lesions on the FLAIR that hamper capturing the biasfield nicely on the FLAIR itself. In such cases, the biasfield of the T1w might be easier to obtain and should be the same as the FLAIR, provided they are scanned in the same scan session (i.e.g same scanner, same coil). BE CAREFUL: this submodule assumes that the biasfields of the T1w and FLAIR are comparable, which is not the case when one of the two (or both) are already biasfield corrected.","title":"xASL_wrp_FLAIR_BiasfieldCorrection.m"},{"location":"Structural_Module/#xasl_wrp_getvolumetricsm","text":"Format: xASL_wrp_GetVolumetrics(x) Description: This submodule computes the total volume for each of the tissue classes & stores them in a TSV file (per BIDS). This is computed from the native space segmentation derivatives (GM, WM & CSF), from which the ICV & relative volumes can be calculated. This is performed for CAT12 or SPM12 (whichever was used), and optionally for a WMH_SEGM.","title":"xASL_wrp_GetVolumetrics.m"},{"location":"Structural_Module/#xasl_wrp_lst_segment_flair_wmhm","text":"Format: xASL_wrp_LST_Segment_FLAIR_WMH(x, rWMHPath[, WMHsegmAlg]) Description: This submodule runs the LST WMH segmentation, either with LGA or LPA. LPA is the default choice, it outperforms LGA a bit, depending on the image quality. These algorithms perform optimally with 3T images, with good contrast. Generally, LPA oversegments whereas LGA undersegments. The LPA oversegmentation is corrected in a later submodule. If a WMH_SEGM already existed, the LST is run quickly as dummy only, to be replaced by the original WMH_SEGM image. This function has the following parts: Resample FLAIR (& WMH_SEGM, if exists) to T1w space where we assume WMH_SEGM_ORI == FLAIR space (if externally provided) WMH_SEGM == T1w space Define parameters for segmentation Run the segmentation Replace by already existing WMH_SEGM File management Remove NaNs from segmentations & fix image edges Remove lesion masks from WMH_SEGM","title":"xASL_wrp_LST_Segment_FLAIR_WMH.m"},{"location":"Structural_Module/#xasl_wrp_lst_t1w_lesionfilling_wmhm","text":"Format: xASL_wrp_LST_T1w_LesionFilling_WMH(x) Description: This submodule runs the LST WMH-based T1w lesion filling, which should improve the registration & segmentation of the T1w by e.g. CAT12/SPM12. The WMH can be either segmented in the previous submodule by LST LGA/LPGA or provided externally. Before lesion filling, we clean up the WMH segmentation, to make the lesion filling a bit more conservative. Sometimes the WMH segmentation oversegments inside the GM (as there can be hyperintensities on the FLAIR) & we don't want to lesion-fill these on the T1w (which would turn their intensities in intensities similar to WM, leading to misclassifications by the T1w segmentation). Note that this is submodule only performs the lesion filling, and the clean up is also performed for the lesion filling only. A more thorough WMH clean up (for e.g. WMH volumetrics) is performed later in the Structural module, using also the results from the T1w segmentation. Note when changing the lesion filling here, LST lesion filling expects a probability map, doesnt work nicely with binary mask This function runs the following steps: File management Clean up the WMH segmentation used for lesion filling Run lesion filling Correction of too much/erronous lesion filling File management","title":"xASL_wrp_LST_T1w_LesionFilling_WMH.m"},{"location":"Structural_Module/#xasl_wrp_linearreg_flair2t1wm","text":"Format: xASL_wrp_LinearReg_FLAIR2T1w(x[, bAutoACPC]) Description: This submodule registers FLAIR linearly to the T1w The same transformation is applied to all other related scans (FLAIR-segmented lesions, WMH specifically or other lesions) This is required to enable the application of T1w derivatives (e.g. transformations to standard space, tissue segmentation) for FLAIR and vice versa (e.g. WMH lesion-filling).","title":"xASL_wrp_LinearReg_FLAIR2T1w.m"},{"location":"Structural_Module/#xasl_wrp_linearreg_t1w2mnim","text":"Format: xASL_wrp_LinearReg_T1w2MNI(x[, bAutoACPC]) Description: This submodule registers T1w linearly to the center of MNI space, a.k.a. ACPC alignment The same transformation is applied to all other related scans (ASL4D, M0, FLAIR, etc.) This facilitates MNI-based algorithms (e.g. SPM-based segmentation), and allows for visual QC with all images roughly in the same space. This submodule first clips high values that can bias the registration algorithm, then performs a center of mass-based ACPC alignment, and then several iterations of SPM coregistration. Assuming that this submodule is run at the start of ExploreASL, all NIfTI orientation matrices are restored before running the registration.","title":"xASL_wrp_LinearReg_T1w2MNI.m"},{"location":"Structural_Module/#xasl_wrp_resample2standardspacem","text":"Format: xASL_wrp_Resample2StandardSpace(x) Description: This submodule resamples all structural images & their derivatives to standard space. It uses the transformation fields that were obtained previously in the Structural module, concatenates all transformations into a single transformation (if not already done) & applies the transformation with a single interpolation (either trilinear for low quality or probability maps, or 2nd order B-spline). Finally, it computes the Jacobian determinants (i.e. the derivative of the transformation field) to obtain a map of the volumetric effects of the transformation. This Jacobian map is multiplied with the standard space resampled images, to restore their (local & global) total volume. The sum of volumes in native & standard space are compared as QC. This submodule is not only part of the structural module, but can be repeated when the transformation map is edited, e.g. after longitudinal registration or after creation of a group-wise template.","title":"xASL_wrp_Resample2StandardSpace.m"},{"location":"Structural_Module/#xasl_wrp_segmentt1wm","text":"Format: [x] = xASL_wrp_SegmentT1w(x, bSegmentSPM12) Description: This submodule segments high resolution structural/anatomical scans into GM/WM/CSF/soft tissue/bone/air tissue classes. It will save GM/WM/CSF in native space, and the transformation from native to standard space. This transformation includes Geodesic Shooting/DARTEL for CAT12. This submodule contains the following steps: Administration Extra segmentation options by Jan Petr Segmentation using CAT12 -> If CAT12 fails, it will be repeated with higher contrast, higher strength affine preprocessing & less biasfield regularization -> If CAT12 fails twice, it will be skipped & SPM12 will be run Segmentation using SPM12 File management CAT12 File management lesions Resample lesions to standard space -> for the lesion masking. MORE EXPLANATION NEEDED BY JAN Manage flowfields -> smooth combination non-linear flowfield outside the lesion & uniform flowfield within the lesion File management","title":"xASL_wrp_SegmentT1w.m"},{"location":"Structural_Module/#xasl_wrp_visualqc_structuralm","text":"Format: xASL_wrp_VisualQC_Structural(x) Description: This submodule performs several visualizations for visual & quantitative QC. After initial admin It starts with the SPM UP parameters (courtesy of Cyril Pernet, his SPM UP scripts were made more robust & accurate by Jan & Henk, & are implemented here for T1w (& optionally FLAIR). Then it performs a collection of visualizations Also repeated specifically for lesions & manually provided ROIs Finally, this contains a report of all missing raw & derivative files, in native & standard space, printing the NIfTI orientation matrix content before (hdr.mat0) & after registrations (hdr.mat) The determinant of these matrices should be the same, otherwise LeftRight has flipped. This should also be the same across a group scanned at the same scanner Then various other QC functions are called & all are summarized in a PDF report.","title":"xASL_wrp_VisualQC_Structural.m"},{"location":"Tutorials-ASL-BIDS/","text":"Tutorials (ASL-BIDS) ExploreASL & ASL-BIDS Starting with version v1.7.0 , ExploreASL will support an import workflow which allows the user to convert DICOM and NIFTI data to the ASL-BIDS format. Since ExploreASL does not fully utilize the BIDS format internally, there will also be an automated workflow to convert from ASL-BIDS to the ExploreASL legacy format . In the following subsections we will explain how you can use the automated ExploreASL import workflow to convert your data structure to ASL-BIDS and how you can process it. The ExploreASL_Master script will have the following format: [x] = ExploreASL([DatasetRoot, ImportModules, ProcessModules, bPause, iWorker, nWorkers]) Parameter descriptions: DatasetRoot : Path to the BIDS dataset root directory ( OPTIONAL ) DatasetRoot Type CHAR ARRAY Default Prompting user input ImportModules : Multi-step import workflow ( OPTIONAL ) DCM2NII : Run the DICOM to NIFTI conversion NII2BIDS : Run the NIFTI to BIDS conversion DEFACE : Run the defacing of structural scans BIDS2LEGACY : Run the BIDS to LEGACY conversion ImportModules DCM2NII NII2BIDS DEFACE BIDS2LEGACY Type BOOLEAN BOOLEAN BOOLEAN BOOLEAN Default false false false false ProcessModules : Multi-step processing pipeline ( OPTIONAL ) STRUCTURAL : Run the Structural Module ASL : Run the ASL Module POPULATION : Run the Population Module ProcessModules STRUCTURAL ASL POPULATION Type BOOLEAN BOOLEAN BOOLEAN Default false false false bPause : Pause workflow before ExploreASL pipeline ( OPTIONAL ) bPause Type BOOLEAN Default false iWorker : Allows parallelization when called externally ( OPTIONAL ) iWorker Type INTEGER Default 1 nWorkers : Allows parallelization when called externally ( OPTIONAL ) nWorkers Type INTEGER Default 1 In the following examples, we want to show how you can use the revised import workflow and how the conventional processing is done now. DICOM source data Converting DICOM source data according to the ASL BIDS standard can be done using the new import workflow. For the upcoming release v1.7.0 we're preparing an exemplary DICOM source dataset based on the ASL DRO . To run this workflow, you have to use the path to your dataset root directory . This dataset root directory should contain a sourceStructure.json file, a studyPar.json file and optionally also a dataPar.json file. Do not forget to set up the source dataset correctly. We're working on a flavor library, to enable the import and processing of a wide variety of different sequence, vendor, and scanner combinations. The first step to convert your DICOM source data to NIFTI source data is to run the following command: [x] = ExploreASL('drive/.../datasetRoot', [1 0 0 0], 0, 0, 1, 1); Here we tell ExploreASL to run the DCM2NII import module by setting the first boolean variable of the ImportModules to 1 . NIFTI source data Let's assume we have intermediate NIFTI data now. To convert this intermediate data to ASL-BIDS raw data, we have to run the second part of the import workflow. To run the second step, we set the second variable of the ImportModules to 1 . Similar to the previous step, we pass the DatasetRoot directory to ExploreASL . [x] = ExploreASL('drive/.../datasetRoot', [0 1 0 0], 0, 0, 1, 1); Data defacing There's also a new option to deface your structural scans. To do this, you can run the third step of the import workflow. This is done by setting the third variable of the ImportModules to 1 . Similar to the previous steps, we pass the DatasetRoot directory to ExploreASL . [x] = ExploreASL('drive/.../datasetRoot', [0 0 1 0], 0, 0, 1, 1); Data in ExploreASL legacy format Right now, ExploreASL still uses the conventional data structure. To convert our ASL-BIDS rawdata to the ExploreASL legacy format, we run the last step of the import workflow. This is done by setting the fourth variable of the ImportModules to 1 . Like in the steps before, we pass the DatasetRoot directory to ExploreASL . [x] = ExploreASL('drive/.../datasetRoot', [0 0 0 1], 0, 0, 1, 1); The import workflow will also generate a dataPar.json file. To adapt your pipeline, you can still use the same settings as before, by changing the JSON fields. ExploreASL processing pipeline If you just want to use the conventional ExploreASL processing pipeline, you can simply turn off the import workflow by setting all ImportModules variables to 0 individually or by using a single 0 for the ImportModules . This results in the following notation: [x] = ExploreASL('drive/.../datasetRoot', 0, 1, 0, 1, 1); To run individual modules, you can set the ProcessModules individually. If you only want to the Structural Module for example, you can use a [1 0 0] vector. To run all modules, you can use a single 1 or a vector of ones, which should look like this [1 1 1] . Running the full processing pipeline can therefore be done like this as well: [x] = ExploreASL('drive/.../datasetRoot', 0, [1 1 1], 0, 1, 1); Full pipeline Running the full pipeline including both import workflow and processing pipeline, can be done by setting both ImportModules and ProcessModules to 1 . [x] = ExploreASL('drive/.../datasetRoot', 1, 1, 0, 1, 1); Other tips and tricks Note that we changed both name and behavior of the SkipPause variable. The variable is called bPause now. Setting it to true or 1 , will result in the pipeline being paused before the processing. We removed the iModules , but the functionality of ProcessModules is basically the same. We use boolean notation now, so instead of [1 2 3] you have to use [1 1 1] now. The overall import functionality is a work in progress right now. We expect stable behavior in release v1.7.0 though. If you plan on using the develop branch until then, you have to live with more or less unstable import behavior. Some of the examples shown on the following pages were written for versions v1.5.1 and older. They will be updated soon. If you want to work with the current develop version, these examples obviously do not apply anymore.","title":"Tutorials (ASL-BIDS)"},{"location":"Tutorials-ASL-BIDS/#tutorials-asl-bids","text":"","title":"Tutorials (ASL-BIDS)"},{"location":"Tutorials-ASL-BIDS/#exploreasl-asl-bids","text":"Starting with version v1.7.0 , ExploreASL will support an import workflow which allows the user to convert DICOM and NIFTI data to the ASL-BIDS format. Since ExploreASL does not fully utilize the BIDS format internally, there will also be an automated workflow to convert from ASL-BIDS to the ExploreASL legacy format . In the following subsections we will explain how you can use the automated ExploreASL import workflow to convert your data structure to ASL-BIDS and how you can process it. The ExploreASL_Master script will have the following format: [x] = ExploreASL([DatasetRoot, ImportModules, ProcessModules, bPause, iWorker, nWorkers]) Parameter descriptions: DatasetRoot : Path to the BIDS dataset root directory ( OPTIONAL ) DatasetRoot Type CHAR ARRAY Default Prompting user input ImportModules : Multi-step import workflow ( OPTIONAL ) DCM2NII : Run the DICOM to NIFTI conversion NII2BIDS : Run the NIFTI to BIDS conversion DEFACE : Run the defacing of structural scans BIDS2LEGACY : Run the BIDS to LEGACY conversion ImportModules DCM2NII NII2BIDS DEFACE BIDS2LEGACY Type BOOLEAN BOOLEAN BOOLEAN BOOLEAN Default false false false false ProcessModules : Multi-step processing pipeline ( OPTIONAL ) STRUCTURAL : Run the Structural Module ASL : Run the ASL Module POPULATION : Run the Population Module ProcessModules STRUCTURAL ASL POPULATION Type BOOLEAN BOOLEAN BOOLEAN Default false false false bPause : Pause workflow before ExploreASL pipeline ( OPTIONAL ) bPause Type BOOLEAN Default false iWorker : Allows parallelization when called externally ( OPTIONAL ) iWorker Type INTEGER Default 1 nWorkers : Allows parallelization when called externally ( OPTIONAL ) nWorkers Type INTEGER Default 1 In the following examples, we want to show how you can use the revised import workflow and how the conventional processing is done now.","title":"ExploreASL &amp; ASL-BIDS"},{"location":"Tutorials-ASL-BIDS/#dicom-source-data","text":"Converting DICOM source data according to the ASL BIDS standard can be done using the new import workflow. For the upcoming release v1.7.0 we're preparing an exemplary DICOM source dataset based on the ASL DRO . To run this workflow, you have to use the path to your dataset root directory . This dataset root directory should contain a sourceStructure.json file, a studyPar.json file and optionally also a dataPar.json file. Do not forget to set up the source dataset correctly. We're working on a flavor library, to enable the import and processing of a wide variety of different sequence, vendor, and scanner combinations. The first step to convert your DICOM source data to NIFTI source data is to run the following command: [x] = ExploreASL('drive/.../datasetRoot', [1 0 0 0], 0, 0, 1, 1); Here we tell ExploreASL to run the DCM2NII import module by setting the first boolean variable of the ImportModules to 1 .","title":"DICOM source data"},{"location":"Tutorials-ASL-BIDS/#nifti-source-data","text":"Let's assume we have intermediate NIFTI data now. To convert this intermediate data to ASL-BIDS raw data, we have to run the second part of the import workflow. To run the second step, we set the second variable of the ImportModules to 1 . Similar to the previous step, we pass the DatasetRoot directory to ExploreASL . [x] = ExploreASL('drive/.../datasetRoot', [0 1 0 0], 0, 0, 1, 1);","title":"NIFTI source data"},{"location":"Tutorials-ASL-BIDS/#data-defacing","text":"There's also a new option to deface your structural scans. To do this, you can run the third step of the import workflow. This is done by setting the third variable of the ImportModules to 1 . Similar to the previous steps, we pass the DatasetRoot directory to ExploreASL . [x] = ExploreASL('drive/.../datasetRoot', [0 0 1 0], 0, 0, 1, 1);","title":"Data defacing"},{"location":"Tutorials-ASL-BIDS/#data-in-exploreasl-legacy-format","text":"Right now, ExploreASL still uses the conventional data structure. To convert our ASL-BIDS rawdata to the ExploreASL legacy format, we run the last step of the import workflow. This is done by setting the fourth variable of the ImportModules to 1 . Like in the steps before, we pass the DatasetRoot directory to ExploreASL . [x] = ExploreASL('drive/.../datasetRoot', [0 0 0 1], 0, 0, 1, 1); The import workflow will also generate a dataPar.json file. To adapt your pipeline, you can still use the same settings as before, by changing the JSON fields.","title":"Data in ExploreASL legacy format"},{"location":"Tutorials-ASL-BIDS/#exploreasl-processing-pipeline","text":"If you just want to use the conventional ExploreASL processing pipeline, you can simply turn off the import workflow by setting all ImportModules variables to 0 individually or by using a single 0 for the ImportModules . This results in the following notation: [x] = ExploreASL('drive/.../datasetRoot', 0, 1, 0, 1, 1); To run individual modules, you can set the ProcessModules individually. If you only want to the Structural Module for example, you can use a [1 0 0] vector. To run all modules, you can use a single 1 or a vector of ones, which should look like this [1 1 1] . Running the full processing pipeline can therefore be done like this as well: [x] = ExploreASL('drive/.../datasetRoot', 0, [1 1 1], 0, 1, 1);","title":"ExploreASL processing pipeline"},{"location":"Tutorials-ASL-BIDS/#full-pipeline","text":"Running the full pipeline including both import workflow and processing pipeline, can be done by setting both ImportModules and ProcessModules to 1 . [x] = ExploreASL('drive/.../datasetRoot', 1, 1, 0, 1, 1);","title":"Full pipeline"},{"location":"Tutorials-ASL-BIDS/#other-tips-and-tricks","text":"Note that we changed both name and behavior of the SkipPause variable. The variable is called bPause now. Setting it to true or 1 , will result in the pipeline being paused before the processing. We removed the iModules , but the functionality of ProcessModules is basically the same. We use boolean notation now, so instead of [1 2 3] you have to use [1 1 1] now. The overall import functionality is a work in progress right now. We expect stable behavior in release v1.7.0 though. If you plan on using the develop branch until then, you have to live with more or less unstable import behavior. Some of the examples shown on the following pages were written for versions v1.5.1 and older. They will be updated soon. If you want to work with the current develop version, these examples obviously do not apply anymore.","title":"Other tips and tricks"},{"location":"Tutorials-Advanced/","text":"Tutorials (Advanced) Basic Image Processing Basic NIFTI Input & Output Let's assume you want to read in a NIFTI image and apply a mask on it. As a good first step we always recommend to initialize ExploreASL first by running the following command. [x] = ExploreASL_Initialize; Now let's read in the image by defining the image path and using the xASL_io_Nifti2Im function. pathNIFTI = fullfile(x.MyPath,'External','TestDataSet','analysis','Sub-001','T1.nii'); image = xASL_io_Nifti2Im(pathNIFTI); Maybe we want to mask the image. The image and the mask do not have the same resolution though, which means we need to resample either the mask or the image. The following commands will resample the mask to the image size. pathMask = fullfile(x.MyPath,'External','SPMmodified','MapsAdded','brainmask.nii'); mask = xASL_io_Nifti2Im(pathMask); maskResampled = xASL_im_ResampleLinearFair(mask, size(image)); To mask the image we multiply the image matrix with the mask matrix. This way all voxels outside of the mask are set to 0. image = image.*maskResampled; Then we can save the image as a NIFTI again and open it with our favorite NIFTI viewer. xASL_io_CreateNifti(fullfile(x.MyPath,'export.nii'), image); xASL_io_Nifti2Im does unzip your image, so make sure to revert those changes within the ExploreASL directory later using git reset or git revert . Basic File Operations Matlab offers two functions to copy or move files and folders from a source to a destination within your file system. These functions are copyfile and movefile . To improve speed and multi OS compatibility, we wrote two similar functions, called xASL_Copy and xASL_Move . In the following example we copy a file called fileA from the folder C:\\Users\\Test_One to C:\\Users\\Test_Two . We then move the file back to C:\\Users\\Test_One and overwrite the original fileA . Finally, we rename fileA to fileB . % Copy fileA from Test_One to Test_Two xASL_Copy('C:\\Users\\Test_One\\fileA.txt', 'C:\\Users\\Test_Two\\fileA.txt'); % Move fileA back to Test_One and overwrite the original fileA xASL_Move('C:\\Users\\Test_Two\\fileA.txt', 'C:\\Users\\Test_One\\fileA.txt', 1); % Rename fileA to fileB xASL_Move('C:\\Users\\Test_One\\fileA.txt', 'C:\\Users\\Test_One\\fileB.txt', 1); Often we need to find a list of files in a certain directory. To do this, we can use xASL_adm_GetFileList . Let's assume there are five files called fileA , fileB , fileC , fileD and fileE in C:\\Users\\Test_One . We know that all names start with file , so we can use this for our regular expression. Check out the example below on how you can get a cell array containing the paths of all these files. strDirectory = 'C:\\Users\\Test_One'; strRegEx = '^file.+$'; filepaths = xASL_adm_GetFileList(strDirectory, strRegEx); Atlas Options The atlases of the ExploreASL population module can be defined in the x.S sub-structure. If you are interested in the TotalGM , TotalWM , DeepWM , Hammers , HOcort_CONN , HOsub_CONN , and Mindboggle_OASIS_DKT31_CMA atlases e.g., you can add the following lines to your dataPar.json file. { \"x\": [{ \"name\": \"Example\", \"subject_regexp\": \"Example\", \"S\": {\"Atlases\": [\"TotalGM\",\"TotalWM\",\"DeepWM\",\"Hammers\",\"HOcort_CONN\",\"HOsub_CONN\",\"Mindboggle_OASIS_DKT31_CMA\"]} }] } Available atlases are: Free atlases: TotalGM : Mask of the entire GM TotalWM : Mask of the entire WM DeepWM : Mask of the deep WM WholeBrain : Mask of the entire brain MNI_Structural : MNI cortical atlas Tatu_ACA_MCA_PCA : Original vascular territories by Tatu et al. Tatu_ICA_PCA : Tatu (only ICA and PCA) Tatu_ICA_L_ICA_R_PCA : Tatu (L ICA and R PCA) Tatu_ACA_MCA_PCA_Prox_Med_Dist : Tatu separated to distal/medial/proximal of ACA/MCA/PCA Mindboggle_OASIS_DKT31_CMA : Mindboggle-101 cortical atlas Free for non-commercial use only: HOcort_CONN : Harvard-Oxford cortical atlas HOsub_CONN : Harvard-Oxford subcortical atlas Hammers : Alexander Hammers's brain atlas HammersCAT12 : Hammers atlas adapted to DARTEL template of IXI550 space Thalamus : Harvad-Oxford thalamus atlas In a future ExploreASL version we want to add a custom atlases directory, where you can add your own atlas & metadata file including a description of how to do this.","title":"Tutorials (Advanced)"},{"location":"Tutorials-Advanced/#tutorials-advanced","text":"","title":"Tutorials (Advanced)"},{"location":"Tutorials-Advanced/#basic-image-processing","text":"","title":"Basic Image Processing"},{"location":"Tutorials-Advanced/#basic-nifti-input-output","text":"Let's assume you want to read in a NIFTI image and apply a mask on it. As a good first step we always recommend to initialize ExploreASL first by running the following command. [x] = ExploreASL_Initialize; Now let's read in the image by defining the image path and using the xASL_io_Nifti2Im function. pathNIFTI = fullfile(x.MyPath,'External','TestDataSet','analysis','Sub-001','T1.nii'); image = xASL_io_Nifti2Im(pathNIFTI); Maybe we want to mask the image. The image and the mask do not have the same resolution though, which means we need to resample either the mask or the image. The following commands will resample the mask to the image size. pathMask = fullfile(x.MyPath,'External','SPMmodified','MapsAdded','brainmask.nii'); mask = xASL_io_Nifti2Im(pathMask); maskResampled = xASL_im_ResampleLinearFair(mask, size(image)); To mask the image we multiply the image matrix with the mask matrix. This way all voxels outside of the mask are set to 0. image = image.*maskResampled; Then we can save the image as a NIFTI again and open it with our favorite NIFTI viewer. xASL_io_CreateNifti(fullfile(x.MyPath,'export.nii'), image); xASL_io_Nifti2Im does unzip your image, so make sure to revert those changes within the ExploreASL directory later using git reset or git revert .","title":"Basic NIFTI Input &amp; Output"},{"location":"Tutorials-Advanced/#basic-file-operations","text":"Matlab offers two functions to copy or move files and folders from a source to a destination within your file system. These functions are copyfile and movefile . To improve speed and multi OS compatibility, we wrote two similar functions, called xASL_Copy and xASL_Move . In the following example we copy a file called fileA from the folder C:\\Users\\Test_One to C:\\Users\\Test_Two . We then move the file back to C:\\Users\\Test_One and overwrite the original fileA . Finally, we rename fileA to fileB . % Copy fileA from Test_One to Test_Two xASL_Copy('C:\\Users\\Test_One\\fileA.txt', 'C:\\Users\\Test_Two\\fileA.txt'); % Move fileA back to Test_One and overwrite the original fileA xASL_Move('C:\\Users\\Test_Two\\fileA.txt', 'C:\\Users\\Test_One\\fileA.txt', 1); % Rename fileA to fileB xASL_Move('C:\\Users\\Test_One\\fileA.txt', 'C:\\Users\\Test_One\\fileB.txt', 1); Often we need to find a list of files in a certain directory. To do this, we can use xASL_adm_GetFileList . Let's assume there are five files called fileA , fileB , fileC , fileD and fileE in C:\\Users\\Test_One . We know that all names start with file , so we can use this for our regular expression. Check out the example below on how you can get a cell array containing the paths of all these files. strDirectory = 'C:\\Users\\Test_One'; strRegEx = '^file.+$'; filepaths = xASL_adm_GetFileList(strDirectory, strRegEx);","title":"Basic File Operations"},{"location":"Tutorials-Advanced/#atlas-options","text":"The atlases of the ExploreASL population module can be defined in the x.S sub-structure. If you are interested in the TotalGM , TotalWM , DeepWM , Hammers , HOcort_CONN , HOsub_CONN , and Mindboggle_OASIS_DKT31_CMA atlases e.g., you can add the following lines to your dataPar.json file. { \"x\": [{ \"name\": \"Example\", \"subject_regexp\": \"Example\", \"S\": {\"Atlases\": [\"TotalGM\",\"TotalWM\",\"DeepWM\",\"Hammers\",\"HOcort_CONN\",\"HOsub_CONN\",\"Mindboggle_OASIS_DKT31_CMA\"]} }] } Available atlases are: Free atlases: TotalGM : Mask of the entire GM TotalWM : Mask of the entire WM DeepWM : Mask of the deep WM WholeBrain : Mask of the entire brain MNI_Structural : MNI cortical atlas Tatu_ACA_MCA_PCA : Original vascular territories by Tatu et al. Tatu_ICA_PCA : Tatu (only ICA and PCA) Tatu_ICA_L_ICA_R_PCA : Tatu (L ICA and R PCA) Tatu_ACA_MCA_PCA_Prox_Med_Dist : Tatu separated to distal/medial/proximal of ACA/MCA/PCA Mindboggle_OASIS_DKT31_CMA : Mindboggle-101 cortical atlas Free for non-commercial use only: HOcort_CONN : Harvard-Oxford cortical atlas HOsub_CONN : Harvard-Oxford subcortical atlas Hammers : Alexander Hammers's brain atlas HammersCAT12 : Hammers atlas adapted to DARTEL template of IXI550 space Thalamus : Harvad-Oxford thalamus atlas In a future ExploreASL version we want to add a custom atlases directory, where you can add your own atlas & metadata file including a description of how to do this.","title":"Atlas Options"},{"location":"Tutorials-Basics/","text":"Tutorials (Basics) How to run ExploreASL using Matlab The first thing you have to do, to use ExploreASL , is to clone the ExploreASL repository. If you want to run ExploreASL from Matlab, we recommend to clone the main repository directly from the official GitHub website . You also have the option to download the zipped version or to download an older release . If you are new to Matlab, we recommend checking out a Matlab tutorial . It can be helpful to add the ExploreASL directory to your Matlab paths. Open Matlab, select the Home tab, and add the ExploreASL directory including its subfolders using the Set Path option. Now change your working directory, using the Current Folder tab or the cd command, to the ExploreASL directory. To run ExploreASL you have to type in the following command in the Command Window : ExploreASL . If you already created an ASL-BIDS dataset in sourcedata format, you can run the full default ExploreASL pipeline like this: DatasetRoot = 'C:\\...\\MY-BIDS-DATASET'; ImportModules = true; ProcessModules = true; bPause = false; [x] = ExploreASL_Master(DatasetRoot, ImportModules, ProcessModules, bPause); How to run a compiled ExploreASL Version To compile ExploreASL you have to run the xASL_adm_MakeStandalone.m script. If necessary, you can also ask the developer team for a specific compiled version. Providing a compiled version for every operating system and corresponding Matlab version is currently not feasible for us. Please feel free to ask us for help though! A compiled version of ExploreASL always requires the corresponding Matlab Runtime. Please checkout the official Matlab Documentation . Download the Matlab Runtime of the Matlab Version which was used for the compilation. Make sure to install the Matlab Runtime correctly. If you're using Windows, it is important that the path to the Matlab Runtime is added to Windows PATH during the installation. Windows Let's assume you want to run the compiled version of ExploreASL latest . Check the contents of the folder created by xASL_adm_MakeStandalone.m , which contains the compiled version. There should be a file called xASL_latest.exe . We recommend using the command line interface now. For this you can go to the address bar of your file explorer. Type in cmd to open the command prompt in the current folder. The following command will start ExploreASL , import the ASL-BIDS dataset in sourcedata format, and process the dataset corresponding to your DatasetRoot directory: xASL_latest.exe \"c:\\MY-BIDS-DATASET\" \"1\" \"1\" The executable will extract all necessary data from the CTF archive within the folder. This is totally normal. Within the command window you should see that ExploreASL is starting to process the given dataset: xASL_latest.exe \"c:\\MY-BIDS-DATASET\" \"1\" \"1\" (insert example here) To test if it is possible to initialize ExploreASL without the processing of a dataset, you could run the following command: xASL_latest.exe \"\" \"0\" \"0\" The usual ExploreASL parameters ( DatasetRoot , ImportModules , ProcessModules , bPause , iWorker , nWorkers ) have to be given to the compiled ExploreASL version as strings. The resulting output could look like this: xASL_latest.exe \"\" \"0\" \"0\" (insert example here) Linux On Linux you can basically do the same as above. We can run the ExploreASL shell script with a specified Matlab MCR (here we use version 96 e.g.) using the following command: ./run_xASL_latest.sh /usr/local/MATLAB/MATLAB_Runtime/v96/ \"\" \"0\" \"0\" Using the options \"\" \"0\" \"0\" we initialize ExploreASL , but do not process a dataset. To run a dataset, we have to switch the ImportModules and/or the ProcessModules parameter from 0 to 1 and pass a path for the DatasetRoot directory. This could look something like this: ./run_xASL_latest.sh /usr/local/MATLAB/MATLAB_Runtime/v96/ \"/home/MY-BIDS-DATASET\" \"1\" \"1\" (insert example here) How to run ExploreASL using the docker image First you have to pull an official docker image from the ExploreASL repository: docker pull exploreasl/xasl:latest Check out your local images using docker images . If you want to rename the docker image, tag your image using the docker tag command: docker tag exploreasl/xasl:latest xasl:my-version To start a docker container of ExploreASL v1.7.0 e.g., you can use the following command: docker run -e DATASETROOT=MY-BIDS-DATASET -e IMPORTMODULES=1 -e PROCESSMODULES=1 -v /home/.../incoming:/data/incoming -v /home/.../outgoing:/data/outgoing xasl:1.7.0 Here DATASETROOT is an environment variable which is a relative path to the DATASETROOT directory of your dataset. The IMPORTMODULES and PROCESSMODULES are the parameters of ExploreASL_Master /home/.../incoming:/data/incoming is used to mount your dataset folder ( /home/.../incoming ) to its corresponding docker dataset folder ( /data/incoming ). The same notation is used to mount the docker dataset output folder ( /data/outgoing ) to its corresponding real output folder on your drive ( /home/.../outgoing ). The ExploreASL x structure The ExploreASL x structure is the main object used to define pipeline settings. Besides settings you can also find processing and meta data there. x.opts (Options) Fieldname Description x.opts.DatasetRoot Dataset root directory of the current BIDS dataset. This is also the first input argument of ExploreASL . x.opts.ImportModules Vector to define which import modules should be executed. This is also the second input argument of ExploreASL . x.opts.ProcessModules Vector to define which processing modules should be executed. This is also the third input argument of ExploreASL . x.opts.bPause Boolean to set if you want to pause the pipeline before the processing. This is also the fourth input argument of ExploreASL . x.opts.iWorker This variable defines which of the parallel ExploreASL calls we are. This is also the fifth input argument of ExploreASL . x.opts.nWorkers This variable defines how many ExploreASL calls are made in parallel. This is also the sixth input argument of ExploreASL . x.opts.bImportData Boolean that is true if at least one import module is going to be executed. x.opts.bProcessData Boolean that is true if at least one processing module is going to be executed. x.opts.bLoadData Boolean that is true if the current BIDS dataset is going to be loaded. x.opts.MyPath Path to the ExploreASL program. x.opts.dataParType String describing the type of input argument that was given for the DatasetRoot . This parameter is mainly supposed to help with backwards compatibility. x.settings (Settings) Fieldname Description x.settings.SelectParFile Variable which tells the import workflow if we have to ask the user for the study root directory a second time. x.settings.stopAfterErrors Number of allowed errors before job iteration is stopped (default=inf). x.settings.dryRun Dry run does not execute the module (default=0). x.settings.bOverwrite Re-running makes no sense if you're not overwriting existing files. x.settings.BILAT_FILTER Bilateral filter by Matthan Caan (original=1, more recent=2). x.settings.DELETETEMP Boolean for removing the temporary files. x.settings.Quality Quality setting for ExploreASL processing. Set to 1 for normal high-quality processing or to 0 for low-quality test runs. x.settings.bReproTesting n/a x.settings.Pediatric_Template n/a x.settings.bLesionFilling Boolean for lesion filling in structural module (submodule 5). x.settings.bAutoACPC Boolean whether center of mass alignment should be performed before SPM registration. x.settings.bGetControlLabelOrder n/a x.settings.SkipIfNoFlair Boolean to skip processing of subjects that do not have a FLAIR image. x.settings.SkipIfNoASL Boolean to skip processing of subjects that do not have a ASL image. x.settings.SkipIfNoM0 Boolean to skip processing of subjects that do not have a M0 image. x.dataset (Dataset) Fieldname Description x.dataset.name String for the name of the study. x.dataset.subjectRegexp String with regular expression for ExploreASL to find subjects by foldername. x.dataset.exclusion Cell with list of subjects to exclude. x.dataset.ForceInclusionList Use this field if you want to use a selection of subjects rather than taking all available subjects from directories. x.dir, x.P & x.D (Paths) Fieldname Description x.dir.sourceStructure Path to the sourceStructure.json file. x.dir.studyPar Path to the studyPar.json file. x.dir.dataset_description Path to the dataset_description.json file. x.dir.dataPar Path to the dataPar.json file. x.D.ROOT Path to the root directory. x.Q (Sequence & quantification) Fieldname Description x.Q.M0 Choose which M0 option to use. x.Q.BackgroundSuppressionNumberPulses Used to estimate decrease of labeling efficiency. x.Q.BackgroundSuppressionPulseTime Vector containing timing, in ms, of the background suppression pulses before the start of the readout (per BIDS). x.Q.PresaturationTime Time in ms before the start of the readout, scalar, when the slice has been saturated (90 degree flip) this has to come before all the bSup pulses, but doesn't need to be always specified. x.Q.readoutDim String specifying the readout type. x.Q.Vendor String containing the Vendor used. x.Q.Sequence String containing the sequence used. x.Q.LabelingType String containing the labeling strategy used. x.Q.Initial_PLD Value of PLD (ms), for 3D this is fixed for whole brain, for 2D this is the PLD of first acquired slice. x.Q.LabelingDuration Value of labeling duration (ms). x.Q.SliceReadoutTime Value (ms) of time added to the PLD after reading out each slice. x.Q.bUseBasilQuantification True for using BASIL quantification in addition to ExploreASL's quantification. x.Q.Lambda Brain/blood water coefficient (mL 1H/ mL blood). x.Q.T2art T2* of arterial blood at 3T, only used when no M0 image (ms). x.Q.BloodT1 T1 relaxation time of arterial blood (ms). Defaults (Alsop MRM 2014), 1800 for GSP phantom. x.Q.TissueT1 T1 relaxation time of GM tissue (ms). Defaults (Alsop MRM 2014). x.Q.nCompartments Number of modeled compartments for quantification. x.Q.ApplyQuantification A vector of 1x5 logical values specifying which types on quantified images should be calculated and saved. x.Q.SaveCBF4D Boolean, true to also save 4D CBF timeseries, if ASL4D had timeseries. x.modules (Modules) Fieldname Description x.modules.bRunLongReg Run longitudinal registration. x.modules.bRunDARTEL Run between-subject registration/create templates. x.modules.import (Import module) Fieldname Description x.modules.import.settings.bCopySingleDicoms n/a x.modules.import.settings.bUseDCMTK n/a x.modules.import.settings.bCheckPermissions n/a x.modules.structural (Structural module) Fieldname Description x.modules.structural.bSegmentSPM12 Boolean to specify if SPM12 segmentation is run instead of CAT12. x.modules.structural.bHammersCAT12 Boolean specifying if CAT12 should provide Hammers volumetric ROI results. x.modules.structural.bFixResolution Resample to a resolution that CAT12 accepts. x.modules.asl (ASL module) Fieldname Description x.modules.asl.motionCorrection Boolean to perform motion correction in case of timeseries. x.modules.asl.SpikeRemovalThreshold Minimal t-stat improval needed to remove motion spikes. x.modules.asl.bRegistrationContrast Specifies the image contrast used for registration. x.modules.asl.bAffineRegistration Specifies if the ASL-T1w rigid-body registration is followed up by an affine registration. x.modules.asl.bDCTRegistration Specifies if to include the DCT registration on top of Affine. x.modules.asl.bRegisterM02ASL Boolean specifying whether M0 is registered to mean_control image (or T1w if no control image exists). x.modules.asl.bUseMNIasDummyStructural When structural (e.g. T1w) data is missing, copy population-average MNI templates as dummy structural templates. x.modules.asl.bPVCNativeSpace Performs partial volume correction (PVC) in ASL native space using the GM and WM maps obtained from previously segmented T1-weighted images. x.modules.asl.PVCNativeSpaceKernel Kernel size for the ASL native space PVC. x.modules.asl.bPVCGaussianMM If set to 1, PV-correction with a Gaussian weighting is used instead of the equal weights of all voxels in the kernel ('flat' kernel) as per Asllani's original method. x.modules.asl.bMakeNIfTI4DICOM Boolean to output CBF native space maps resampled and/or registered to the original T1w/ASL, and contrast adapted and in 12 bit range allowing to convert the NIfTI to a DICOM file. x.modules.population (Population module) Fieldname Description ... n/a x.S (Masking & atlases) Fieldname Description x.S.bMasking Vector specifying if we should mask a ROI with a subject-specific mask. x.S.Atlases Vector specifying the atlases which should be used within the population module. x.S.slices Slice numbers: defines which transversal slices to use by default. x.S.slicesLarge Slice numbers: defines which transversal slices to use by default. x.S.slicesExtraLarge Slice numbers: defines which transversal slices to use by default. x.S.nSlices Length of x.S.slices. x.S.nSlicesLarge Length of x.S.slicesLarge. x.S.nSlicesExtraLarge Length of x.S.slicesExtraLarge. x.S.TransCrop Cropping settings: defines default transversal cropping settings. x.S.jet256 Jet 256 colormap. x.S.gray Grayscale colormap. x.S.red Red colormap. x.S.yellow Yellow colormap. x.S.green Green colormap. x.S.blue Blue colormap. x.S.purple Purple colormap. x.S.turqoise Turqoise colormap. x.S.orange Orange colormap. x.S.colors_ROI Cell array containing the colormaps from above. x.S.cool Cool colorbar. x.S.hot Hot colorbar. x.S.VoxelSize Voxel-size in mm of reslicing & DARTEL (default=1.5mm). x.S.masks Contains skull and WBmask. x.S.LabelClr 64 label colors. x.external (External tools) Fieldname Description x.external.SPMVERSION String describing the version of SPM. x.external.bAutomaticallyDetectFSL Boolean to automatically detect the FSL version if disabled, this function will try to use the system-initialized FSL and throw an error if FSL is not initialized.","title":"Tutorials (Basics)"},{"location":"Tutorials-Basics/#tutorials-basics","text":"","title":"Tutorials (Basics)"},{"location":"Tutorials-Basics/#how-to-run-exploreasl-using-matlab","text":"The first thing you have to do, to use ExploreASL , is to clone the ExploreASL repository. If you want to run ExploreASL from Matlab, we recommend to clone the main repository directly from the official GitHub website . You also have the option to download the zipped version or to download an older release . If you are new to Matlab, we recommend checking out a Matlab tutorial . It can be helpful to add the ExploreASL directory to your Matlab paths. Open Matlab, select the Home tab, and add the ExploreASL directory including its subfolders using the Set Path option. Now change your working directory, using the Current Folder tab or the cd command, to the ExploreASL directory. To run ExploreASL you have to type in the following command in the Command Window : ExploreASL . If you already created an ASL-BIDS dataset in sourcedata format, you can run the full default ExploreASL pipeline like this: DatasetRoot = 'C:\\...\\MY-BIDS-DATASET'; ImportModules = true; ProcessModules = true; bPause = false; [x] = ExploreASL_Master(DatasetRoot, ImportModules, ProcessModules, bPause);","title":"How to run ExploreASL using Matlab"},{"location":"Tutorials-Basics/#how-to-run-a-compiled-exploreasl-version","text":"To compile ExploreASL you have to run the xASL_adm_MakeStandalone.m script. If necessary, you can also ask the developer team for a specific compiled version. Providing a compiled version for every operating system and corresponding Matlab version is currently not feasible for us. Please feel free to ask us for help though! A compiled version of ExploreASL always requires the corresponding Matlab Runtime. Please checkout the official Matlab Documentation . Download the Matlab Runtime of the Matlab Version which was used for the compilation. Make sure to install the Matlab Runtime correctly. If you're using Windows, it is important that the path to the Matlab Runtime is added to Windows PATH during the installation.","title":"How to run a compiled ExploreASL Version"},{"location":"Tutorials-Basics/#windows","text":"Let's assume you want to run the compiled version of ExploreASL latest . Check the contents of the folder created by xASL_adm_MakeStandalone.m , which contains the compiled version. There should be a file called xASL_latest.exe . We recommend using the command line interface now. For this you can go to the address bar of your file explorer. Type in cmd to open the command prompt in the current folder. The following command will start ExploreASL , import the ASL-BIDS dataset in sourcedata format, and process the dataset corresponding to your DatasetRoot directory: xASL_latest.exe \"c:\\MY-BIDS-DATASET\" \"1\" \"1\" The executable will extract all necessary data from the CTF archive within the folder. This is totally normal. Within the command window you should see that ExploreASL is starting to process the given dataset: xASL_latest.exe \"c:\\MY-BIDS-DATASET\" \"1\" \"1\" (insert example here) To test if it is possible to initialize ExploreASL without the processing of a dataset, you could run the following command: xASL_latest.exe \"\" \"0\" \"0\" The usual ExploreASL parameters ( DatasetRoot , ImportModules , ProcessModules , bPause , iWorker , nWorkers ) have to be given to the compiled ExploreASL version as strings. The resulting output could look like this: xASL_latest.exe \"\" \"0\" \"0\" (insert example here)","title":"Windows"},{"location":"Tutorials-Basics/#linux","text":"On Linux you can basically do the same as above. We can run the ExploreASL shell script with a specified Matlab MCR (here we use version 96 e.g.) using the following command: ./run_xASL_latest.sh /usr/local/MATLAB/MATLAB_Runtime/v96/ \"\" \"0\" \"0\" Using the options \"\" \"0\" \"0\" we initialize ExploreASL , but do not process a dataset. To run a dataset, we have to switch the ImportModules and/or the ProcessModules parameter from 0 to 1 and pass a path for the DatasetRoot directory. This could look something like this: ./run_xASL_latest.sh /usr/local/MATLAB/MATLAB_Runtime/v96/ \"/home/MY-BIDS-DATASET\" \"1\" \"1\" (insert example here)","title":"Linux"},{"location":"Tutorials-Basics/#how-to-run-exploreasl-using-the-docker-image","text":"First you have to pull an official docker image from the ExploreASL repository: docker pull exploreasl/xasl:latest Check out your local images using docker images . If you want to rename the docker image, tag your image using the docker tag command: docker tag exploreasl/xasl:latest xasl:my-version To start a docker container of ExploreASL v1.7.0 e.g., you can use the following command: docker run -e DATASETROOT=MY-BIDS-DATASET -e IMPORTMODULES=1 -e PROCESSMODULES=1 -v /home/.../incoming:/data/incoming -v /home/.../outgoing:/data/outgoing xasl:1.7.0 Here DATASETROOT is an environment variable which is a relative path to the DATASETROOT directory of your dataset. The IMPORTMODULES and PROCESSMODULES are the parameters of ExploreASL_Master /home/.../incoming:/data/incoming is used to mount your dataset folder ( /home/.../incoming ) to its corresponding docker dataset folder ( /data/incoming ). The same notation is used to mount the docker dataset output folder ( /data/outgoing ) to its corresponding real output folder on your drive ( /home/.../outgoing ).","title":"How to run ExploreASL using the docker image"},{"location":"Tutorials-Basics/#the-exploreasl-x-structure","text":"The ExploreASL x structure is the main object used to define pipeline settings. Besides settings you can also find processing and meta data there.","title":"The ExploreASL x structure"},{"location":"Tutorials-Basics/#xopts-options","text":"Fieldname Description x.opts.DatasetRoot Dataset root directory of the current BIDS dataset. This is also the first input argument of ExploreASL . x.opts.ImportModules Vector to define which import modules should be executed. This is also the second input argument of ExploreASL . x.opts.ProcessModules Vector to define which processing modules should be executed. This is also the third input argument of ExploreASL . x.opts.bPause Boolean to set if you want to pause the pipeline before the processing. This is also the fourth input argument of ExploreASL . x.opts.iWorker This variable defines which of the parallel ExploreASL calls we are. This is also the fifth input argument of ExploreASL . x.opts.nWorkers This variable defines how many ExploreASL calls are made in parallel. This is also the sixth input argument of ExploreASL . x.opts.bImportData Boolean that is true if at least one import module is going to be executed. x.opts.bProcessData Boolean that is true if at least one processing module is going to be executed. x.opts.bLoadData Boolean that is true if the current BIDS dataset is going to be loaded. x.opts.MyPath Path to the ExploreASL program. x.opts.dataParType String describing the type of input argument that was given for the DatasetRoot . This parameter is mainly supposed to help with backwards compatibility.","title":"x.opts (Options)"},{"location":"Tutorials-Basics/#xsettings-settings","text":"Fieldname Description x.settings.SelectParFile Variable which tells the import workflow if we have to ask the user for the study root directory a second time. x.settings.stopAfterErrors Number of allowed errors before job iteration is stopped (default=inf). x.settings.dryRun Dry run does not execute the module (default=0). x.settings.bOverwrite Re-running makes no sense if you're not overwriting existing files. x.settings.BILAT_FILTER Bilateral filter by Matthan Caan (original=1, more recent=2). x.settings.DELETETEMP Boolean for removing the temporary files. x.settings.Quality Quality setting for ExploreASL processing. Set to 1 for normal high-quality processing or to 0 for low-quality test runs. x.settings.bReproTesting n/a x.settings.Pediatric_Template n/a x.settings.bLesionFilling Boolean for lesion filling in structural module (submodule 5). x.settings.bAutoACPC Boolean whether center of mass alignment should be performed before SPM registration. x.settings.bGetControlLabelOrder n/a x.settings.SkipIfNoFlair Boolean to skip processing of subjects that do not have a FLAIR image. x.settings.SkipIfNoASL Boolean to skip processing of subjects that do not have a ASL image. x.settings.SkipIfNoM0 Boolean to skip processing of subjects that do not have a M0 image.","title":"x.settings (Settings)"},{"location":"Tutorials-Basics/#xdataset-dataset","text":"Fieldname Description x.dataset.name String for the name of the study. x.dataset.subjectRegexp String with regular expression for ExploreASL to find subjects by foldername. x.dataset.exclusion Cell with list of subjects to exclude. x.dataset.ForceInclusionList Use this field if you want to use a selection of subjects rather than taking all available subjects from directories.","title":"x.dataset (Dataset)"},{"location":"Tutorials-Basics/#xdir-xp-xd-paths","text":"Fieldname Description x.dir.sourceStructure Path to the sourceStructure.json file. x.dir.studyPar Path to the studyPar.json file. x.dir.dataset_description Path to the dataset_description.json file. x.dir.dataPar Path to the dataPar.json file. x.D.ROOT Path to the root directory.","title":"x.dir, x.P &amp; x.D (Paths)"},{"location":"Tutorials-Basics/#xq-sequence-quantification","text":"Fieldname Description x.Q.M0 Choose which M0 option to use. x.Q.BackgroundSuppressionNumberPulses Used to estimate decrease of labeling efficiency. x.Q.BackgroundSuppressionPulseTime Vector containing timing, in ms, of the background suppression pulses before the start of the readout (per BIDS). x.Q.PresaturationTime Time in ms before the start of the readout, scalar, when the slice has been saturated (90 degree flip) this has to come before all the bSup pulses, but doesn't need to be always specified. x.Q.readoutDim String specifying the readout type. x.Q.Vendor String containing the Vendor used. x.Q.Sequence String containing the sequence used. x.Q.LabelingType String containing the labeling strategy used. x.Q.Initial_PLD Value of PLD (ms), for 3D this is fixed for whole brain, for 2D this is the PLD of first acquired slice. x.Q.LabelingDuration Value of labeling duration (ms). x.Q.SliceReadoutTime Value (ms) of time added to the PLD after reading out each slice. x.Q.bUseBasilQuantification True for using BASIL quantification in addition to ExploreASL's quantification. x.Q.Lambda Brain/blood water coefficient (mL 1H/ mL blood). x.Q.T2art T2* of arterial blood at 3T, only used when no M0 image (ms). x.Q.BloodT1 T1 relaxation time of arterial blood (ms). Defaults (Alsop MRM 2014), 1800 for GSP phantom. x.Q.TissueT1 T1 relaxation time of GM tissue (ms). Defaults (Alsop MRM 2014). x.Q.nCompartments Number of modeled compartments for quantification. x.Q.ApplyQuantification A vector of 1x5 logical values specifying which types on quantified images should be calculated and saved. x.Q.SaveCBF4D Boolean, true to also save 4D CBF timeseries, if ASL4D had timeseries.","title":"x.Q (Sequence &amp; quantification)"},{"location":"Tutorials-Basics/#xmodules-modules","text":"Fieldname Description x.modules.bRunLongReg Run longitudinal registration. x.modules.bRunDARTEL Run between-subject registration/create templates.","title":"x.modules (Modules)"},{"location":"Tutorials-Basics/#xmodulesimport-import-module","text":"Fieldname Description x.modules.import.settings.bCopySingleDicoms n/a x.modules.import.settings.bUseDCMTK n/a x.modules.import.settings.bCheckPermissions n/a","title":"x.modules.import (Import module)"},{"location":"Tutorials-Basics/#xmodulesstructural-structural-module","text":"Fieldname Description x.modules.structural.bSegmentSPM12 Boolean to specify if SPM12 segmentation is run instead of CAT12. x.modules.structural.bHammersCAT12 Boolean specifying if CAT12 should provide Hammers volumetric ROI results. x.modules.structural.bFixResolution Resample to a resolution that CAT12 accepts.","title":"x.modules.structural (Structural module)"},{"location":"Tutorials-Basics/#xmodulesasl-asl-module","text":"Fieldname Description x.modules.asl.motionCorrection Boolean to perform motion correction in case of timeseries. x.modules.asl.SpikeRemovalThreshold Minimal t-stat improval needed to remove motion spikes. x.modules.asl.bRegistrationContrast Specifies the image contrast used for registration. x.modules.asl.bAffineRegistration Specifies if the ASL-T1w rigid-body registration is followed up by an affine registration. x.modules.asl.bDCTRegistration Specifies if to include the DCT registration on top of Affine. x.modules.asl.bRegisterM02ASL Boolean specifying whether M0 is registered to mean_control image (or T1w if no control image exists). x.modules.asl.bUseMNIasDummyStructural When structural (e.g. T1w) data is missing, copy population-average MNI templates as dummy structural templates. x.modules.asl.bPVCNativeSpace Performs partial volume correction (PVC) in ASL native space using the GM and WM maps obtained from previously segmented T1-weighted images. x.modules.asl.PVCNativeSpaceKernel Kernel size for the ASL native space PVC. x.modules.asl.bPVCGaussianMM If set to 1, PV-correction with a Gaussian weighting is used instead of the equal weights of all voxels in the kernel ('flat' kernel) as per Asllani's original method. x.modules.asl.bMakeNIfTI4DICOM Boolean to output CBF native space maps resampled and/or registered to the original T1w/ASL, and contrast adapted and in 12 bit range allowing to convert the NIfTI to a DICOM file.","title":"x.modules.asl (ASL module)"},{"location":"Tutorials-Basics/#xmodulespopulation-population-module","text":"Fieldname Description ... n/a","title":"x.modules.population (Population module)"},{"location":"Tutorials-Basics/#xs-masking-atlases","text":"Fieldname Description x.S.bMasking Vector specifying if we should mask a ROI with a subject-specific mask. x.S.Atlases Vector specifying the atlases which should be used within the population module. x.S.slices Slice numbers: defines which transversal slices to use by default. x.S.slicesLarge Slice numbers: defines which transversal slices to use by default. x.S.slicesExtraLarge Slice numbers: defines which transversal slices to use by default. x.S.nSlices Length of x.S.slices. x.S.nSlicesLarge Length of x.S.slicesLarge. x.S.nSlicesExtraLarge Length of x.S.slicesExtraLarge. x.S.TransCrop Cropping settings: defines default transversal cropping settings. x.S.jet256 Jet 256 colormap. x.S.gray Grayscale colormap. x.S.red Red colormap. x.S.yellow Yellow colormap. x.S.green Green colormap. x.S.blue Blue colormap. x.S.purple Purple colormap. x.S.turqoise Turqoise colormap. x.S.orange Orange colormap. x.S.colors_ROI Cell array containing the colormaps from above. x.S.cool Cool colorbar. x.S.hot Hot colorbar. x.S.VoxelSize Voxel-size in mm of reslicing & DARTEL (default=1.5mm). x.S.masks Contains skull and WBmask. x.S.LabelClr 64 label colors.","title":"x.S (Masking &amp; atlases)"},{"location":"Tutorials-Basics/#xexternal-external-tools","text":"Fieldname Description x.external.SPMVERSION String describing the version of SPM. x.external.bAutomaticallyDetectFSL Boolean to automatically detect the FSL version if disabled, this function will try to use the system-initialized FSL and throw an error if FSL is not initialized.","title":"x.external (External tools)"},{"location":"Tutorials-QC/","text":"Tutorials (QC - Quick Start) Attention: Unfortunately, the following tutorial is outdated. We are working on an up-to-date version right now. This document provides a \u201cquick start\u201d walk-through for a dataset processed by ExploreASL. This can be either the attached example dataset (n=1) or a clinical study. It is always recommended to first test the compatibility of ExploreASL with the example dataset (Step 0 below), and to create a file report for steps 1-6, to get accustomed to the data and to make sure that ExploreASL runs properly. Note that ExploreASL is in development, so naming conventions may change, especially when we move to a complete BIDS adherence. 0. Run TestDataSet to check ExploreASL compatibility First, try to run the test data set. Note that according to good practice, it is important to separate code and data. The user should copy /ExploreASL/External/TestDataSet to a directory with read and write permissions outside of the ExploreASL toolbox, and keep the ExploreASL directory structure unchanged. Let\u2019s assume your copy of the TestDataSet is now in the folder /drive/folder/TestDataSet . Open Matlab, go to the directory of ExploreASL, run ExploreASL(\u2018drive/folder/TestDataSet/derivatives/ExploreASL/dataPar.json\u2019, 0, 1); to process the TestDataSet. The dataPar.json file in the example dataset contains all image processing and quantification parameters that ExploreASL needs. (Note that for your own study, you would need to create this parameter file. You can find a list of parameters in /ExploreASL/DataParTemplate.m ). If you only want to run a quick test, we recommend to set the Quality parameter within dataPar.json to 0. Please note that in the future, the structure of this test dataset will be replaced by the BIDS format. Also, you can add the same parameters to the JSON sidecars of the ASL NIfTI files, which will allow processing ASL scans with different parameters within the same study. In the case of a multi-center study, and/or multiple sequences or scanner updates, the JSON sidecars allow to have different ASL parameters within a single study. Upon successful completion of the processing, ExploreASL creates a result file ( //Population/Stats/ median_qCBF_(Native|Standard)Space_total_GM_n=1_*_PVC0.tsv ). Verify that the GM CBF here (without partial volume (PV) correction, i.e. PVC0)) is approximately 65 mL/100g/min . If this file does not exist, then there could be a problem with ExploreASL compatibility. If the file exists and values are the same as reported here, then your software and hardware are ExploreASL compatible. In case ExploreASL processing runs for the example data set and not for other datasets then the problem is probably data related and not compatibility related. When you perform this walkthrough on your own data, there are three first main cases to note: Data completeness, note down any data that was not imported or somehow not got processed; Proper processing, check visually whether the processing went well, e.g. nicely segmented and registered; Large anatomical deviations, check visually if there are large anatomical variations that can make subjects outliers 1. Data inclusion >> dataPar = '\\drive\\TestDataSet\\derivatives\\ExploreASL\\dataPar.json'; >> [x] = ExploreASL_Master(dataPar,0,1,1); ExploreASL will run the processing pipeline... ============================================================================================== ________ __ ______ ______ __ / | / | / \\ / \\ / | ########/ __ __ ______ ## | ______ ______ ______ /###### |/###### |## | ## |__ / \\ / | / \\ ## | / \\ / \\ / \\ ## |__## |## \\__##/ ## | ## | ## \\/##/ /###### |## |/###### |/###### |/###### |## ## |## \\ ## | #####/ ## ##< ## | ## |## |## | ## |## | ##/ ## ## |######## | ###### |## | ## |_____ /#### \\ ## |__## |## |## \\__## |## | ########/ ## | ## |/ \\__## |## |_____ ## |/##/ ## |## ##/ ## |## ##/ ## | ## |## | ## |## ##/ ## | ########/ ##/ ##/ #######/ ##/ ######/ ##/ #######/ ##/ ##/ ######/ ########/ ## | ## | ##/ ==================================== ExploreASL Settings ===================================== DataParPath \\drive\\TestDataSet\\derivatives\\ExploreASL\\dataPar.json Import Modules Process Modules Structural ASL Population bPause True iWorker 1 nWorkers 1 ============================================================================================== ExploreASL v1.5.1 initialized ... Automatically defining sessions... ==================================== Additional Settings ===================================== 1 scans - 0 exclusions, resulting in 1 scans of: Longitudinal timePoint 1 = 1 scans - 0 exclusions = 1 scans ASL sessions: 1 Ancillary data, sets: 3 sets are defined for 1 \"SubjectsSessions\" Set 1 = \"LongitudinalTimePoint\" options \"TimePoint_1\", codes for paired data Set 2 = \"SubjectNList\" options \"SubjectNList\", codes for paired data Set 3 = \"Site\" options \"SingleSite\", codes for two-sample data x.D.ROOT \\drive\\TestDataSet\\derivatives\\ExploreASL x.DELETETEMP 1 (delete temporary files) x.Quality 1 (0 = fast try-out; 1 = normal high quality) ============================================================================================== Press any key to start processing & analyzing Please ensure you have a read-only copy of your original data as they may be overwritten Or press CTRL/command-C to cancel... You should obtain a similar initial screen showing which subjects and scans are found to be processed (how many exclusions, how many subjects for each time point etc.), as well as potentially included co-variates (e.g. site, age, cohort, sex). Note that we run the pipeline on low quality ( x.Quality=0 ): while this will provide poorer results (segmentation, registration, etc) this will allow us to quickly test the full pipeline. On a relatively new computer, the full pipeline should run either within 5-10 min ( x.Quality=0 ) or 30-60 min ( x.Quality=1 ). 2. Missing files Check the files //ROOT/Missing*Files.csv . These provide an overview of any missing files. Files can either be missing when they are not imported ( Missing*NativeFiles.csv , for native space files), or when they are not processed (mainly Missing*MNIFiles.csv , for MNI space files). If no files are specified in these files, or they do not exist, this means that there were no missing files. 3. QC structural module The structural module processes the anatomical (T1-weighted, T1w) images, to provide segmentations/partial volume (PV) maps and for spatial normalization to MNI space. Optionally, if FLAIR images exist, these are used to correct the white matter hyperintensities (WMH) on the T1w images. Check (from left to right): //Population/T1Check/Tra_Src_rT1_*.jpg for T1w quality, structural anomalies, normalization to MNI //Population/T1Check/Tra_Reg_rT1_*.jpg same as previous, but after lesion filling (if FLAIR exists) //Population/T1Check/Tra_Seg_rT1_*.jpg for T1w segmentation (WM segmentation in red) //Population/TissueVolume/Tissue_volume_*.tsv for the GM, WM and CSF volumes Note that all QC images are prefixed with \u2018Tra_\u2019 (transversal/axial)/ \u2018Cor_\u2019 (coronal) or \u2018Sag_\u2019 (sagittal) denoting the plane of the slices. Check, if FLAIR exists (from left to right): //Population/FLAIRCheck/Tra_Src_rFLAIR_*.jpg for FLAIR quality, structural anomalies //Population/FLAIRCheck/Tra_Reg_rFLAIR_*reg.jpg for WMH segmentation, compare with previous //Population/FLAIR_REGDIR/Tra_Seg_rFLAIR_*reg.jpg for registration FLAIR->T1w (red=T1w WM segmentation) //Population/TissueVolume/WMH_LST_*.tsv for the WMH Total Lesion Volume (TLV) and number (N) of WMH For a population data quality overview (if nScans>1), inspect //Population/Templates/Template_mean_T1.nii, as well as //Population/Templates/Template_sd_T1.nii for the between-subject variation. Do the same for pGM and pWM, and FLAIR and WMH_SEGM if available. 4. DICOM values //Population/DICOMparameters/ASL4D_quantification_parameters.csv and //Population/DICOMparameters/M0_quantification_parameters.csv summarize the data in the files //ROOT/SubjectName/ASL_1/ASL4D_parms.mat and //ROOT/SubjectName/ASL_1/M0_parms.mat , including the different DICOM header parameters that are imported and can be used in the quantification process. It is important to check that the TR, TE, and scale slopes are comparable for all scans on a single scanner. If not, they allude to situations where the scans were performed with not completely similar protocols, due to e.g. a software update, or use of different scanners. Ignoring this can lead to undesired variance in the whole-brain CBF quantification. 5. QC of ASL module The ASL module processes the perfusion (ASL, M0) images, from motion correction to registration to quantification and PV correction. Check for general ASL quality, vascular artifacts, good GM-WM contrast, WM-CSF contrast, artifacts on the temporal standard deviation (SD) images, geometrical distortion, and signal drop out from EPI susceptibility artifacts, whole-brain coverage (slice_gradient). Check also for registration to standard space, all images should be in the same position/orientation, i.e. meaning that you always see the same slices, with the same angulation. Check for motion artifacts as a bright halo around the CBF and temporal SD images. In a study QC report, you could show some worst, median, and best examples. Check (from left to right): //Population/ASLCheck/Tra_qCBF_untreated_*ASL_*.jpg for the CBF images without vascular treatment (qCBF*) //Population/ASLCheck/Tra_Reg_pWM_qCBF_untreated_*ASL_*.jpg for the ASL->T1w registration (T1w WM segmentation in red) //Population/SliceGradientCheck/SliceGradient_*.jpg for the orientation of native slices in MNI space If time-series exist (from left to right): //Population/RawSourceIMCheck/Tra_mean_control_*.jpg for the inspection of the average ASL source image //Population/SD_SNR/Tra_SD*ASL_*.jpg for the temporal SD image. This should be a smooth, noisy image, with only vascular peaks. //Population/MotionASL/rp_*ASL*motion.jpg to inspect subject motion (net displacement vector) //Population/MotionASL/rp_*ASL*threshold_free_spike_detection.jpg to inspect the performance of ENABLE If an M0 scan exists (from left to right): //Population/M0Check/Tra_noSmooth_M0_*_ASL*.jpg for the inspection of M0 //Population/M0_Reg_ASL/Tra_Reg_pGM_noSmooth_M0_*ASL*.jpg for the M0->T1w registration (pGM in red) //Population/M0_Reg_ASL/M0_im_proc_*.jpg for processing of M0 into a smooth bias field (masking & smoothing). Verify that the mask correctly removes the CSF & extracranial signal, to avoid smoothing of this into the M0 bias field. If population data exists (i.e. nScans>1 ): For a population data quality overview, inspect //Population/Templates/Template_mean_CBF.nii , as well as //Population/Templates/Template_sd_CBF.nii for the between-subject variation. Do the same for the other QC images if available. 6.1 Qualitative analysis: visual inspection in detail A) Reproduce some of the above JPG images by loading the NIfTIs, creating an overlay, and scrolling through To go through the images in more detail, we advise using Chris Rorden\u2019 mricron32.exe, which is a very light-weight, flexible, and easy-to-use tool. Please go to the population folder, and repeat the visual QC above in detail by opening the standard space NIfTIs. E.g., start with the original T1, resliced into standard space ( rT1_ORI*.nii(.gz) ), and then overlay the gray matter (GM) and/or white matter (WM) segmentations ( rc1T1*.nii(.gz) and rc2T1*.nii(.gz) respectively. You do this, by keeping the original T1 NIfTI open, in the top menu click \u2018Overlay\u2019 - \u2018Add\u2019 and select the NIfTI you want to overlay. Then you can select a color at the right drop-down menu. You can change the transparency of the overlay by \u2018Overlay\u2019 - \u2018Transparency on background\u2019. Then, keep the same NIfTI open, and start a second instance of mricron32, and load another NIfTI there, e.g. the FLAIR ( rFLAIR*.nii(.gz) ), note how you can scroll through both NIfTIs in sync. (if this doesn\u2019t work, you need to enable \u2018View\u2019 - \u2018Yoke\u2019 at both MRIcron instances). With the DEL key, you can activate the crosshair. You can layout the two MRIcron instances side-to-side by using the Windows key-Left Windows key-Right combination. B) Relate the ASL CBF image to the structural T1w image Load the ASL image ( qCBF*.nii(.gz) and notice how much lower its resolution is compared to the structural/anatomical images. Then open the T1w and ASL images side to side, to scroll through them in sync, and notice how this allows you to identify the structural reference of your ASL perfusion signal. Can you observe structural contrast in the ASL image? Do you see that the CBF is indeed higher in the GM than in the WM? C) Relate the temporal SD image to the structural T1w image Now do the same with the temporal SD image ( SD*.nii.(gz) , not SD_control* ), open it side-to-side with the T1w image. This image shows the temporal variations of the ASL signal. Where does this come from? D) Overlay the CBF image over the T1w image To create a nice visualization, open the T1w NIfTI, and then load the ASL CBF image as an overlay. Then choose a nice color scale, proper transparency, and play with the low and high-intensity thresholds, to create an overlay of the CBF image in \u2018false colors\u2019 over the grayscale anatomical NIfTI. Again, notice the relatively low resolution (i.e. blurriness/smooth appearance) of the ASL image. Try to make a really nice overlay! 6.2 Quantitative analysis: create region-of-interest (ROI)-based statistics E) Check the default, basic ROI overview of the data in //Population/Stats/*.tsv . These filenames are built up as: Values Description (mean\\|median\\|spatialCoV) The statistic: either the mean, median, or coefficient of variance over the ROI (qCBF_untreated) The input data (this can be anything, e.g. M0, pGM, FLAIR) (TotalGM\\|DeepWM\\|MNI_structural) The applied atlas, which specifies which ROIs to use (n=x) The number of subjects in the analysis (these are rows in the TSV file) (07-Mar-2019) The date of the analysis PVC(0\\|2) Partial volume correction (PVC) options: 0 (no PVC), 2 (two-compartment, classical PVC) In the Stats folder's files, if the same T1w is used for multiple runs ( ASL_1 , ASL_2 etc.), the values concerning the structural derivatives only (e.g. volumetrics and ratio) will be printed only for the first run. Start by opening \u2018mean_qCBF_untreated_MNI_structural_n=1_07-Mar-2019_PVC2.tsv\u2019. Notice that columns A to L are the \u2018covariates\u2019, whereas the remaining columns are the results of the ROI analysis. See the names of the MNI_structural atlas (Caudate, Cerebellum, Frontal, etc), and notice how from each of them, 3 columns are created, with the B (bilateral), L (left), or R (right) part of the ROI. F) Run an ROI analysis with a custom atlas 1) Pick an atlas Go to folder /ExploreASL/External/AtlasesNonCommercial and choose an atlas. Open the NIfTI file of the atlas, and notice how it has a label number for each ROI: you can see this number in the lower-left corner of MRIcron. By overlaying the atlas over the T1w of the subject, and creating a nice color scheme and transparency (e.g. color scheme \u2018NIH\u2019 and 60% transparency), and can see if you like the ROIs of this atlas for your analysis. Suggestions are \u2018Hammers\u2019, \u2018HOcort_CONN\u2019 (the CONN-toolbox version of the Harvard-Oxford atlas, cortical part), or HOsub_CONN (same as previous but subcortical part). Note how each NIfTI file of the atlases have their own .tsv file, which specifies the name of the ROIs (the column number corresponds to the label number in the NIfTI file). Remember the full path of the atlas NIfTI. Note that you can also provide your own atlas, as long as the ROIs contain the same label numbers in the NIfTI as in the .tsv file. 2) Pick a data type Pick the data type you want to perform your ROI analysis on, e.g. qCBF (see other available data types in the Population folder). 3) Restart ExploreASL For this, we first need to restart ExploreASL, but without running the whole analysis (since we already did this). Open Matlab, initialize ExploreASL using the command [x] = ExploreASL_Initialize;. To process a dataset you can use the ExploreASL function. Tell ExploreASL which dataset to load, by providing the path of your data parameter file to ExploreASL by running [x] = ExploreASL_(\u2018drive/folder/dataPar.son\u2019). Notice how this loads the dataset without any processing (i.e. without running the structural, ASL, or any other modules). 4) Run the ROI analysis, by typing in Matlab: x.S.InputDataStr = 'qCBF'; % (qCBF can be replaced by another datatype) x.S.InputAtlasPath = '/ExploreASL/External/AtlasesNonCommercial/HOcort_CONN.nii'; % (replace this by the atlas of your choice) xASL_wrp_GetROIstatistics(x); % (Note that this may provide a warning that x.Sequence is not defined yet, % if you haven't predefined any ASL sequence yet (which should go semi-automatically % with your own data). x.Sequence should contain your ASL sequence, e.g. x.Sequence % = \u20182D_EPI\u2019 (in the case of the TestDataSet)) E) Check the ROI analysis Repeat the steps in (E) above, but then with the correct atlas name. Note how the ROIs (columns M and upwards) are now the bilateral (B), left (L) and right (R) parts of the atlas you selected. Recommendable software Free software that is recommendable, includes: ExploreASL GUI to work with ExploreASL using a graphical user interface MRIcron , to open NIfTIs outside of Matlab/ExploreASL bids-matlab to work with files in BIDS format When not indicated otherwise, installation settings should be kept on default.","title":"Tutorials (QC)"},{"location":"Tutorials-QC/#tutorials-qc-quick-start","text":"Attention: Unfortunately, the following tutorial is outdated. We are working on an up-to-date version right now. This document provides a \u201cquick start\u201d walk-through for a dataset processed by ExploreASL. This can be either the attached example dataset (n=1) or a clinical study. It is always recommended to first test the compatibility of ExploreASL with the example dataset (Step 0 below), and to create a file report for steps 1-6, to get accustomed to the data and to make sure that ExploreASL runs properly. Note that ExploreASL is in development, so naming conventions may change, especially when we move to a complete BIDS adherence.","title":"Tutorials (QC - Quick Start)"},{"location":"Tutorials-QC/#0-run-testdataset-to-check-exploreasl-compatibility","text":"First, try to run the test data set. Note that according to good practice, it is important to separate code and data. The user should copy /ExploreASL/External/TestDataSet to a directory with read and write permissions outside of the ExploreASL toolbox, and keep the ExploreASL directory structure unchanged. Let\u2019s assume your copy of the TestDataSet is now in the folder /drive/folder/TestDataSet . Open Matlab, go to the directory of ExploreASL, run ExploreASL(\u2018drive/folder/TestDataSet/derivatives/ExploreASL/dataPar.json\u2019, 0, 1); to process the TestDataSet. The dataPar.json file in the example dataset contains all image processing and quantification parameters that ExploreASL needs. (Note that for your own study, you would need to create this parameter file. You can find a list of parameters in /ExploreASL/DataParTemplate.m ). If you only want to run a quick test, we recommend to set the Quality parameter within dataPar.json to 0. Please note that in the future, the structure of this test dataset will be replaced by the BIDS format. Also, you can add the same parameters to the JSON sidecars of the ASL NIfTI files, which will allow processing ASL scans with different parameters within the same study. In the case of a multi-center study, and/or multiple sequences or scanner updates, the JSON sidecars allow to have different ASL parameters within a single study. Upon successful completion of the processing, ExploreASL creates a result file ( //Population/Stats/ median_qCBF_(Native|Standard)Space_total_GM_n=1_*_PVC0.tsv ). Verify that the GM CBF here (without partial volume (PV) correction, i.e. PVC0)) is approximately 65 mL/100g/min . If this file does not exist, then there could be a problem with ExploreASL compatibility. If the file exists and values are the same as reported here, then your software and hardware are ExploreASL compatible. In case ExploreASL processing runs for the example data set and not for other datasets then the problem is probably data related and not compatibility related. When you perform this walkthrough on your own data, there are three first main cases to note: Data completeness, note down any data that was not imported or somehow not got processed; Proper processing, check visually whether the processing went well, e.g. nicely segmented and registered; Large anatomical deviations, check visually if there are large anatomical variations that can make subjects outliers","title":"0. Run TestDataSet to check ExploreASL compatibility"},{"location":"Tutorials-QC/#1-data-inclusion","text":">> dataPar = '\\drive\\TestDataSet\\derivatives\\ExploreASL\\dataPar.json'; >> [x] = ExploreASL_Master(dataPar,0,1,1); ExploreASL will run the processing pipeline... ============================================================================================== ________ __ ______ ______ __ / | / | / \\ / \\ / | ########/ __ __ ______ ## | ______ ______ ______ /###### |/###### |## | ## |__ / \\ / | / \\ ## | / \\ / \\ / \\ ## |__## |## \\__##/ ## | ## | ## \\/##/ /###### |## |/###### |/###### |/###### |## ## |## \\ ## | #####/ ## ##< ## | ## |## |## | ## |## | ##/ ## ## |######## | ###### |## | ## |_____ /#### \\ ## |__## |## |## \\__## |## | ########/ ## | ## |/ \\__## |## |_____ ## |/##/ ## |## ##/ ## |## ##/ ## | ## |## | ## |## ##/ ## | ########/ ##/ ##/ #######/ ##/ ######/ ##/ #######/ ##/ ##/ ######/ ########/ ## | ## | ##/ ==================================== ExploreASL Settings ===================================== DataParPath \\drive\\TestDataSet\\derivatives\\ExploreASL\\dataPar.json Import Modules Process Modules Structural ASL Population bPause True iWorker 1 nWorkers 1 ============================================================================================== ExploreASL v1.5.1 initialized ... Automatically defining sessions... ==================================== Additional Settings ===================================== 1 scans - 0 exclusions, resulting in 1 scans of: Longitudinal timePoint 1 = 1 scans - 0 exclusions = 1 scans ASL sessions: 1 Ancillary data, sets: 3 sets are defined for 1 \"SubjectsSessions\" Set 1 = \"LongitudinalTimePoint\" options \"TimePoint_1\", codes for paired data Set 2 = \"SubjectNList\" options \"SubjectNList\", codes for paired data Set 3 = \"Site\" options \"SingleSite\", codes for two-sample data x.D.ROOT \\drive\\TestDataSet\\derivatives\\ExploreASL x.DELETETEMP 1 (delete temporary files) x.Quality 1 (0 = fast try-out; 1 = normal high quality) ============================================================================================== Press any key to start processing & analyzing Please ensure you have a read-only copy of your original data as they may be overwritten Or press CTRL/command-C to cancel... You should obtain a similar initial screen showing which subjects and scans are found to be processed (how many exclusions, how many subjects for each time point etc.), as well as potentially included co-variates (e.g. site, age, cohort, sex). Note that we run the pipeline on low quality ( x.Quality=0 ): while this will provide poorer results (segmentation, registration, etc) this will allow us to quickly test the full pipeline. On a relatively new computer, the full pipeline should run either within 5-10 min ( x.Quality=0 ) or 30-60 min ( x.Quality=1 ).","title":"1. Data inclusion"},{"location":"Tutorials-QC/#2-missing-files","text":"Check the files //ROOT/Missing*Files.csv . These provide an overview of any missing files. Files can either be missing when they are not imported ( Missing*NativeFiles.csv , for native space files), or when they are not processed (mainly Missing*MNIFiles.csv , for MNI space files). If no files are specified in these files, or they do not exist, this means that there were no missing files.","title":"2. Missing files"},{"location":"Tutorials-QC/#3-qc-structural-module","text":"The structural module processes the anatomical (T1-weighted, T1w) images, to provide segmentations/partial volume (PV) maps and for spatial normalization to MNI space. Optionally, if FLAIR images exist, these are used to correct the white matter hyperintensities (WMH) on the T1w images. Check (from left to right): //Population/T1Check/Tra_Src_rT1_*.jpg for T1w quality, structural anomalies, normalization to MNI //Population/T1Check/Tra_Reg_rT1_*.jpg same as previous, but after lesion filling (if FLAIR exists) //Population/T1Check/Tra_Seg_rT1_*.jpg for T1w segmentation (WM segmentation in red) //Population/TissueVolume/Tissue_volume_*.tsv for the GM, WM and CSF volumes Note that all QC images are prefixed with \u2018Tra_\u2019 (transversal/axial)/ \u2018Cor_\u2019 (coronal) or \u2018Sag_\u2019 (sagittal) denoting the plane of the slices. Check, if FLAIR exists (from left to right): //Population/FLAIRCheck/Tra_Src_rFLAIR_*.jpg for FLAIR quality, structural anomalies //Population/FLAIRCheck/Tra_Reg_rFLAIR_*reg.jpg for WMH segmentation, compare with previous //Population/FLAIR_REGDIR/Tra_Seg_rFLAIR_*reg.jpg for registration FLAIR->T1w (red=T1w WM segmentation) //Population/TissueVolume/WMH_LST_*.tsv for the WMH Total Lesion Volume (TLV) and number (N) of WMH For a population data quality overview (if nScans>1), inspect //Population/Templates/Template_mean_T1.nii, as well as //Population/Templates/Template_sd_T1.nii for the between-subject variation. Do the same for pGM and pWM, and FLAIR and WMH_SEGM if available.","title":"3. QC structural module"},{"location":"Tutorials-QC/#4-dicom-values","text":"//Population/DICOMparameters/ASL4D_quantification_parameters.csv and //Population/DICOMparameters/M0_quantification_parameters.csv summarize the data in the files //ROOT/SubjectName/ASL_1/ASL4D_parms.mat and //ROOT/SubjectName/ASL_1/M0_parms.mat , including the different DICOM header parameters that are imported and can be used in the quantification process. It is important to check that the TR, TE, and scale slopes are comparable for all scans on a single scanner. If not, they allude to situations where the scans were performed with not completely similar protocols, due to e.g. a software update, or use of different scanners. Ignoring this can lead to undesired variance in the whole-brain CBF quantification.","title":"4. DICOM values"},{"location":"Tutorials-QC/#5-qc-of-asl-module","text":"The ASL module processes the perfusion (ASL, M0) images, from motion correction to registration to quantification and PV correction. Check for general ASL quality, vascular artifacts, good GM-WM contrast, WM-CSF contrast, artifacts on the temporal standard deviation (SD) images, geometrical distortion, and signal drop out from EPI susceptibility artifacts, whole-brain coverage (slice_gradient). Check also for registration to standard space, all images should be in the same position/orientation, i.e. meaning that you always see the same slices, with the same angulation. Check for motion artifacts as a bright halo around the CBF and temporal SD images. In a study QC report, you could show some worst, median, and best examples. Check (from left to right): //Population/ASLCheck/Tra_qCBF_untreated_*ASL_*.jpg for the CBF images without vascular treatment (qCBF*) //Population/ASLCheck/Tra_Reg_pWM_qCBF_untreated_*ASL_*.jpg for the ASL->T1w registration (T1w WM segmentation in red) //Population/SliceGradientCheck/SliceGradient_*.jpg for the orientation of native slices in MNI space If time-series exist (from left to right): //Population/RawSourceIMCheck/Tra_mean_control_*.jpg for the inspection of the average ASL source image //Population/SD_SNR/Tra_SD*ASL_*.jpg for the temporal SD image. This should be a smooth, noisy image, with only vascular peaks. //Population/MotionASL/rp_*ASL*motion.jpg to inspect subject motion (net displacement vector) //Population/MotionASL/rp_*ASL*threshold_free_spike_detection.jpg to inspect the performance of ENABLE If an M0 scan exists (from left to right): //Population/M0Check/Tra_noSmooth_M0_*_ASL*.jpg for the inspection of M0 //Population/M0_Reg_ASL/Tra_Reg_pGM_noSmooth_M0_*ASL*.jpg for the M0->T1w registration (pGM in red) //Population/M0_Reg_ASL/M0_im_proc_*.jpg for processing of M0 into a smooth bias field (masking & smoothing). Verify that the mask correctly removes the CSF & extracranial signal, to avoid smoothing of this into the M0 bias field. If population data exists (i.e. nScans>1 ): For a population data quality overview, inspect //Population/Templates/Template_mean_CBF.nii , as well as //Population/Templates/Template_sd_CBF.nii for the between-subject variation. Do the same for the other QC images if available.","title":"5. QC of ASL module"},{"location":"Tutorials-QC/#61-qualitative-analysis-visual-inspection-in-detail","text":"A) Reproduce some of the above JPG images by loading the NIfTIs, creating an overlay, and scrolling through To go through the images in more detail, we advise using Chris Rorden\u2019 mricron32.exe, which is a very light-weight, flexible, and easy-to-use tool. Please go to the population folder, and repeat the visual QC above in detail by opening the standard space NIfTIs. E.g., start with the original T1, resliced into standard space ( rT1_ORI*.nii(.gz) ), and then overlay the gray matter (GM) and/or white matter (WM) segmentations ( rc1T1*.nii(.gz) and rc2T1*.nii(.gz) respectively. You do this, by keeping the original T1 NIfTI open, in the top menu click \u2018Overlay\u2019 - \u2018Add\u2019 and select the NIfTI you want to overlay. Then you can select a color at the right drop-down menu. You can change the transparency of the overlay by \u2018Overlay\u2019 - \u2018Transparency on background\u2019. Then, keep the same NIfTI open, and start a second instance of mricron32, and load another NIfTI there, e.g. the FLAIR ( rFLAIR*.nii(.gz) ), note how you can scroll through both NIfTIs in sync. (if this doesn\u2019t work, you need to enable \u2018View\u2019 - \u2018Yoke\u2019 at both MRIcron instances). With the DEL key, you can activate the crosshair. You can layout the two MRIcron instances side-to-side by using the Windows key-Left Windows key-Right combination. B) Relate the ASL CBF image to the structural T1w image Load the ASL image ( qCBF*.nii(.gz) and notice how much lower its resolution is compared to the structural/anatomical images. Then open the T1w and ASL images side to side, to scroll through them in sync, and notice how this allows you to identify the structural reference of your ASL perfusion signal. Can you observe structural contrast in the ASL image? Do you see that the CBF is indeed higher in the GM than in the WM? C) Relate the temporal SD image to the structural T1w image Now do the same with the temporal SD image ( SD*.nii.(gz) , not SD_control* ), open it side-to-side with the T1w image. This image shows the temporal variations of the ASL signal. Where does this come from? D) Overlay the CBF image over the T1w image To create a nice visualization, open the T1w NIfTI, and then load the ASL CBF image as an overlay. Then choose a nice color scale, proper transparency, and play with the low and high-intensity thresholds, to create an overlay of the CBF image in \u2018false colors\u2019 over the grayscale anatomical NIfTI. Again, notice the relatively low resolution (i.e. blurriness/smooth appearance) of the ASL image. Try to make a really nice overlay!","title":"6.1 Qualitative analysis: visual inspection in detail"},{"location":"Tutorials-QC/#62-quantitative-analysis-create-region-of-interest-roi-based-statistics","text":"E) Check the default, basic ROI overview of the data in //Population/Stats/*.tsv . These filenames are built up as: Values Description (mean\\|median\\|spatialCoV) The statistic: either the mean, median, or coefficient of variance over the ROI (qCBF_untreated) The input data (this can be anything, e.g. M0, pGM, FLAIR) (TotalGM\\|DeepWM\\|MNI_structural) The applied atlas, which specifies which ROIs to use (n=x) The number of subjects in the analysis (these are rows in the TSV file) (07-Mar-2019) The date of the analysis PVC(0\\|2) Partial volume correction (PVC) options: 0 (no PVC), 2 (two-compartment, classical PVC) In the Stats folder's files, if the same T1w is used for multiple runs ( ASL_1 , ASL_2 etc.), the values concerning the structural derivatives only (e.g. volumetrics and ratio) will be printed only for the first run. Start by opening \u2018mean_qCBF_untreated_MNI_structural_n=1_07-Mar-2019_PVC2.tsv\u2019. Notice that columns A to L are the \u2018covariates\u2019, whereas the remaining columns are the results of the ROI analysis. See the names of the MNI_structural atlas (Caudate, Cerebellum, Frontal, etc), and notice how from each of them, 3 columns are created, with the B (bilateral), L (left), or R (right) part of the ROI. F) Run an ROI analysis with a custom atlas 1) Pick an atlas Go to folder /ExploreASL/External/AtlasesNonCommercial and choose an atlas. Open the NIfTI file of the atlas, and notice how it has a label number for each ROI: you can see this number in the lower-left corner of MRIcron. By overlaying the atlas over the T1w of the subject, and creating a nice color scheme and transparency (e.g. color scheme \u2018NIH\u2019 and 60% transparency), and can see if you like the ROIs of this atlas for your analysis. Suggestions are \u2018Hammers\u2019, \u2018HOcort_CONN\u2019 (the CONN-toolbox version of the Harvard-Oxford atlas, cortical part), or HOsub_CONN (same as previous but subcortical part). Note how each NIfTI file of the atlases have their own .tsv file, which specifies the name of the ROIs (the column number corresponds to the label number in the NIfTI file). Remember the full path of the atlas NIfTI. Note that you can also provide your own atlas, as long as the ROIs contain the same label numbers in the NIfTI as in the .tsv file. 2) Pick a data type Pick the data type you want to perform your ROI analysis on, e.g. qCBF (see other available data types in the Population folder). 3) Restart ExploreASL For this, we first need to restart ExploreASL, but without running the whole analysis (since we already did this). Open Matlab, initialize ExploreASL using the command [x] = ExploreASL_Initialize;. To process a dataset you can use the ExploreASL function. Tell ExploreASL which dataset to load, by providing the path of your data parameter file to ExploreASL by running [x] = ExploreASL_(\u2018drive/folder/dataPar.son\u2019). Notice how this loads the dataset without any processing (i.e. without running the structural, ASL, or any other modules). 4) Run the ROI analysis, by typing in Matlab: x.S.InputDataStr = 'qCBF'; % (qCBF can be replaced by another datatype) x.S.InputAtlasPath = '/ExploreASL/External/AtlasesNonCommercial/HOcort_CONN.nii'; % (replace this by the atlas of your choice) xASL_wrp_GetROIstatistics(x); % (Note that this may provide a warning that x.Sequence is not defined yet, % if you haven't predefined any ASL sequence yet (which should go semi-automatically % with your own data). x.Sequence should contain your ASL sequence, e.g. x.Sequence % = \u20182D_EPI\u2019 (in the case of the TestDataSet)) E) Check the ROI analysis Repeat the steps in (E) above, but then with the correct atlas name. Note how the ROIs (columns M and upwards) are now the bilateral (B), left (L) and right (R) parts of the atlas you selected. Recommendable software Free software that is recommendable, includes: ExploreASL GUI to work with ExploreASL using a graphical user interface MRIcron , to open NIfTIs outside of Matlab/ExploreASL bids-matlab to work with files in BIDS format When not indicated otherwise, installation settings should be kept on default.","title":"6.2 Quantitative analysis: create region-of-interest (ROI)-based statistics"}]}